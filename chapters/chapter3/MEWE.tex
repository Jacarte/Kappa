
\msection{MEWE: Multi-variant Execution for WebAssembly}
\label{section:mewe}

\renewcommand{\tool}{MEWE\xspace}
% Overview
This section describes MEWE \cite{MEWE}. 
\tool synthesizes diversified function variants by using CROW.
It then provides execution-path randomization in a Multivariant Execution (MVE).
MEWE generates application-level multivariant binaries without changing the operating system or \wasm\ runtime.
It creates an MVE by intermixing functions for which CROW generates variants, as illustrated by the green square in \autoref{fig:approach_landscape}.
\tool inlines function variants when appropriate, resulting in call stack diversification at runtime.



In \autoref{workflow}, we focus on MEWE, highlighted in green in \autoref{fig:approach_landscape}. 
MEWE takes the LLVM IR variants generated by CROW's diversifier. 
It then merges LLVM IR variants into a Wasm multivariant.
In the figure, we highlight the two components of MEWE, \emph{Multivariant Generation} and the \emph{Mixer}.
In the \emph{Multivariant Generation} process, 
MEWE merges the LLVM IR variants created by CROW and creates an LLVM multivariant binary.
The merging of the variants intermixes the calling of function variants, allowing the execution path randomization.

\emph{The Mixer} augments the LLVM multivariant binary with a random generator. 
The random generator is needed to perform the execution-path randomization.
Also, \emph{The Mixer} fixes the entrypoint in the multivariant binary.
Finally, using the same custom Wasm LLVM backend as CROW, MEWE generates a standalone multivariant \wasm\ binary.
Once generated, the multivariant \wasm\ binary can be deployed to any \wasm\ engine. 

\begin{figure*}
  \centering
  \includegraphics[height=3.2in]{diagrams/MEWE.pdf}
  \caption{Overview of \tool workflow. It takes as input an LLVM binary. It first generates a set of functionally equivalent variants for each function in the binary using CROW. Then, MEWE generates an LLVM multivariant binary composed of all the function variants. Finally, the Mixer includes the behavior in charge of selecting a variant when a function is invoked. Finally, the \tool mixer composes the LLVM multivariant binary with a random number generation library and tampers the original application entrypoint. The final process produces a \wasm\ multivariant binary ready to be deployed. Figure partially taken from \cite{Lic}. }
  \label{workflow}
\end{figure*}


\msubsection{Multivariant generation}


The key component of \tool consists in combining the variants into a single binary.
The goal is to support execution-path randomization at runtime.
The core idea is to introduce one dispatcher function per original function with variants.
A dispatcher function is a synthetic function in charge of choosing a variant at random when the original function is called.
With the introduction of the dispatcher function,  \tool turns the original call graph into a multivariant call graph, defined as follows. 


\begin{figure}
    \centering
  \includegraphics[width=.8\linewidth]{diagrams/CFG.png}
  \caption{Example of two static call graphs. At the top, the original call graph, at the bottom, the multivariant call graph, which includes nodes that represent function variants (in gray), dispatchers (in green), and original functions  (in yellow). Figure taken from \cite{Lic}.
}
  \label{multivariant}
\end{figure}

% Instance of a multivariant module
In \autoref{multivariant}, we show the original static call graph for an original program (top of the figure), as well as the multivariant call graph generated with \tool (bottom of the figure).
The gray nodes represent function variants, the green nodes function dispatchers, and the yellow nodes are the original functions.
The directed edges represent the possible calls.
The original program includes three functions. \tool generates 43 variants for the first function, none for the second, and three for the third. 
\tool introduces two dispatcher nodes for the first and third functions. Each dispatcher is connected to the corresponding function variants to invoke one variant randomly at runtime.


\lstset{
    language=llvm,
    %style=nccode,
    basicstyle=\footnotesize\ttfamily,
    columns=fullflexible,
    breaklines=true,
    numbers=none,
    stepnumber=1,
    float
}

\begin{minipage}[t]{0.9\linewidth}
\scriptsize
\centering
\noindent\begin{minipage}[b]{\linewidth}
    \begin{minipage}[t]{1\linewidth}
        \begin{lstlisting}[escapeinside={(*}{*)}]
define internal i32 @foo(i32 %0) {
    entry:
      %1 = call i32 @discriminate(i32 3)
      switch i32 %1, label %end [
        i32 0, label %case_43_
        i32 1, label %case_44_
      ]
    case_43_:                 
      %2 = call i32 @foo_43_(%0)
      ret i32 %2
    case_44_:                
      %3 = <body of foo_44_ inlined>
      ret i32 %3
    end:                                             
      %4 = call i32 @foo_original(%0)
      ret i32 %4
}
        \end{lstlisting}
    \end{minipage}%
    
    \noindent\rule{\linewidth}{0.4pt}
    \captionof{lstlisting}{Dispatcher function embedded in the multivariant binary of the original function in the rightmost green node in \autoref{multivariant}.}\label{listing:multivariant_template}
\end{minipage}
\end{minipage}

% exaplanation of dispatcher
In  \autoref{listing:multivariant_template}, we illustrate the LLVM construction for the function dispatcher corresponding to the right most green node of \autoref{multivariant}.
It first calls the random generator, which returns a value used to invoke a specific function variant. 
We utilize a switch-case structure in the dispatchers to prevent indirect calls, which are vulnerable to speculative execution-based attacks \cite{Narayan2021Swivel}.
The choice of a switch-case also avoids having multiple function definitions with the same signature, which could increase the attack surface in case the function signature is vulnerable \cite{johnson2021}.
This also allows \tool to inline function variants inside the dispatcher instead of defining them again.
% Move the following to the Evaluation of MEWE part
% Here we trade security over performance since dispatcher functions that perform indirect calls, instead of a switch-case,  could improve the performance of the dispatchers as indirect calls have constant time.
%It should be noted that the dispatcher function is constructed using the same signature as the original function. 


%\msubsection{MEWE's Mixer}

%\todo{Augment the description of the MIXER.}

MEWE has four specific objectives: link the LLVM multivariant binary, inject a random generator, tamper the application's entrypoint, and merge all these components into a multivariant \wasm\ binary.
We use the Rustc compiler\footnote{\url{https://doc.rust-lang.org/rustc/what-is-rustc.html}} to orchestrate the mixing.
For the random generator, we rely on WASI's specification \cite{WASI} for the random behavior of the dispatchers. 
However, its exact implementation is dependent on the platform on which the binary is deployed.
The Mixer component of MEWE creates a new entrypoint for the binary called \emph{entrypoint tampering}.
It wraps the dispatcher for the entrypoint variants as a new function for the final Wasm binary and is declared as the application entrypoint. 


\begin{tcolorbox}[title=Contribution paper and artifact,boxrule=1pt,arc=.2em,boxsep=1.0mm]
  MEWE is fully presented in Cabrera-Arteaga \etal "Multi-Variant Execution at the Edge"
  \emph{Conference on Computer and Communications Security, MTD}
 \url{https://dl.acm.org/doi/abs/10.1145/3560828.3564007}
 \\\\
 MEWE is also available as an open-source tool at \url{https://github.com/ASSERT-KTH/MEWE}
\end{tcolorbox}