
\msection{Comparing CROW, MEWE and WASM-MUTATE}

In this section we discuss the main differences between CROW, MEWE and WASM-MUTATE.
We discuss the main differences between CROW, MEWE and WASM-MUTATE according to three main dimensions: 1) the technology and approach of each one, 2) the strength of the generated variants and, 3) the security guarantees of the variants generated by each tool.
We select these three dimensions because they lead the implementation of our tools.
Besides, we provide the artifacts for each one of the tools.

\msubsection{Technology and approach}
CROW is a compiler-based strategy, needing access to the original source code or its LLVM IR representation to work. 
Its core is a Satisfiability Modulo Theories (SMT) solver, ensuring the functional equivalence of the generated variants.
This approach lays the groundwork for a universal LLVM superdiversifier, potentially extending its applications and adaptability to other technologies.
MEWE extends the capabilities of CROW, utilizing the same underlying technology to create program variants. 
It goes a step further by packaging the LLVM IR variants into a Wasm multivariant, providing MVE through execution path randomization.

On the other hand, WASM-MUTATE is a semi-automated, binary-based tool, centralizing its core around e-graph traversals. 
This approach facilitates the creation of a pool of \Wasm program variants through the meticulous application of rewriting rules on an e-graph data structure. 
This method removes the need for compiler adjustments, offering compatibility with any existing \Wasm binary. 
Moreover, it highlights how extending intermediate representations could establish a general framework for binary rewriting in \Wasm.

\msubsection{Strength of the generated variants}
CROW and MEWE use enumerative synthesis and verify semantic equivalence through SMT solvers. 
This approach not only has the potential to exceed handcrafted optimizations but also ensures that the transformations are \temph{preserved}. 
In other words, the transformations generated out of CROW and MEWE are virtually irreversible, even following compiler optimizations. 
This is particularly remarkable in the case of \emph{constant inferring} transformations (see \autoref{CROW:constant_inferring}). 
Furthermore, the use of enumerative synthesis allows the generated variants to potentially improve the original program's runtime performance, demystifying that software diversification inherently compromises performance. 
While CROW and MEWE do not require any extra input but the program to diversify, the speed of variant generation is intrinsically linked to the SMT solvers' efficiency, known to be slow. 
Besides, their variants generation capabilities are limited by the \emph{overlapping} phenomenon discussed in \autoref{section:crow:example}.

On the other hand, WASM-MUTATE adopts a semi-automatic approach, requiring users to set the rewriting rules. Thus, the responsibility of ensuring functional equivalence is transferred to the rule creation process.
This tool offers a significant advantage over CROW and MEWE by allowing transformations to any section of a \wasm program, being not limited to the code section. 
Moreover, it benefits from a virtually cost-free e-graph traversal process and avoids the \emph{overlapping}  issue seen in CROW and MEWE, as detailed in \autoref{section:crow:example}. 
In addition, since WASM-MUTATE operates at the binary level, it can modify functions incorporated by the \Wasm producer itself.
For example, this is the case of the \emph{wasm32-wasi} architecture.
While the original program might have a few lines of code, the underlying compiler might inject more functions to support the \emph{wasm32-wasi} architecture.
Thus, augmenting the diversification space available to WASM-MUTATE.

WASM-MUTATE outperforms CROW and MEWE capabilities in terms of number of generated variants.
Yet, the changes made by WASM-MUTATE might not be as preserved as the ones generated by CROW and MEWE.
Thus, the variants generated by WASM-MUTATE might be more susceptible to be reversed, e.g. by further optimization passes.


\msubsection{Security guarantees}
CROW and MEWE generate distinct and highly preserved code variants. 
This means that these variants, each with unique \Wasm codes, maintain their distinctiveness even after JIT compilers translate them into machine codes. 
This distinctive feature significantly reduces the impact to side-channel attacks that exploit specific machine code instructions, e.g., port contention \cite{10.1145/3488932.3517411}.
WASM-MUTATE, while offering slightly reduced preservation in its generated variants compared to CROW and MEWE, still maintains the same security guarantees excepting the multivariant cases.
Its ability to produce a greater number of variants can offset this preservation shortfall.


Furthermore, CROW and MEWE enhance security against timing-based attacks by creating variants that exhibit a wide range of execution times. 
This strategy is especially prominent in MEWEâ€™s approach, which develops multivariants functioning on randomizing execution paths, thereby thwarting attempts at timing-based inference attacks. 
Consequently, attackers might find it exceedingly difficult to identify a specific variant through time profiling of a MEWE multivariant (ee section \autoref{usecasetime}).
Adding another layer to this security framework, the integration of diverse variants into multivariants can potentially disrupt the functioning of dynamic analysis tools such as symbolic executors \cite{opaque predicate}. 
For example, different control flows through a random discriminator, which exponentially increases the number of paths, rendering them virtually unexplorable.



An advantege of WASM-MUTATE, compared to CROW and MEWE, is its capacity to transform non-code sections without impacting the runtime behavior of the original variant, a strategy that effectively shields against static binary analysis, including malware detection based on signature sets \cite{CABRERAARTEAGA2023103296}.
For instance, it can modify the type section of a \Wasm program, a section typically utilized only for function signature validation during compilation and validation processes by the host engine. 
This thwarts compiler identification techniques, such as fingerprinting.
Besides, it can be used for masquerading as a different compilation source.
Thus, reducing the fingerprinting surface available to attackers.


CROW, MEWE, and WASM-MUTATE all have the capability to alter the original program structure, either by eliminating dead code or by introducing additional elements. 
From a static perspective, such alterations serve to reduce potential attack surfaces, thereby impeding signature-based identification techniques as noted in \cite{CABRERAARTEAGA2023103296}.
Modifying the layout of a \Wasm program invariably affects its unmanaged memory during runtime, a segment not overseen by the \Wasm program itself (see section \autoref{background:wasm:memory} for a detailed discussion on unmanaged memory). 
This aspect is especially important for CROW and MEWE, given that they do not directly address the \Wasm memory model, i.e., they do not directly diversify memory accesses. 
For example, the \emph{constant inferring} transformations, which significantly alter the layout of program variants, affects unmanaged memory elements such as the returning address of a function.


Furthermore, WASM-MUTATE not only affects unmanaged memory through changes in the \Wasm program layout.
It also adds rewriting rules to transform managed memory instructions. 
Memory alterations, either to the unmanaged or managed memories, have substantial implications for security. 
For instance, they can counteract attacks by eliminating potential jump points that facilitate malicious activities within the binary, a preventive measure highlighted by Narayan et al. \cite{Swivel}.

\msection{Accompanying artifacts}

This thesis is accompanied by the source code of the three contributions, CROW, MEWE and WASM-MUTATE. 
The source code is accessible through the links:
\begin{enumerate}
    \item CROW: \url{https://github.com/ASSERT-KTH/slumps}
    %\item Customized LLVM backend: \url{https://github.com/Jacarte/llvm-project}
    \item MEWE: \url{https://github.com/ASSERT-KTH/MEWE}
    \item WASM-MUTATE: \url{https://github.com/bytecodealliance/wasm-tools/tree/main/crates/wasm-mutate}
\end{enumerate}

Our software artifacts are licensed under the MIT License. The dependent source codes, such as LLVM, are licensed under their original conditions.

\msection{Conclusions}

In this chapter we discuss the technical specifics underlying our primary technical contributions.
We elucidate the mechanisms through which CROW generates program variants.
Following this, we outline the conceptual framework for a universal LLVM superdiversifier, laying a foundation for broader applicability and versatility.
Subsequently, we discuss MEWE, offering a detailed examination of its role in forging MVE for \Wasm. 
We also explore the details of WASM-MUTATE, highlighting its pioneering utilization of an e-graph traversal algorithm to spawn \wasm program variants. 
Remarkably, we undertake a comparative analysis of the three tools, delineating their respective benefits and limitations, alongside the potential security assurances they provide upon the program variants derived from them. 

In \autoref{chapter:method}, we present four use cases that support the exploitation of these tools.
\autoref{chapter:method} serves to bridge theory with practice, showcasing the tangible impacts and benefits realized through the deployment of CROW, MEWE, and WASM-MUTATE.
