
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%% CHAPTER 1: INTRODUCTION %%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
\label{Intro}

\chapterprecishere{\input{quotes/cinderella1.tex}\par\raggedleft--- {\small\textup{MR. Cox} \textbf{1893}, Cinderella: Three hundred and forty-five variants \cite{cox1893cinderella}}}

\lettrine[lines=3]{T}{he} first web browser, Nexus, made its appearance in 1990 \cite{nexus}. 
At its inception, web browsing consisted solely of retrieving and displaying small, static textual web pages. 
In simpler terms, users could only read page content without any interactive components. 
However, the escalating computing power of devices, the proliferation of the internet, the valuation of internet-based companies and the demand for more engaging user experiences gave rise the concept of executing code in conjunction with web pages. 
In 1995, the Netscape browser revolutionized this concept by introducing JavaScript \cite{10.1007/978-3-642-14107-2_7}, a programming language that allowed code execution on the client-side.
Interactive web content immediately highlighted benefits: unlike classical native software, web applications do not require installation, are always up-to-date, and are accessible from any device with a web browser. 
Significantly, since the advent of Netscape, all browsers offer JavaScript support. 
In the present day, the majority of web pages incorporate not only HTML but also JavaScript code, which is executed on client computers. 
Over the past several decades, web browsers have transformed into JavaScript virtual machines. 
They have evolved into intricate systems capable of running comprehensive applications, such as video and audio players, animation creators, and PDF document renderers, like the one displaying this document.

JavaScript is presently the most widely utilized scripting language in all contemporary web browsers \cite{mulazzani2013fast}.
However, it is not without limitations due to the inherent characteristics of the language.
For instance, each JavaScript engine necessitates the parsing and recompiling of the JavaScript code, resulting in substantial overhead.
Just parsing and compiling JavaScript code consumes the majority of the load times of websites \cite{clark}.
In addition to performance limitations, JavaScript also has security concerns \cite{10.1145/1190216.1190252}.
A notable example of this is the lack of memory isolation in JavaScript, which allows extraction of information from other processes \cite{10.1145/3412841.3442001}.
These issues led the Web Consortium (W3C) to standardize a bytecode for the web environment in 2015, which is the \Wasm(Wasm) language.
Hence, \Wasm became the fourth official language for the web.


\Wasm is designed with a focus on speed, portability, self-containment, and security \cite{Haas_2017}. 
It enables the ahead-of-time compilation of all programs from source languages such as C/C++ and Rust. 
Third-party compilers produce \Wasm binaries, which may be optimized, as is the case of LLVM. 
\Wasm bytecode format abstracts its Instruction Set Architecture, making it akin to machine code instructions but independent of CPU architectures \cite{wasm_spec}. 
Resembling machine code, \Wasm is already optimized and consists of consecutive binary sections. 
The contiguous array organization of a \Wasm binary enables efficient processing, allowing compilers to speed up compilation through parallel parsing. 
Wasm binaries not only validate and compile rapidly but are also quick to transmit over a network.

\Wasm's versatility extends beyond web browsers to backend scenarios. 
Studies have highlighted the benefits of using WebAssembly as an intermediate layer. 
These benefits include improved startup times and enhanced memory usage. 
This performance surpasses alternative solutions such as containerization and virtualization \cite{pMendkiServerless, 1244493Jacobsson}. 
The Bytecode Alliance consequently proposed the WebAssembly System Interface (WASI) in 2019 \cite{bytecodealliance, WASI}.
WASI standardized the execution of \Wasm utilizing a POSIX system interface protocol, thus enabling \Wasm's direct execution in the operating system.
Despite \Wasm's strong potential to resolve enduring issues in the web environment and its benefits in standalone executions, it introduces new challenges.

\msection{\Wasm security}

WebAssembly is praised for its security, especially for its design that prevents programs from accessing data beyond their own memory. 
However, there has been less focus on potential vulnerabilities and attacks within WebAssembly's own memory \cite{usenixWasm2020}.

Remarkably, WebAssembly binaries can have inherent vulnerabilities due to source code flaws. 
For example, the absence of stack-smashing protections like stack canaries in code compiled to WebAssembly could lead to undetected overflows in \Wasm, causing crashes \cite{DeRoover2022} in standalone deployments.


Moreover, significant risks exist from side-channel attacks on WebAssembly.
In browsers, Rokicki \etal revealed the risk for port contention side-channel attacks on \Wasm binaries in browsers \cite{10.1145/3488932.3517411}. 
In standalone deployments, Genkin \etal demonstrated the potential for data extraction via cache timing-side channels in \Wasm \cite{Genkin2018DrivebyKC}. 
Similarly, Maisuradze and Rossow showed speculative execution attacks on \Wasm binaries \cite{ret2spec}. 


\msection{Software Monoculture}

Web browsers and JavaScript have evolved significantly in the past thirty years, leading to numerous implementations. 
Yet, only Firefox, Chrome, Safari, and Edge are commonly used on devices.
This situation reflects a software monoculture problem wherein a single flaw could impact multiple applications. 
The concept of monoculture is borrowed from biology and symbolizes an ecosystem at risk of extinction due to shared vulnerabilities and lack of diversity. 
Currently, web pages including WebAssembly binaries are centrally served from main servers. 
Thus, this monoculture issue is also applicable to the \Wasm code served to web browsers. 
Despite its design for secure execution and sandboxing, Wasm is not immune to vulnerabilities. 
Therefore, sharing Wasm code through web browsers could also share its vulnerabilities. 

The software monoculture problem exacerbates when considering the edge-cloud computing platforms and their adoption of \Wasm to provide services.
Specifically, in addition to browser clients, thousands of edge devices running \Wasm as backend services could be affected by shared vulnerabilities. 
This scenario suggests that if one node in an edge network is vulnerable, all the others would be vulnerable in the exact same way since the same binary is replicated on each node. 
In simpler terms, the same attacker payload could compromise all edge nodes simultaneously, meaning that a single distributed Wasm binary could trigger a worldwide attack.

\msection{\Wasm evasion }


\Wasm is often used in browsers for computation-intensive activities, including gaming and image processing, but it has also been exploited by malicious actors for cryptojacking \cite{10.1145/3339252.3339261}.
The popularity of \Wasm for cryptojacking stems from its ability to execute a high volume of hash functions. 
This task needs substantial computing resources, and \Wasm outperforms JavaScript in speed.
Besides, \Wasm code's poor readability makes it a convenient tool for obfuscating harmful code.
Cryptojacking via WebAssembly often involves a malicious JavaScript+\Wasm payload that secretly executes on the victim's browser \cite{9566204}.
There payloads are commonly found on websites offering illegal downloads, fake websites, online casinos or adult content, using cryptojacking as a means to generate passive income.
Because it is hard to detect and remove, cryptojacking can execute on a victim's computer, continuously using resources and generating income for the attacker.
This profitable malware does not require exploiting vulnerabilities or stealing credentials.



Several techniques employ static analysis, dynamic analysis and even state-of-the-art machine learning methods to detect \Wasm crytomalware \cite{Minesweeper,MinerRay,MINOS,SEISMIC,RAPID,Outguard}.
However, obfuscation studies have revealed weaknesses in these methods, indicating a largely unexplored threat to malware detection accuracy in \Wasm.
Remarkably, these studies do not consider the existence of obfuscation tools.








\msection{Problems statements}

According to the discussion above, we identify three key problems to be addressed.

\begin{enumerate}[label=\textbf{Ps\arabic*}, ref=C\arabic*]

	\item \label{prob4} \textbf{WebAssembly security}: \Wasm ecosystem and binaries are vulnerable to attacks, specially side-channel attacks. Existing WebAssembly research mostly reacts to existing vulnerabilities, leaving the potential for unidentified attacks.
	Besides, current defenses are limited to specific attacks or require the alteration of runtimes. 
	
	\item \label{prob2} \textbf{Software monoculture}: 
	Identical \Wasm binaries are deployed on multiple nodes and browsers. 
	Deployment systems, including web browsers, might be also identical. 
	Such a situation presents a potential threat to the entire ecosystem due to shared vulnerabilities.
	 
	\item \label{prob5} \textbf{WebAssembly malware}: \Wasm malware is a serious threat. Current implementated defenses are not sufficient to protect against \Wasm malware, mostly because current defenses ignore malware obfuscation.

\end{enumerate}


\begin{comment}
\msection{Problem statement}

\end{comment}

\msection{Contributions in Software Diversification}

This dissertation introduces tools, strategies, and methodologies designed to address the previously enunciated problem statements via Software Diversification.
Software Diversification is a security-focused process that involves identifying, developing, and deploying program variants of a given original program \cite{okhravi2013survey}.
Pioneers in this field, Cohen \etal \cite{cohen1993operating} and Forrest \etal \cite{595185}, proposed enhancing software diversity through code transformations. 
Their proposal suggested creating program variants while maintaining their functionalities to mitigate potential vulnerabilities.
Subsequently, transformations aimed at reducing the predictability of programs' observable behavior have been suggested. For instance, some researchers proposed diversifying the control flow of programs \cite{davi2015isomeron}, their instruction set \cite{barrantes2003randomized}, or the system calls they utilize \cite{Chew02mitigatingbuffer}. 
A combination of these transformations can yield less predictable and therefore more secure variants.

While previous studies on software diversification have illustrated the removal of vulnerabilities, it can consistently serve as a preemptive solution in every instance. 
Despite the extensive research on software diversification, its application to \Wasm remains largely unexplored. 
Firstly, software diversification could enhance the capabilities of established \Wasm analysis tools by including diversified program variants, thus complicating the task for attackers to exploit any overlooked vulnerabilities. 
Generated as a proactive security measure, these diversified variants could mimic a wider range of real-world conditions, consequently increasing the accuracy of \Wasm analysis tools, including \Wasm malware detectors. 
Secondly, we observed that current solutions to reduce side-channel attacks on \Wasm binaries are either limited to specific attacks or require the alteration of runtimes. 
Software diversification could address yet-to-be-discovered vulnerabilities on \Wasm binaries by creating diversified variants in a manner that is independent of the platform. 
In the realm of software diversification, we present the following contributions.


\begin{enumerate}[label=\textbf{C\arabic*}, ref=C\arabic*]
	\item \label{methodcontrib} \wrule{Experimental contribution:} For each proposed technique we provide an artifact implementation and conduct experiments to assess its capabilities. The artifacts are publicly available. The protocols and results of assessing the artifacts provide guidance for future research.
	
	\item \label{therycontrib} \wrule{Theoretical contribution:} We propose a theoretical foundation in order to generate and improve Software Diversification for \Wasm. We provide a formal definition of \Wasm program variants and their diversity. We also provide a formal definition of \Wasm program diversity generation.
	
	\item \label{generationcontrib} \wrule{Diversity generation:} We generate \Wasm program variants. The variants are semantically equivalent to the original program, yet behaviorally diverse.
	
	\item \label{defensivecontrib} \wrule{Defensive Diversification:} We assess how generated \Wasm program variants could be used for defensive purposes. We provide empirical insights about practical usage of the generated variants in preventing side-channel attacks.
	
	\item \label{ofensivecontrib} \wrule{Offensive Diversification:} 
	We evaluate the potential for using generated \Wasm program variants for offensive purposes, while also enhancing security systems. 
	Our research includes experiments where we test the resilience of \Wasm analysis tools against these generated variants. 
	Furthermore, we offer insights into which types of program variants practitioners should prioritize to improve \Wasm analysis tools.

	
\end{enumerate}

\begin{table}
	\centering
	\begin{tabular}{l | l l l l }
		\multicolumn{1}{c|}{Contribution} & \multicolumn{4}{c}{Research papers} 
		\\
		&  \ref{crowpaper} & \ref{mewepaper} & \ref{wasmmutatepaper} & \ref{evasionpaper} \\
		\hline
		\ref{methodcontrib} Experimental contribution & \checkmark & \checkmark & \checkmark & \checkmark \\
		\ref{therycontrib} Theoretical contribution  & \checkmark &  &  \checkmark &  \\
		\ref{generationcontrib} Diversity generation   & \checkmark & \checkmark & \checkmark & \checkmark\\
		\ref{defensivecontrib} Defensive diversification   & \checkmark & \checkmark & \checkmark\\
		\ref{ofensivecontrib} Offensive diversification  & & & & \checkmark\\
	\end{tabular}
	\caption{Mapping between contributions and research papers \label{contrib_map}.}
	
\end{table}

\section{Summary of research papers}

This compilation thesis comprises the following research papers.
In \autoref{contrib_map} we map the contributions to our research papers.

\begin{enumerate}[label={\textbf{P\arabic*}:}, ref={P\arabic*}]
	\item \label{crowpaper} \textbf{CROW: Code randomization for WebAssembly bytecode.} \\ 
	\textbf{Javier Cabrera-Arteaga}, Orestis Floros, Oscar Vera-PÃ©rez, Benoit Baudry, Martin Monperrus\\
	\textit{ Measurements, Attacks, and Defenses for the Web (MADWeb 2021), 12 pages} \\
	\url{https://doi.org/10.14722/madweb.2021.23004} \\
	
	\wrule{Summary:} In this paper, we introduce the first entirely automated workflow for diversifying WebAssembly binaries. 
	We present CROW, an open-source tool that implements software diversification through enumerative synthesis. 
	We assess the capabilities of CROW and examine its application on real-world, security-sensitive programs.
	In general, CROW can create statically diverse variants. 
	Furthermore, we illustrate that the generated variants exhibit different behaviors at runtime.

	
	
	\item \label{mewepaper} \textbf{Multivariant execution at the Edge. } \\
	\textbf{Javier Cabrera-Arteaga}, Pierre Laperdrix, Martin Monperrus, Benoit Baudry\\
    \textit{Moving Target Defense (MTD 2022), 12 pages} \\
    \url{https://dl.acm.org/doi/abs/10.1145/3560828.3564007} \\

	\wrule{Summary:} 
	In this paper, we synthesize functionally equivalent variants of a deployed edge service. 
	These variants are encapsulated into a single multivariant WebAssembly binary, 
	When executing the service endpoint, a random variant is selected each time a function is invoked.
	Execution of these multivariant binaries occurs on the global edge platform provided by Fastly, as part of a research collaboration. 
	We demonstrate that these multivariant binaries present a diverse range of execution traces throughout the entire edge platform, distributed worldwide, effectively creating a moving target defense.

	
	\item \label{wasmmutatepaper}\textbf{Wasm-mutate: Fast and efficient software diversification for WebAssembly. }\\ 
	\textbf{Javier Cabrera-Arteaga}, Nicholas Fitzgerald, Martin Monperrus, Benoit Baudry\\
	\textit{Under review, 17 pages} \\
	\url{https://arxiv.org/pdf/2309.07638.pdf}

	\wrule{Summary:}
	This paper introduces WASM-MUTATE, a compiler-agnostic WebAssembly diversification engine. 
	The engine is designed to swiftly generate semantically equivalent yet behaviorally diverse WebAssembly variants by leveraging an e-graph. 
	We show that WASM-MUTATE can generate tens of thousands of unique WebAssembly variants in mere minutes. 
	Importantly, WASM-MUTATE can safeguard WebAssembly binaries from timing side-channel attacks, such as Spectre.



	\item \label{evasionpaper} \textbf{WebAssembly Diversification for Malware evasion.} \\ 
	\textbf{Javier Cabrera-Arteaga}, Tim Toady, Martin Monperrus, Benoit Baudry\\
	\textit{Computers \& Security, Volume 131, 2023, 17 pages} \\

	\wrule{Summary:}  \Wasm, while enhancing rich applications in browsers, also proves efficient in developing cryptojacking malware. 
	Protective measures against cryptomalware have not factored in the potential use of evasion techniques by attackers. 
	This paper delves into the potential of automatic binary diversification in aiming WebAssembly cryptojacking detectors' evasion. 
	We provide proof that our diversification tools can generate variants of WebAssembly cryptojacking that successfully evade VirusTotal and MINOS. 
	We further demonstrate that these generated variants introduce minimal performance overhead, thus verifying binary diversification as an effective evasion technique.

\end{enumerate}


%\todo{End up with the diagram locating our contributions in the landscape.}

\section*{Thesis layout}
This dissertation comprises two parts as a compilation thesis. 
Part one summarises the research papers included within, which is partially rooted in the author's licentiate thesis \cite{Lic}. 
Chapter 2 offers a background on \Wasm and the latest advancements in Software Diversification. 
Chapter 3 delves into our technical contributions. 
Chapter 4 exhibits two use cases applying our technical contributions. 
Chapter 5 concludes the thesis and outlines future research directions. 
The second part of this thesis incorporates all the papers discussed in part one.

