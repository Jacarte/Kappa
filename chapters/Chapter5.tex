
\chapter{Conclusions and Future Work}
\label{results}

\chapterprecishere{\input{quotes/ullman.tex}\par\raggedleft--- {\small\textup{Jeffrey D. Ullman}}}


\lettrine[lines=4]{I}{n} this thesis, we have presented a comprehensive suite of methods and tools for Software Diversification in \Wasm.
This chapter summarizes the technical contributions of this dissertation and the empirical findings of our research.
Besides, we outline directions for future research.

\section{Summary of technical contributions}

We present three tools for Software Diversification in \Wasm: CROW, MEWE and WASM-MUTATE.
CROW is a compiler-based approach.
It leverages enumerative synthesis to generate functionally equivalent code replacements and assembles them into diverse \wasm program variants. 
CROW uses SMT solvers to guarantee functional equivalence.
MEWE provides dynamic execution path randomization by packaging variants generated out of CROW.
Finally WASM-MUTATE, uses hand-made rewriting rules and random traversals over e-graphs to provide a binary-based solution for \Wasm diversification.


CROW is a compiler-based strategy, needing access to the source code or its LLVM IR representation to work. 
Its core is an enumerative synthesis implementation with functionallity verification using SMT solvers, ensuring the functional equivalence of the generated variants.
In addition, MEWE extends the capabilities of CROW, utilizing the same underlying technology to create program variants. 
It goes a step further by packaging the LLVM IR variants into a Wasm multivariant, providing MVE through execution path randomization.
Both CROW and MEWE are fully automated, requiring no user intervention besides the input source code.
WASM-MUTATE, on the other hand, is a binary-based tool.
It uses a set of rewriting rules and the input \wasm binary to generate program variants, centralizing its core around random e-graph traversals. 
Remarkably, WASM-MUTATE removes the need for compiler adjustments, offering compatibility with any existing \Wasm binary. 



\todo{Wrapping up of the technical contributions and main challenges per tool. We provide all our tools}


\section{Summary of empirical findings}

We have conducted a series of experiments to evaluate the effectiveness of our tools.
In concrete we use WASM-MUTATE to demonstrate two scenarios of Software Diversification for \Wasm: Offensive Software Diversification and Defensive Software Diversification.

Our work provides evidence that the malware detection community has opportunities to strengthen the automatic detection of cryptojacking WebAssembly malware. 
The results of our work are actionable, as we also provide quantitative evidence on specific malware transformations on which detection methods can focus. 
The case discussed in this section is fully detailed in Cabrera-Arteaga \etal "WebAssembly Diversification for Malware Evasion"

WASM-MUTATE crafts \Wasm binaries that are resilient to Spectre-like attacks. 
By integrating a software diversification layer into \Wasm binaries deployed on Function-as-a-Service (FaaS) platforms, security can be significantly bolstered. 
This approach allows for the deployment of unique and diversified \Wasm binaries, potentially utilizing a distinct variant for each cloud node, thereby enhancing the overall security.
The case discussed in this section is fully detailed in Cabrera-Arteaga \etal "WASM-MUTATE: Fast and Effective Binary Diversification for WebAssembly"

\todo{Overall results for Offensive}
\todo{Overall results for Defensive}


\todo{General thoughts on the results}

Although our experiments are conducted prior to submitting the \Wasm binary to the FaaS platform, we argue that \Wasm binary diversification could be implemented at any stage of the FaaS workflow.
The same argument holds by using any other diversification tool presented in this dissertation (see \autoref{tech}).


\section{Future Work}

Along with this dissertation we have highlighted several open challenges related to Software Diversification in \Wasm.
These challenges open up several directions for future research.
In the following, we outline some of these directions.

\wrule{Extending WASM-MUTATE:} 
WASM-MUTATE may gain advantages from the enumerative synthesis techniques employed by CROW and MEWE. 
Specifically, WASM-MUTATE could adopt the transformations generated by these tools as rewriting rules. 
This approach could enhance WASM-MUTATE in two specific ways. 
Firstly, it could improve the preservation of the variants generated by WASM-MUTATE. 
The primary reason for this is that enumerative synthesis outperforms compiler optimizations, making it more challenging for reverse engineers to identify the original program.
Secondly, this method would inevitably expand the diversification space of WASM-MUTATE e-graphs.


\wrule{Program Normalization:} We successfully employed WASM-MUTATE for the evasion of malware detection (see \autoref{offensive_app}). 
The proposed mitigation in the prior study involved code normalization as a means of reducing the spectrum of malware variants. 
Our current work provides insights into the potential effectiveness of this approach. 
Specifically, a practically costless process of pre-compiling Wasm binaries could be employed as a preparatory measure for malware classifiers. 
In other words, a \wasm binary can first be JITed to machine code, effectively eliminating approx. 24\% of malware variants according to our preservation statistics highlighted in \autoref{comp:table:tools}. 
This approach could substantially enhance the efficiency and precision of malware detection systems.


\begin{strategy}[Meta-oracles]
    We have observed that employing meta-oracles seems to be a promising approach for improving the detection of \Wasm malware. 
\end{strategy}
    

\textbf{Fuzzing \Wasm compilers}
Generating well-formed inputs in fuzzing campaigns presents a significant challenge \cite{7958599}. 
This challenge is particularly prevalent in fuzzing compilers, where the inputs need to be executable yet complex enough programs to test various compiler components. 
To address this issue, our tools can generate semantically equivalent variants from an original \wasm binary, thereby improving the scope and efficiency of the fuzzing process. 
A practical instance of the effectiveness of this approach occurred in 2021, when it led to the discovery of a security CVE in wasmtime \cite{CVE}.



\textbf{Mitigating Port Contention}
Rokicki et al. \cite{10.1145/3488932.3517411} demonstrated the feasibility of a covert side-channel attack using port contention within \Wasm code in the browser. 
This attack essentially depends on the precise prediction of Wasm instructions that trigger port contention.
To address this security issue, one could conveniently implement Software Diversification as a browser plugin. 
Software Diversification has the capability to substitute the \wasm instructions used as port contention predictors with other instructions. 
This is very similar to the effect on timers and padding previously discussed in \autoref{exploit:discussion}.
Such an approach would inevitably eliminate the port contention in the specific port used for the attack, thereby strengthening browsers against such harmful actions.



\wrule{Dataset augmentation:} The \Wasm ecosystem is still in its infancy compared to more mature programming environments. 
The study by Hilbig et al. in 2021 found only 8,000 unique \Wasm binaries globally\cite{Hilbig2021AnES}, a fraction of the 1.5 million and 1.7 million packages available in npm and PyPI, respectively. 
This limited dataset poses challenges for machine learning-based analysis tools, which require extensive data for effective training. 
The scarcity of \Wasm programs also exacerbates the problem of software monoculture, increasing the risk of compromised \Wasm programs being consumed\cite{usenixWasm2020}. 

\wrule{AI and Software Diversification}
As we discussed in \autoref{tech}, having a diversifier at the high language level seems impractical due to the wide range of existing frontends.
Wit the appearing of Large Language Models and their accuracy in generating high-level language such issue could be solved.
Yet, we believe it is not only a matter of connecting the LLM to the diversifier, studies on preservation should be acompilshed.
In concrete, high-level diversification migth lead to low preservation, making false the assumption of diversification at low-level.
