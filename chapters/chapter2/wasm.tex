\msection{\Wasm}
\label{sota:wasm}
%% For the intro
 % In 2014, Alon Zakai and colleagues proposed Emscripten \cite{emscripten}. 
% Emscripten used a strict subset of JavaScript, asm.js, to allow low-level code such as C to be compiled to JavaScript. 
% Asm.js was faster than JavaScript because it limited the language features to those that can be optimized in the LLVM pipeline. 
% Notably, Asm.js demonstrated that client-code could be improved with the right language design and standardization.
% Wasm marked the breaking point of several failed attempts of porting code but JavaScript to the web browser \cite{javaapplet,activex,silverlight}.
% Previous alternatives largely failed to gain traction, primarily due to security concerns and a lack of consensus among browser vendors.
% The announcement of \wasm\ marked the first step into the standardization of bytecode in the web environment. 

% History
The W3C publicly announced the \Wasm(Wasm) language in 2017 as the fourth scripting language supported in all major web browser vendors.
\wasm\ is a binary instruction format for a stack-based virtual machine and was officially consolidated by the work of Haas \etal \cite{Haas_2017} in 2017 and extended by Rossberg \etal in 2018 \cite{10.1145/3282510}. 
It is designed to be fast, portable, self-contained and secure, and it outperforms JavaScript execution. 
Since 2017, the adoption of \wasm\ keeps growing. 
For example; Adobe, announced a full online version of Photoshop\footnote{\url{https://twitter.com/Adobe/status/1453034805004685313?s=20&t=Zf1N7-WmzecA0K4V8R69lw}} written in WebAssembly;  game companies moved their development from JavaScript to Wasm like is the case of a full Minecraft version\footnote{\url{https://satoshinm.github.io/NetCraft/}}. 

Moreover, WebAssembly has been evolving outside web browsers since its first announcement.
Some works demonstrated that using WebAssembly as an intermediate layer is better in terms of startup and memory usage than containerization and virtualization \cite{pMendkiServerless, 1244493Jacobsson}. 
Consequently, in 2019, the Bytecodealliance proposed WebAssembly System Interface (WASI) \cite{WASI}. 
WASI pioneered the execution of \wasm\ with a POSIX system interface protocol, making it possible to execute Wasm closer to the underlying operating system. 
Therefore, it standardizes the adoption of \wasm\ in heterogeneous platforms \cite{bryant2020webassembly}, making it suitable for standalone and backend execution scenarios \cite{9640153, wen2020wasmachine}.


\todo{TBD: Some words about the evergreen method and how to extend Wasm?}
%\vspace{-1.5cm}
% How to generate
%\msubsection{\Wasm's generation and binary format}
%\todo{Replace by Rust example}
%\todo{Annotate the Wasm code with the sections offset and length}
%\todo{Instantiate each one of the previously mentioned concepts}
%\todo{Improve some metadata, size of the code, etc}
%\todo{FIX: linerefs}

\msubsection{From source code to \Wasm}

\Wasm programs are compiled from source languages like C/C++, Rust, or Go, which means that it can benefit from the optimizations of the source language compiler.
The resulting \wasm program is like a traditional shared library, containing instruction codes, symbols, and exported functions. 
A host environment is in charge of complementing the Wasm program, such as providing external functions required for execution within the host engine. 
For instance, functions for interacting with an HTML page's DOM are imported into the Wasm binary when invoked from JavaScript code in the browser. 


In \autoref{CExample1} and \autoref{WASMExample}, we present a C program alongside its corresponding WebAssembly binary. 
The C function encompasses various elements such as heap allocation, external function usage, and a function definition that includes a loop, conditional branching, function calls, and memory accesses.
The Wasm code shown in \autoref{WASMExample} is displayed in its textual format, known as WAT\footnote{The WAT text format is primarily designed for human readability and for low-level manual editing.}.
The static memory declared in line 2 of \autoref{CExample1} is allocated within the Wasm binary's linear memory, as illustrated in line 47 of \autoref{WASMExample}.
The function declared in line 5 of \autoref{CExample1} is converted into an imported function, as seen in line 8 of \autoref{WASMExample}.
The main function, spanning lines 7 to 14 in \autoref{CExample1}, is transcribed into a Wasm function covering lines 12 to 38 in \autoref{WASMExample}. Within this function, the translation of various C language constructs into Wasm can be observed.
For instance, the \texttt{for} loop found in line 8 of \autoref{CExample1} is mapped to a block structure in lines 17 to 31 of \autoref{WASMExample}. 
The loop's breaking condition is converted into a conditional branch, as shown in line 25 of \autoref{WASMExample}.


\begin{minipage}[hbtp]{0.9\textwidth}
    \begin{minipage}[t]{1.0\linewidth}
        \lstset{language=C,caption={Example C program which includes heap allocation, external function usage, and a function definition featuring a loop, conditional branching, function calls, and memory accesses.  },
        label=CExample1,
        breaklines=true, 
        basicstyle=\small\ttfamily,
        captionpos=b,
        frame=b,
        numbers=left,
        postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
        escapeinside={(*@}{@*)}
        }
    \input{sota/code/code.c}
    \end{minipage}
\end{minipage}



\input{chapters/chapter2/wasm_example}


There exist several compilers that turn source code into \Wasm binaries. 
For example, LLVM has offered \Wasm as a backend option since its 7.1.0 release\toolcite{https://github.com/llvm/llvm-project/releases/tag/llvmorg-7.1.0}, supporting a diverse set of frontend languages like C/C++, Rust, Go, and AssemblyScript\footnote{A subset of the TypeScript language}.
Significantly, a study by Hilbig et al. reveals that 70\% of \Wasm binaries are generated using LLVM-based compilers. 
The main advantage of using LLVM is that it provides a common optimization infrastructure for \Wasm binaries.
In parallel developments, the KMM framework\toolcite{https://kotlinlang.org/docs/wasm-overview.html} has incorporated \Wasm as a compilation target.


A recent trend in the \Wasm ecosystem involves porting various programming languages by converting both the language's engine or interpreter and the source code into a \Wasm program. 
For example, Javy\toolcite{https://github.com/bytecodealliance/javy} encapsulates JavaScript code within the QuickJS interpreter, demonstrating that direct source code conversion to \Wasm isn't always required. 
If an interpreter for a specific language can be compiled to \Wasm, it allows for the bundling of both the interpreter and the language into a single, isolated \Wasm binary. 
Similarly, Blazor\toolcite{https://dotnet.microsoft.com/en-us/apps/aspnet/web-apps/blazor} facilitates the execution of .NET Common Intermediate Language (CIL) in \Wasm binaries for browser-based applications. 
However, this approach is still non-mature and faces challenges, such as the absence of JIT compilation for the "interpreted" code, making it less suitable for long-running tasks \cite{10.1145/3593434.3593454}. 
On the other hand, it proves effective for short-running tasks, particularly those executed in Edge-Cloud computing platforms.

\msubsection{\Wasm's binary format}
\label{background:wasm:binary}

The Wasm binary format is close to machine code and already optimized, being a consecutive collection of sections.
In \autoref{background:wasm:fig:section} we show the binary format of a Wasm section.
A Wasm section starts with a 1-byte section ID, followed by a 4-byte section size, and concludes with the section content, which precisely matches the size indicated earlier.
A \wasm binary contains sections of 13 types, each with a specific semantic role and placement within the module. 
For instance, the \emph{Custom Section} stores metadata like the compiler used to generate the binary, while the \emph{Type Section} contains function signatures that serve to validate the \emph{Function Section}. 
The \emph{Import Section} lists elements imported from the host, and the \emph{Function Section} details the functions defined within the binary. 
Other sections like \emph{Table, Memory, and Global Sections} specify the structure for indirect calls, unmanaged linear memories, and global variables, respectively. 
\emph{Export, Start, Element, Code, Data, and Data Count Sections} handle aspects ranging from declaring elements for host engine access to initializing program state, declaring bytecode instructions per function, and initializing linear memory. 
Each of these sections must occur only once in a binary and can be empty, i.e., they can be empty.
For the sake of understanding, we also annotate sections as comments in the Wasm code in \autoref{WASMExample}.
    

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\linewidth]{figures/section.pdf}
    \caption{Memory byte representation of a \Wasm binary section, starting with a 1-byte section ID, followed by an 8-byte section size, and finally the section content.}
    \label{background:wasm:fig:section}
\end{figure}

A \wasm binary can be processed efficiently due to its organization into a contiguous array of sections. 
For instance, this structure permits compilers to expedite the compilation process either through parallel parsing or by disregarding \emph{Custom Sections}. 
Moreover, the \emph{Code Section}'s instructions are further compacted through the use of the LEB128\toolcite{https://en.wikipedia.org/wiki/LEB128} encoding. 
Consequently, Wasm binaries are not only fast to validate and compile, but also swift to transmit over a network.

\msubsection{\Wasm's runtime}
\label{background:wasm:execution}

The \Wasm's runtime characterizes the behavior of \wasm programs during execution. 
This section describes the main components of the \Wasm runtime, namely the execution stack, functions, memory model, and execution process. 
These components are crucial for understanding both the \Wasm's control flow and the analysis of \Wasm binaries.


\wrule{Execution Stack:} At runtime, \Wasm engines instantiate a \Wasm module. 
This module is a runtime representation of a loaded and initialized \Wasm binary described in \autoref{background:wasm:binary}. 
The primary component of a module instance is its Execution Stack. 
The Execution Stack stores typed values, labels, and control frames. 
Labels manage block instructions, loops, and function calls. 
Values within the stack can only be static types.\footnote{
Our explanation pertains to \Wasm version 1.0. Several extensions or proposals have introduced additional types. For instance, the SIMD proposal introduced the v128 type. } 
These types include \texttt{i32} for 32-bit signed integers, \texttt{i64} for 64-bit signed integers, \texttt{f32} for 32-bit floats, and \texttt{f64} for 64-bit floats. 
Abstract types such as classes, objects, and arrays are not supported natively. 
Instead, these types are abstracted into primitive types during compilation and stored in linear memory.


\wrule{Functions: }At runtime, \Wasm functions are closures over the module instance, grouping locals and function bodies.
Locals are typed variables that are local to a specific function invocation.
A function body is a sequence of instructions that are executed when the function is called.
Each instruction either reads from the execution stack, writes to the execution stack, or modifies the control flow of the function.
Recalling the example \wasm binary previously showed, 
% Functions
the local variable declarations and typed instructions that are evaluated using the stack can be appreciated between Line 7 and Line 32 in \autoref{WASMExample}. 
Each instruction reads its operands from the stack and pushes back the result. 
In the case of \autoref{WASMExample}, the result value of the main function is the calculation of the last instruction, \texttt{i32.add}. 
As the listing also shows, instructions are annotated with a numeric type.


\wrule{Memory model:} A WebAssembly module instance incorporates three key types of memory-related components. 
These components can either be managed solely by the host engine or shared with the \Wasm binary itself. 
This division of responsibility is often categorized as \emph{managed} and \emph{unmanaged} memory \cite{usenixWasm2020}. 
Managed refers to components that are exclusively modified by the host engine at the lowest level, e.g. when the \Wasm binary is JITed, while unmanaged components can also be altered through  \Wasm opcodes.
First, modules may include multiple linear memory instances, which are contiguous arrays of bytes. 
These are accessed using 32-bit integers (\texttt{i32}) and are shareable only between the initiating engine and the \Wasm binary. 
Generally, these linear memories are considered to be unmanaged, e.g. line 21 of \autoref{WASMExample} shows an explicit memory opcode. 
Second, there are global instances, which are variables accompanied by values and mutability flags (see example in line 42 of \autoref{WASMExample}). 
These globals are managed by the host engine, which controls their allocation and memory placement completely oblivious to the \Wasm binary scope. 
They can only be accessed via their declaration index, prohibiting dynamic addressing. 
Third, local variables are mutable and specific to a given function instance. 
They are accessible only through their index relative to the executing function and are part of the data managed by the host engine.


\wrule{Execution:} \Wasm is optimized and closely aligned with machine code for performance reasons, which typically results in fast JIT compilation for execution.
Engines such as V8\toolcite{https://chromium.googlesource.com/v8/v8.git} and SpiderMonkey\toolcite{https://spidermonkey.dev/} employ this strategy when executing \Wasm binaries in browser clients. 
After JITed, the \Wasm binary operates within a sandboxed environment, accessing the host environment only via imported JavaScript functions from the host.
While \Wasm was initially developed for browsers, it has significantly evolved, primarily due to WASI\cite{WASI}. 
WASI provides a standardized POSIX-like interface for interactions between \Wasm modules and host environments. 
Compilers can generate \wasm binaries that employ WASI, enabling execution in standalone engines. 
These binaries can subsequently be executed by standalone engines across various environments, including the cloud, servers, and IoT devices. 
Much like browsers, these engines often convert \Wasm into machine code via JIT compilation, ensuring a sandboxed execution process. 
Standalone engines such as WASM3\toolcite{https://github.com/wasm3/wasm3}, Wasmer\toolcite{https://wasmer.io/}, Wasmtime\toolcite{https://github.com/bytecodealliance/wasmtime}, WAVM\toolcite{https://github.com/WAVM/WAVM}, and Sledge\cite{Sledge} have been developed to support both \Wasm and WASI. 
In a similar vein, Singh et al.\cite{WARDuino2019} created a \Wasm virtual machine explicitly designed for Arduino-based devices.



\msubsection{\Wasm's control flow}


A \Wasm function groups instructions which are organized into blocks, with the function's entrypoint point acting as the root block. 
In contrast to conventional assembly code, control flow structures in Wasm leap between block boundaries rather than arbitrary positions within the code, effectively prohibiting \texttt{goto}s to random code positions. 
Each block may specify the needed execution stack state before execution as well as the resultant execution stack state once its instructions have been executed.
Typically, the execution stack state is simply the quantity and numeric type of values on the stack. 
This stack state is used to validate the binary during compilation and to ensure that the stack is in a valid state before the execution of the block's instructions.
Blocks in Wasm are explicit (see instructions \texttt{block} and \texttt{end} in lines 16 and 34 of \autoref{WASMExample}), delineating where they commence and conclude.
By design, a block cannot reference or execute code from external blocks.


During runtime, \Wasm break instructions can only jump to one of its enclosing blocks. 
Breaks, except for those within loop constructions, jump to the block's end and continue to the next immediate instruction. 
For instance, after line 34 of \autoref{WASMExample}, the execution would proceed to line 35. 
Within a loop, the end of a block results in a jump to the block's beginning, thus restarting the loop. 
For example, if line 30 of \autoref{WASMExample} evaluates as false, the next instruction to be executed in the loop would be line 18. 
\autoref{background:wasm:block} provides an example for better understanding, comparing a standard block and a loop block in a Wasm function.

\input{snippets/jumps.tex}

Each break instruction includes the depth of the enclosing block as an operand. 
This depth is used to identify the target block for the break instruction. 
For example, in the left-most part of the previously discussed listing, a break instruction with a depth of 1 would jump past two enclosing blocks.
This design hardens the rewriting of \wasm binaries.
For instance, if a block is removed, the depth of the break instructions within the block must be updated to reflect the new enclosing block depth.
This is a significant challenge for rewriting tools, as it requires the analysis of the control flow graph to determine the enclosing block depth for each break instruction.

\msubsection{WebAssembly's binary analysis}
\label{background:wasm:analysis}
As the WebAssembly ecosystem continues to grow, the need for robust tools to ensure its security and reliability has increased. 
To address this, a variety of tools have been developed that employ different strategies to identify vulnerabilities in \Wasm programs. 
In the following we provide a brief overview of the most relevant tools in this space w.r.t static and dynamic analysis, as well as specialized malware detection.

%% PATCH
\vspace{10mm}
\wrule{Static analysis:} 
Tools like Wassail\cite{wassail}, SecWasm\cite{secwasm}, Wasmati\cite{wasmati}, and Wasp\cite{Wasp} leverage techniques such as information flow control, code property graphs, control flow analysis, and concolic execution to detect vulnerabilities in \wasm binaries. 
Remarkably, VeriWasm\cite{veriwasm} stands out as a static offline verifier specifically designed for native x86-64 binaries compiled from \Wasm. 

% Finally, Wafl\cite{wafl} extends AFL++ to perform coverage-based fuzzing on \Wasm binaries.

\wrule{Dynamic analysis:}
In the dynamic analysis counterpart, tools like TaintAssembly\cite{taintassembly}, Wasabi\cite{wasabi}, and Fuzzm\cite{fuzzm} offer similar functionalities in vulnerability detection. 
Stiévenart and colleagues have introduced a dynamic approach to slice \Wasm programs based on Observational-Based Slicing (ORBS)\cite{slicing, slicing2}. 
Hybrid methods have also gained traction, with tools like CT-Wasm\cite{ctwasm} enabling the verifiably secure implementation of cryptographic algorithms in \Wasm. 

\wrule{Specialized Malware Detection:} Cryptomalware have a wide presence in the web since the first days of \wasm.
The main reason is that mining algorithms using CPUs moved to \wasm for obvious performance reasons \cite{musch2019new}. 
In cryptomalware detection, tools like MineSweeper\cite{Minesweeper}, MinerRay\cite{MinerRay}, and MINOS\cite{MINOS} utilize static analysis through machine learning techniques to detect browser cryptomalwares. 
Conversely, tools like SEISMIC\cite{SEISMIC}, RAPID\cite{RAPID}, and OUTGuard\cite{outguard} seek the same goal with dynamic analysis techniques.
Remarkably, VirusTotal\toolcite{https://www.virustotal.com}, packaging more than 60 commercial antivirus as back-boxes, detects cryptomalware in \wasm binaries.


\msubsection{\Wasm's security}

Additionally, SWAM\toolcite{https://github.com/satabin/swam} stands out as \Wasm interpreter implemented in Scala. 
Finally, WaVe\cite{wave} offers a \Wasm interpreter featuring mechanized verification of the \Wasm-WASI interaction with the underlying operating system.


From a security standpoint, \Wasm programs are designed without a standard library and are prohibited from direct interactions with the operating system. Instead, the host environment offers a predefined set of functions that can be imported into the \Wasm program. 
It falls upon the compilers to specify which functions from the host environment will be imported by the \Wasm application.


While \Wasm is engineered to be deterministic, well-typed, and to adhere to a structured control flow, the ecosystem is still emerging and faces various security vulnerabilities. 
These vulnerabilities pose risks to both the consumers and the \Wasm binaries themselves. 
Side-channel attacks, in particular, are a significant concern. 
For example, Genkin et al. have shown that \Wasm can be exploited to exfiltrate data through cache timing-side channels \cite{Genkin2018DrivebyKC}. 
Similarly, research by Maisuradze and Rossow demonstrates the feasibility of speculative execution attacks on \Wasm binaries \cite{ret2spec}. 
Rokicki \etal further reveal the potential for port contention side-channel attacks on \Wasm binaries in browsers \cite{10.1145/3488932.3517411}.
Additionally, studies by Lehmann et al. and Stiévenart and colleagues indicate that vulnerabilities in C/C++ source code can propagate into \Wasm binaries \cite{usenixWasm2020, DeRoover2022}. 
This dissertation introduces a comprehensive set of tools aimed at preemptively enhancing \Wasm security through Software Diversification.

