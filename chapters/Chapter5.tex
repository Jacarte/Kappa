
\chapter{Conclusions and Future Work}
\label{results}

\chapterprecishere{\input{quotes/dn2.tex}\par\raggedleft--- {\small\textup{Donald Knuth}}}

\lettrine[lines=3]{T}{he} growing adoption of \Wasm requires efficent code analysis and hardening techniques.
This thesis contributes to this effort with a comprehensive set of methods and tools for Software Diversification in \Wasm.
It includes the technical contributions of this dissertation: CROW, MEWE, and WASM-MUTATE.
Additionally, we present specific use cases for exploiting the diversification created for \Wasm programs.
In this chapter, we summarize the technical contributions of this dissertation, including an overview of the empirical findings of our research.
Finally, we discuss future research directions in \Wasm Software Diversification.

\section{Summary of technical contributions}
Our first tool, CROW, is a compiler-based approach.
It uses the LLVM compiler and requires the source code or the LLVM IR representation for its functioning. 
Its core comprises an enumerative synthesis implementation. 
CROW ensures the functional equivalence of the generated variants by employing SMT solvers for functionality verification.  

MEWE, on the other hand, reuses the variants generated with CROW to generate program variants. 
Furthermore, it encapsulates the LLVM IR variants into a \Wasm multivariant binary, facilitating execution path randomization. 
Both CROW and MEWE are fully automated systems, necessitating only the input source code from users. 

WASM-MUTATE, a binary-based approach, uses a set of rewriting rules and the input \wasm binary to generate program variants. 
In WASM-MUTATE, the generation of \Wasm variants primarily involves random e-graph traversals. 
Remarkably, WASM-MUTATE eliminates the need for compiler adjustments, thus ensuring compatibility with all existing \Wasm binaries. 
Unlike CROW and MEWE, which are confined to code and function sections, WASM-MUTATE can generate variants by transforming any segment of the \wasm binary.

CROW, MEWE, and WASM-MUTATE are open-source, public tools, making their deployment entirely practical. 
Notably, WASM-MUTATE is currently in use in real-world scenarios to enhance \Wasm compilers\toolcite{https://github.com/bytecodealliance/wasm-tools}.

\section{Summary of empirical findings}

According to the comparison of our technical contributions discussed in \autoref{tech} and, the results of our use case experiments in \autoref{exploit} we summarize the following empirical findings.


\begin{strategy}[Offensive Software Diversification]
    We illustrate the practical application of Offensive Software Diversification in \Wasm. 
    Specifically, we automatically diversify 33 \Wasm cryptomalware, generating many variants in mere minutes.
    These variants effectively evade detection from state-of-the-art malware detection systems.
    Our research verifies the existence of opportunities for the malware detection community to bolster the automatic detection of cryptojacking WebAssembly malware. 
    
\end{strategy}

\begin{strategy}[Defensive Software Diversification]
    Our techniques bolster overall security by enabling the deployment of unique and diversified \Wasm binaries, potentially employing different variants as needed.
    Our methods can generate thousands of variants with high preservation in mere minutes.
    The rapid generation of these variants is possible due to our leveraging of the swift transformation of \Wasm binaries.
    For instance, WASM-MUTATE can produce variants in seconds with the use of virtually inexpensive random e-graph traversals.
    Given our ability to generate variants within minutes, it becomes practical to deploy a unique variant per computing node on FaaS platforms in a randomization scenario, as outlined in \autoref{deployment}.
    We have tested such a scenario with Fastly \cite{MEWE}, including multivariant executions, thus verifying the viability of moving target defense techniques \cite{jackson2011compiler}.
    Specifically, we use Fastly.
    On average, Fastly can redeploy a Wasm binary on their platform in 13 seconds.
    Although each computing node may contain a different \Wasmb variant out of our tools, a 13-second window is sufficient for an attack.
    Yet, MEWE addresses this issue with multivariant binaries, where each execution involves a different variant.
    In conclusion, our ability to generate variants rapidly facilitates the deployment of a new variant, including multivariant binaries, for a single \Wasm original program, serving as a practical moving target defense technique.
\end{strategy}


\begin{strategy}[Implications of our implementations]
    CROW and MEWE depend on SMT solvers to prove functional equivalence in their enumerative synthesis implementation, which can be a bottleneck in variant generation. 
    Consequently, WASM-MUTATE outperforms CROW and MEWE by producing unique variants. 
    It achieves this in at least an order of magnitude greater, within the same timeframe.   
    The main reason is that WASM-MUTATE uses a preset of rewriting rules accompanied by virtually inexpensive random e-graph traversals.
    %Yet, by employing enumerative synthesis, CROW and MEWE ensure that the generated variants are more effectively \temph{preserved}.
    % Conclusion
    The applications of our technical contributions are not orthogonal but complementary. 
    Specifically, one can employ CROW and MEWE to generate a set of variants, which subsequently serve as rewriting rules for WASM-MUTATE. 
    Furthermore, when practitioners require swift generation of variants, they could utilize WASM-MUTATE, accepting a decrease in preservation of the variants.
\end{strategy}


\section{Future Work}

Along with this dissertation we have highlighted several open challenges related to Software Diversification in \Wasm.
These challenges open up several directions for future research.
In the following, we outline some of these directions.



\begin{strategy}[Program Normalization]
     We successfully employed WASM-MUTATE for the evasion of malware detection (see \autoref{offensive_app}). 
    The proposed mitigation in the prior study involved code normalization as a means of reducing the spectrum of malware variants. 
    Our current work provides insights into the potential effectiveness of this approach. 
    Specifically, a practically costless process of pre-compiling Wasm binaries could be employed as a preparatory measure for malware classifiers. 
    In other words, a \wasm binary can first be JITed to machine code, effectively eliminating malware variants. 
    This approach could substantially enhance the efficiency and precision of malware detection systems.

    \todo{Motivation. Why this is important?}

    \todo{One paragraph on SOTA}

    \todo{One paragraph about how I would do it.}
\end{strategy}

\begin{strategy}[Meta-oracles]
    \label{meta-oracles}
    Our experiment results in \autoref{offensive_app}  indicate that VirusTotal surpasses MINOS in detecting \Wasm cryptojacking. 
    The primary factor contributing to this is VirusTotal's utilization of a broader range of antivirus vendors, which employs various detection strategies. 
    On the other hand, MINOS functions as a binary oracle. 
    This evidence supports the use of multiple malware oracles (meta-oracles) in identifying cryptojacking malware in browsers. 
    In the context of \Wasm, given the existence of numerous and diverse Wasm-specific detection mechanisms, this strategy is both practical and feasible, yet not explored in the literature.

    \todo{Motivation. Why this is important?}

    \todo{One paragraph on SOTA}

    \todo{One paragraph about how I would do it.}

\end{strategy}
    