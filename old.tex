
% make this page vertical
\begin{landscape}
    \begin{table}
        
    
        \centering
        \begin{adjustbox}{width=1\linewidth}
        \begin{tabular}{p{0.2\linewidth} | l l l l l l l l l l l l l}
                  & Core & Code & Types & Def.Functions & Debloats & Memory & Globals & Locals & Custom S. & If swap & Loop unroll & Constant inferring & MVE  \\
            \hline
            CROW & Superdiversifier & x  \\
            \hline
            MEWE & CROW & x\\
            \hline
            wasm-mutate & e-graphs & x & x & x & x & x & x & x & x & x & x \\
            
            
        \end{tabular}
        \end{adjustbox}
        \caption{Comparison between CROW, MEWE and wasm-mutate.}
    \end{table}
    \end{landscape}
    

    \todo{Comparison of the approaches.}
    \todo{Add the cool table.}
    
    % Move the following
    Other solutions would have been to diversify at the source-code level or the \wasm\ binary level. However, these facts would limit the applicability of our work.
    Our approach is more general as diversification also will work for other LLVM backends.
    
    % Why and main change
    \todo{This is contradictory to our binary solution.}
    We use the superdiversifier idea of Jacob and colleagues to implement CROW because of two main reasons.
    First, the code replacements generated by this technique outperform diversification strategies based on handwritten rules . 
    Concretely, we can control the quality of the generated codes. 
    Besides, CROW always generates equivalent programs because it is based on a solver to check for equivalence. 
    Second, there is a battle-tested superoptimizer for LLVM, Souper \cite. 
    This latter makes it feasible the construction of a generic LLVM superdiversifier. 


\begin{table}
    \centering
    \begin{tabular}[pos]{l|l|l|l|l}
         & Runtime & Managed memory & Unmanaged memory &   \\
        \hline
        CROW & No & Yes & Yes & No  \\
        MEWE & No & Yes & Yes & No \\
        WASM-MUTATE & Yes & Yes & Yes & Yes \\
    \end{tabular}
\end{table}


\begin{table}
    \centering
    \begin{tabular}[pos]{l|l|l|l|l}
         & Reversible & < Runtime & > Runtime & Fast gen. \\
        \hline
        CROW & No & Yes & Yes & No  \\
        MEWE & No & Yes & Yes & No \\
        WASM-MUTATE & Yes & Yes & Yes & Yes \\
    \end{tabular}
\end{table}

\begin{table}
    \centering
    \begin{tabular}[pos]{l|l|l|l|l}
         & Core & Automatic & In. & Out \\
        \hline
        CROW & SMT & 1 & LLVM & \wasm \\
        MEWE & CROW & 1 & LLVM & MVE \wasm \\
        WASM-MUTATE & e-graph & 0.5 & \wasm & \wasm \\
    \end{tabular}
\end{table}


%% From Lhemann

{
    \color{red}
    Why is program analysis of WebAssembly binaries worthwhile in
particular? First, WebAssemblyâ€™s position as the low-level bytecode for
the Web makes it highly relevant today and more so in the future. If
proponents of WebAssembly are to be believed, it has the potential to
become a universal bytecode for applications outside the browser as
well. Figure 1.1 shows that WebAssembly is the common interchange
format between multiple source languages compiling to WebAssem-
bly and different host environments executing it. Developing program
analyses for each individual source language, or for each of the differ-
ent runtimes does not scale. When source code is not available, there
is also no choice but to analyze the WebAssembly bytecode directly

Second, as a novel code format, analyzing WebAssembly is rife with
open challenges and opportunities. When statically instrumenting WebAssembly binaries, the rewriting needs to be type-aware, otherwise the
resulting binaries are no longer valid. Other characteristics of WebAs-
sembly also need to be taken into account, e.g., structured control-flow
with relative branch labels. At the same time, WebAssembly is a saner
format for binary analysis and rewriting than native machine code.
Static disassembly of WebAssembly is robust, and built-in validation
helps with the reliability of static rewriting. We will discuss challenges
and opportunities around WebAssembly in more detail in Section 1.4.

Last but not least, we believe research should yield practical insights,
datasets, and (prototype) tools that are useful to developers and other
researchers to build on. Web developers so far are mostly used to high-
level JavaScript programs. With WebAssembly, e.g., compiled from C
and C++ code, they require new tooling and guidelines for dealing
with memory vulnerabilities, or to make sense of a binary without
source code. We discuss the conceptual contributions of our work in
Section 1.5 and how the chapters of the dissertation map to publica-
tions and released artifacts in Section 1.6
}


In concrete, distributing the unmodified binary to 100 machines would, essentially, creates 100 homogeneously vulnerable machines.
However, let us illustrate the case with a different approach: each time the binary is replicated onto a different machine, we distribute a unique variant instead of the original binary. 
If we disseminate a unique variant, with X stacked transformations, to each machine, every system would run a distinct \wasm binary. 
Based on our findings, even when some binaries are still vulnerable, we can confidently say that if 100 variants of a vulnerable program, each furnished with X stacked transformations, are distributed, the impact of any potential attack is considerably mitigated.
While it's true that some variants may retain their original vulnerabilities, not all of them do. 
This significantly enhances overall security. 
Further reinforcing this point, let's consider the case of btb\_leakage. 
In this scenario, a suite of 100 variants, each featuring at least 200 stacked transformations, ensures full protection against potential threats, effectively securing the entire infrastructure.
Moreover, considering the results for the ret2spec attack, this property holds for the whole population of generated variants, despite the number of stacked transformations.
Therefore, \tool as a Software Diversification tool, is a peemptive solution to potential attacks.

This is particularly remarkable in the case of \emph{constant inferring} transformations (see \autoref{CROW:constant_inferring}).
This tool offers a significant advantage over CROW and MEWE as it permits transformations in any section of a \wasm program, not just the code section.
Moreover, it leverages a virtually cost-free e-graph traversal process, avoiding, as a direct consequence, the \emph{overlapping} issue seen in CROW and MEWE, as detailed in \autoref{section:crow:example}. 
In addition, since WASM-MUTATE operates at the binary level, it can modify functions incorporated by the \Wasm producer itself.
For example, this is the case of the \emph{wasm32-wasi} architecture.
While the original program might have a few lines of code, the underlying compiler might inject more functions to support the \emph{wasm32-wasi} architecture.
Thus, augmenting the diversification space available to WASM-MUTATE.
Moreover, WASM-MUTATE outperforms CROW and MEWE capabilities in terms of the number of generated variants.
Yet, the changes made by WASM-MUTATE might not be as preserved as the ones generated by CROW and MEWE.
Thus, the variants generated by WASM-MUTATE might be more susceptible of being reversed, e.g. by further optimization passes.


An advantage of WASM-MUTATE, compared to CROW and MEWE, is its capacity to transform non-code sections without impacting the runtime behavior of the original variant, a strategy that effectively shields against static binary analysis, including malware detection based on signature sets \cite{EVASION}.
For instance, it can modify the type section of a \Wasm program, a section typically used only for function signature validation during compilation and validation processes by the host engine. 
This thwarts compiler identification techniques, such as fingerprinting.
Besides, it can be used for masquerading as a different compilation source.
Thus, reducing the fingerprinting surface available to attackers.


The overhead introduced by the diversification is tunneable in all three tools.
CROW, MEWE, and WASM-MUTATE generate variants that potentially improve the original program's runtime performance, demystifying that Software Diversification inherently compromises performance.
Therefore, users of our tools could decide to use or not worst performant variants in their deployments.


\wrule{Smart Contract Analysis} In the field of smart contracts, static analysis tools like WANA\cite{wana}, and EOSAFE\cite{eosafe} are employed to unearth vulnerabilities in \Wasm smart contracts. 
Dynamic analysis tools in this sphere include EOSFuzzer\cite{EOSFuzzer} and wasai\cite{wasai}.
Similarly, Manticore\toolcite{https://github.com/trailofbits/manticore/tree/master/manticore} supports the symbolic execution of \wasm smart contracts. 


\emph{Discussion}
In this section we mention some challenges we face during the writing of this work.
We enumerate them in order to enforce the debase and the discussion on the topic.

\emph{Oracle classification moves in time:}
One could expect that the more detectors a binary has, the more iterations are needed to evade them.
However, we have observed that this is not the case for some binaries.
The main reason is that the final labelling of binaries for VirusTotal vendors is not immediate \cite{251586}. 
For example, a VirusTotal vendor could label a binary as benign and change it later to malign after several weeks in a conservative way of acting.
This phenomenon creates a time window in which slightly changed binaries (fewer iterations in our case) could evade the detection of numerous vendors.

\emph{Lack of bigger picture:} A WebAssembly cryptomalware can only exist with its JavaScript complement.
For example, a browser cryptonalware needs to send the calculated hashes to a cryptocurrency service.
This network communication is outside the WebAssembly accesses and needs to be delegated to a JavaScript code.
Besides, other functionalities can be intermixing between JavaScript and WebAssembly and in some cases be completely in one side or the other \cite{romano2022wobfuscator}.
This intermixing between JavaScript and WebAssembly could provide statically different WebAssembly. 
% What we saw
We have observed that, the imports and the memory data of the WebAssembly binaries have a high variability in our original dataset.
The imported functions from JavaScript change from binary to binary.
Their data segments can also differ in content and length.
To completely analyze these cases, the whole JavaScript-WebAssembly program is needed, something only provided in 9/33 cases of our dataset.

\emph{More narrowed fitness function:} We use a simple fitness function, but the MCMC evasion algorithm could have a fitness function as general as wanted.
In our case, we do not use binary metadata, instead we focus on the result from the malware oracle, given that the main goal is to evade this oracle.

\emph{Mitigation: } \todo{TBD, data augmentation, better resilience evaluation ?}


Another interesting thing would be to see if there is difference in the detectors. If some detectors are fooled by some transformations or are more robust, etc.

\todo{Motivate the use case with the following sota}

\wrule{Binary rewriting tools and obfuscators} The landscape for tools that can modify, obfuscate, or enhance \Wasm binaries for various has increased. 
For instance, BREWasm\cite{BREWasm} provides a comprehensive static binary rewriting framework specifically designed for \Wasm. 
Wobfuscator\cite{wobfuscator} takes a different approach, serving as an opportunistic obfuscator for Wasm-JS browser applications. 
Madvex\cite{madvex} focuses on modifying \Wasm binaries to evade malware detection, with its approach being limited to alterations in the code section of a \Wasm binary. 
Additionally, WASMixer\cite{wasmixer} obfuscates WebAssembly binaries, by including memory access encryption, control-flow flattening, and the insertion of opaque predicates.


\todo{ The malware evasion paper}

%\lipsum[1]
%Checkmarck symbol
\def\checkmark{\tikz\fill[scale=0.4](0,.35) -- (.25,0) -- (1,.7) -- (.25,.15) -- cycle;} 

% Commands to refer to the milestones
\newtheoremstyle{sota}% name of the style to be used
  {\topsep}% measure of space to leave above the theorem. E.g.: 3pt
  {\topsep}% measure of space to leave below the theorem. E.g.: 3pt
  {\itshape}% name of font to use in the body of the theorem
  {0pt}% measure of space to indent
  {\bfseries}% name of head font
  {}% punctuation between head and body
  { }% space after theorem head; " " = normal interword space
  {(\thmname{#1}\thmnumber{#2})\textnormal{\thmnote{ (#3)}}}

\def\Gnospace~{G{}}
\theoremstyle{sota}
\newtheorem{goal}{G}
\providecommand*{\definitionautorefname}{\Gnospace}
\newcommand{\goalautorefname}{\Gnospace}


\def\Snospace~{S{}}
\theoremstyle{sota}
\newtheorem{strategy}{S}
\providecommand*{\definitionautorefname}{\Snospace}
\newcommand{\strategyautorefname}{\Snospace}

\def\Unospace~{U{}}
\theoremstyle{sota}
\newtheorem{usage}{U}
\providecommand*{\definitionautorefname}{\Unospace}
\newcommand{\usageautorefname}{\Unospace}

We have observed that some transformations can be applied in any order. 
This means that different sequences of transformations can produce the same binary variant. 
This often happens when two mutation targets inside the binary are different, such as two disjoint pieces of code.
Therefore, a potential parallelization for the baseline algorithm is possible as soon as transformation sequences do not interfere with others.



\msection{Preservation of \Wasm's diversification}
\label{exploit:discussion_bad}

In \autoref{exploit:defensive}, we have noted an increasing trend of exfiltration bandwidth in certain variants. 
\autoref{offensive_app} presents a similar case, indicating that without a clear objective in the diversification process, stochastic diversification can be counterproductive. 
We observed that the preservation of variants is the primary cause of such phenomena. 

Preservation refers to the ability of a transformation at the \Wasm level to maintain the machine code of the original \Wasm program.
In concrete, some transformations result in distinct \Wasm binaries, yet identical machine code is produced upon their JIT compilation.
Transformations that are not preserved can compromise the effectiveness of diversification.
For instance, the inclusion of random \texttt{nop} operations directly into \Wasm. 
Our experiments show that this specific transformation does not change the final machine code because JIT compilers typically eliminate \texttt{nop} operations.
This phenomenon is similarly noticed with transformations to the custom sections of \Wasm binaries.

In the context of \Wasm malware detection, this means that identical machine code, even when their \Wasm variants are different, can be detected by malware detectors.
For practitioners, malware detection tools can be enhanced by incorporating a pre-compilation step to normalize \Wasm binaries.
To the best of our knowledge, the current antivirus do not do this process.
Besides, developers could focus on transformations that preserve the machine code, as they are more likely to contribute to the diversification objectives, e.g., evasion.

On the other hand, side-channel attacks occur at the machine code level. 
Preserving \Wasm variants is thus essential for successful defensive diversification. 
If the machine code for the generated variants is preserved, the original \Wasm program's side-channel attack is not effective against the variant.




    
Cohen \cite{} recognized the value of diversity for offensive purposes in his dissertation in 1986. 
He has observed virus evolution ultimately dooms static approaches to antivirus detection due to computability limits.
Concretely, end-user detection for malware tends to rely heavily on static and syntactic analysis in addition to dynamic monitoring because of the higher costs of dynamic and behavioral analysis \cite{offensive_div}.
This can be especially appreciated for \Wasm malware detection, as discussed in \autoref{background:wasm:analysis}.


\begin{strategy}[Extending WASM-MUTATE]
    WASM-MUTATE may gain advantages from the enumerative synthesis techniques employed by CROW and MEWE. 
    Specifically, WASM-MUTATE could adopt the transformations generated by these tools as rewriting rules. 
    This approach could enhance WASM-MUTATE in two specific ways. 
    First, it could improve the preservation of the variants generated by WASM-MUTATE. 
    Second, this method would inevitably expand the diversification space of WASM-MUTATE e-graphs.
    \end{strategy}
    



\begin{strategy}[AI and Software Diversification]
    As discussed in \autoref{tech}, implementing a diversifier at the high language level seems impractical due to the multitude of existing frontends.
    However, the emergence of Large Language Models (LLMs) and their ability to generate high-level language may address this problem. 
    Nevertheless, we argue that simply connecting the LLM to the diversifier does not provide a complete solution; studies on preservation must also be conducted.
    Specifically, high-level diversification might lead to low preservation, thereby challenging the assumption of diversification at the low-level.
    In the context of \Wasm, considering the wide variety of frontends, utilizing LLMs might be a feasible method for generating Software Diversification.
    Although preservation poses a problem at a high-level, it could potentially solve the inherited, more challenging issue of transforming programs at the intermediate representation level or \Wasm bytecode itself.
 
\end{strategy}



A few dominant web browsers and standalone engines have led to a software monoculture.
This creates an ecosystem where a singular vulnerability could have widespread repercussions.
This is particularly true with the integration of WebAssembly binaries, which are served from centralized datacenters. 
While \Wasm is designed with security in mind, it is not without flaws.
Vulnerabilities inherent in its memory system, potential for side-channel attacks, and issues with source code can lead to security breaches. 
Moreover, the current landscape of malware detection in \Wasm is not well-studied.
This is especially true in the face of advanced obfuscation techniques that hinder the effectiveness of existing detection methods.
This leaves a critical gap in the defense against \Wasm-targeted cyber threats.



\item \label{prob2} \textbf{Software monoculture}: 
Identical \Wasm binaries are deployed on multiple nodes and browsers. 
Deployment systems, including web browsers, might be also identical. 
Such a situation presents a potential threat to the entire ecosystem due to shared vulnerabilities.


\begin{strategy}[Mitigating Port Contention]
    Rokicki \etal  \cite{10.1145/3488932.3517411} showcased the potential of a covert side-channel attack using port contention in \Wasm code within browsers to violate cross scripting isolation.
    Side-channels exploiting port contention utilize the competition for shared hardware resources to extract sensitive information from processes. 
    The attacker measures the time taken to access these shared resources to deduce data or behavior of a victim process sharing the same resources. 
    Counteracting these attacks is especially difficult as they leverage fundamental features of the hardware design meant to enhance performance. 
    The success of this attack largely relies on the accurate prediction of Wasm instructions inducing port contention. 
    To tackle this security concern, \Wasm Software Diversification can be effectively implemented as a browser plugin. 
    Our tools possess the ability to change the \Wasm instructions acting as port contention predictors with different instructions. 
    This bears a strong resemblance to the impact on timers and padding discussed earlier in \autoref{exploit:defensive}. 
    Such a strategy would certainly eradicate the port contention in the particular port used for the attack, subsequently hardening browsers against such detrimental activities.

\end{strategy}


\begin{comment}
    
    \wrule{Dataset augmentation:} The \Wasm ecosystem is still in its infancy compared to more mature programming environments. 
    The study by Hilbig \etal  in 2021 found only 8,000 unique \Wasm binaries globally\cite{Hilbig2021AnES}, a fraction of the 1.5 million and 1.7 million packages available in npm and PyPI, respectively. 
    This limited dataset poses challenges for machine learning-based analysis tools, which require extensive data for effective training. 
    The scarcity of \Wasm programs also exacerbates the problem of software monoculture, increasing the risk of compromised \Wasm programs being consumed\cite{usenixWasm2020}. 
\end{comment}

Fastly, on average, can redeploy a \Wasm binary across its extensive platform of 73 datacenters worldwide in just 13 seconds. 
The number of datacenters allows for the practical deployment of a unique variant per node using our tools. 
Despite each computing node potentially hosting a distinct \Wasm variant produced by our tools, a 13-second window might still be vulnerable. 
To address this potential issue, we employ multivariant binaries, invoking a unique variant with each execution. 
In conclusion, generating dozens of unique variants every several seconds, each serving as a multivariant binary packaging thousands of other variants is achievable by using our tools.
Therefore, this exemplifies the application of Defensive Software Diversification to a real-world \Wasm standalone scenario.


\begin{strategy}[Meta-oracles]
    \label{meta-oracles}
    Our experiment results in \autoref{offensive_app}  indicate that VirusTotal surpasses MINOS in detecting \Wasm cryptojacking. 
    The primary factor contributing to this is VirusTotal's utilization of a broader range of antivirus vendors, which employs various detection strategies. 
    On the other hand, MINOS functions as a binary oracle. 
    This evidence supports the use of multiple malware oracles (meta-oracles) in identifying cryptojacking malware in browsers. 
    In the context of \Wasm, given the existence of numerous and diverse Wasm-specific detection mechanisms, this strategy is both practical and feasible, yet not explored in the literature.

    \todo{Motivation. Why this is important?}

    \todo{One paragraph on SOTA}

    \todo{One paragraph about how I would do it.}

\end{strategy}


    %We believe such an issue could be solved by data augmentation techniques.

    %Dataset augmentation has been demonstrated to enhance the precision of classification models \cite{2021arXiv210311882S, selfAPR, 10.1109/TSE.2023.3240118}.
    %Therefore, our tools could be used to produce a wide array of known malware variants.
    %Such variants could serve to augment the dataset employed in the training of malware detection systems.
    %This could potentially rectify the inherent issue of the high preservation of malware variants.
    %Specifically, although the canonical program may not be located within a reasonable time for a highly preserved malware variant, a closely related %variant may have already been incorporated into the augmented dataset.
    %In summary, this method could bolster the robustness of the detection systems, thereby making them more resistant to evasion techniques.


    \todo{We keep it.}
    \todo{Change title. Refine it. Twice as long. Why we want efficiency ? Reasons to be efficient. Objective on top of diversification technique. Notion of Being precise. Different constraints, gas based. Examples: evasion.}
    
    On the contrary, stochastic diversification may generate variants that do not align with the specific objective. 
    For instance, our approaches have shown less impact on ret2spec and pht side-channel attacks compared to btb attacks when using stochastic diversification.
    We can conceptualize this problem as an issue of diversification space exploration. 
    By dividing the diversification search space, we can more efficiently focus the diversification process. 
    The main benefit of this division is a narrowed search space, which can speed up and refine the process of diversification. 
    
    
    We intend to research into the previously mentioned concept. 
    Our strategy could potentially incorporate feedback-directed methods that rely on specific code patterns, such as the disruption of embedded timers, to better combat side-channel attacks. 
    For example, port contention side-channel \cite{10.1145/3488932.3517411} attacks can be preventing by using Software Diversification. 
    One might count the number of instructions that result in port contention and use this data to choose or eliminate variants with a high or low count of instructions leading to port contention.
    Feedback-guided code pattern approaches need a comprehensive study of the mechanisms underlying various attack vectors, and the exact impact of different code transformations on them. 
    The delicate adjustment of these methods to maintain a balance between general and specific security objectives poses a significant challenge. 
    Continuous research and development are required to optimize and validate their effectiveness in a variety of scenarios.
    
    
    \subsection{Oneshot Diversification}
    
    our methods remarkably generate tens of thousands of variants in minutes. 
    
    
    \todo{In the context of Wasm. More constraints}
    \todo{Rotatio time is important in some cases.}
    \url{https://dblp.org/pid/l/MichaelELocasto.html}
    