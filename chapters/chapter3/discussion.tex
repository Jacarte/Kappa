
\msection{Discussion}

In this section we discuss the main differences between CROW, MEWE and wasm-mutate.
Besides, we provide insights on the provided artifacts for each one of the tools and main implementation details.

\msubsection{Comparing CROW, MEWE and wasm-mutate}

We discuss the main differences between CROW, MEWE and wasm-mutate according to three main dimensions: 1) the technology and approach of each one, 2) the strength of the generated variants, 3) the security guarantees of the variants generated by each tool.

\textbf{Technology and approach.}
CROW is a compiler-based strategy, needing access to the original source code or its LLVM IR representation to work. 
Its core is a Satisfiability Modulo Theories (SMT) solver, ensuring the functional equivalence of the generated variants.
This approach lays the groundwork for a universal LLVM superdiversifier, promising a wide range of applications and adaptability.
Building upon CROW, MEWE extends its capabilities, utilizing the same underlying technology to create program variants. 
It goes a step further by packaging the LLVM IR variants into a Wasm multivariant.

Contrastingly, WASM-MUTATE is a semi-automated, binary-based tool, centralizing its core around e-graph traversals. 
This approach facilitates the creation of a pool of \Wasm program variants through the meticulous application of rewriting rules on an e-graph data structure. 
This method removes the need for compiler adjustments, offering compatibility with any existing \Wasm binary and showcasing flexibility and applicability. 
Moreover, it introduces a versatile intermediate representation, establishing a general framework for binary rewriting in \Wasm.


\textbf{Strength of the generated variants.}
CROW and MEWE leverage enumerative synthesis and semantic equivalence verified through SMT solvers. 
This methodology has proven that can surpass handcrafted optimizations. 
Consequently, the transformations generated by CROW and MEWE are vritually irreversible, even after subsequent compiler optimizations. 
This is specially remarkable for \emph{constant inferring} transformations.
Moreover, the utilization of enumerative synthesis means that these variants can potentially outperform the original program in terms of runtime, showing that software diversification do not compromise performance. 
CROW and MEWE operate autonomously, albeit the pace of variant generation is tethered to the efficiency of the SMT solvers they employ.

In contrast, WASM-MUTATE operates semi-automatically, needing user intervention to define the rewriting rules.
The functional equivalence guarantee is then ported to the crafting of such rewriting rules. 
WASM-MUTATE advantages CROW and MEWE, which are confined to influencing only the code of \wasm variants. WASM-MUTATE can modify any part of a \wasm program, including custom sections, a transformation unattainable with the other two technologies. 
Furthermore, in addition to a virtually cost-free e-graph traversal, WASM-MUTATE can generate more variants than its counterparts. 
However, this comes with a caveat: the alterations induced by WASM-MUTATE may not withstand subsequent optimization phases, presenting a delicate balance between rapid generation and the robustness of the generated variants. 


\textbf{Security guarantees.}
CROW and MEWE generates distinct and highly preserved code variants. 
This means that these variants, each with unique \Wasm codes, maintain their distinctiveness even after JIT compilers translate them into machine codes. 
This distinctive feature significantly reduces the impact to side-channel attacks that exploit specific machine code instructions, e.g., port contention \cite{port contention}.
Furthermore, these tools enhance security against timing-based attacks by creating variants that exhibit a wide range of execution times. 
This strategy is especially prominent in MEWEâ€™s approach, which develops multivariants functioning on randomizing execution paths, thereby thwarting attempts at timing-based inference attacks. 
Consequently, attackers might find it exceedingly difficult to identify a specific variant through time profiling of a MEWE multivariant, ensuring a heightened level of security (See section \autoref{usecasetime}).
Adding another layer to this security framework, the integration of diverse variants into multivariants can potentially disrupt the functioning of dynamic analysis tools such as symbolic executors \cite{opaque predicate}. 
For example, different control flows through a random discriminator, which exponentially increases the number of paths, rendering them virtually unexplorable.

WASM-MUTATE, while offering slightly reduced preservation in its generated variants compared to CROW and MEWE, still maintains the same security guarantees excepting the multivariant cases.
Its ability to produce a greater number of variants can offset this preservation shortfall.

An advantege of WASM-MUTATE, compared to CROW and MEWE, is its capacity to transform non-code sections without impacting the runtime behavior of the original variant, a strategy that effectively shields against static binary analysis, including malware detection based on signature sets \cite{CABRERAARTEAGA2023103296}.
For instance, it can modify the type section of a \Wasm program, a section typically utilized only for function signature validation during compilation and validation processes by the host engine. 
This thwarts compiler identification techniques, such as fingerprinting.
Besides, it can be used for masquerading as a different compilation source.
Thus, reducing the fingerprinting surface available to attackers.

Shared across CROW, MEWE, and WASM-MUTATE is the functionality to eliminate dead code and modify the original program's control flow, serving to minimize the attack surface.
This approach not only hinders signature-based identification \cite{CABRERAARTEAGA2023103296} but also prevents Return-Oriented Programming (ROP) attacks by eliminating potential jump points to malicious behaviors within the binary, as highlighted by Narayan et al. \cite{Swivel}. 
Moreover, the alteration of control flow, while preserving the program's original functionality, enhances resistance to attacks, a strategy validated by Crane et al. in the context of Function-Reuse attacks \cite{10.1145/2810103.2813682, 10.1145/3453483.3454035}. 

\todo{Indirectly affecting the memory. Unmanaged and Managed data.}

\msubsection{Accompanying artifacts}

This thesis is accompanied by the source code of the three contributions, CROW, MEWE and WASM-MUTATE. 
The source code is accessible through the links:
\begin{enumerate}
    \item CROW: \url{https://github.com/KTH/slumps}
    \item Customized LLVM backend: \url{https://github.com/Jacarte/llvm-project}
    \item MEWE: \url{https://github.com/Jacarte/MEWE}
    \item WASM-MUTATE: \todo{URL}
\end{enumerate}

Our software artifacts are licensed under the MIT License. The dependent source codes, such as LLVM, are licensed under their original conditions.

\msection{Conclusions}

In this chapter we discuss the technical specifics underlying our primary technical contributions.
We elucidate the mechanisms through which CROW engenders program variants, all in the service of advancing software diversification. 
Following this, we outline the conceptual framework for a universal LLVM superdiversifier, laying a foundation for broader applicability and versatility.
Subsequently, we turn our attention to MEWE, offering a detailed examination of its role in forging a robust MVE system. 
We also explore the inner workings of WASM-MUTATE, highlighting its pioneering utilization of an e-graph traversal algorithm to spawn \wasm program variants. 
Remarkably, we undertake a comparative analysis of the three tools, delineating their respective benefits and limitations, alongside the potential security assurances they provide upon the program variants derived from them. 

In \autoref{chapter:method}, we present four use cases that support the exploitation of these tools.
\autoref{chapter:method} serves to bridge theory with practice, showcasing the tangible impacts and benefits realized through the deployment of CROW, MEWE, and WASM-MUTATE.
