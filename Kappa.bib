@inbook{Runeson2020,
  author    = {Runeson, Per
               and Engstr{\"o}m, Emelie
               and Storey, Margaret-Anne},
  editor    = {Felderer, Michael
               and Travassos, Guilherme Horta},
  title     = {The Design Science Paradigm as a Frame for Empirical Software Engineering},
  booktitle = {Contemporary Empirical Methods in Software Engineering},
  year      = {2020},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {127--147},
  abstract  = {Software engineering research aims to help improve real-world practice. With the adoption of empirical software engineering research methods, the understanding of real-world needs and validation of solution proposals have evolved. However, the philosophical perspective on what constitutes theoretical knowledge and research contributions in software engineering is less discussed in the community. In this chapter, we use the design science paradigm as a frame for articulating and communicating prescriptive software engineering research contributions. Design science embraces problem conceptualization, solution (or artifact) design, and validation of solution proposals, with recommendations for practice phrased as technological rules. Design science is used in related research areas, particularly information systems and management theory. We elaborate the constructs of design science for software engineering, relate them to different conceptualizations of design science, and provide examples of possible research methods. We outline how the assessment of research contributions, industry--academia communication, and theoretical knowledge building may be supported by the design science paradigm. Finally, we provide examples of software engineering research presented through a design science lens.},
  isbn      = {978-3-030-32489-6},
  doi       = {10.1007/978-3-030-32489-6_5},
  url       = {https://doi.org/10.1007/978-3-030-32489-6_5}
}

@article{Hilbig2021AnES,
  title   = {An Empirical Study of Real-World WebAssembly Binaries: Security, Languages, Use Cases},
  author  = {Aaron Hilbig and Daniel Lehmann and Michael Pradel},
  journal = {Proceedings of the Web Conference 2021},
  year    = {2021}
}


@inproceedings{moduloinputpaper,
  author    = {Le, Vu and Afshari, Mehrdad and Su, Zhendong},
  title     = {Compiler Validation via Equivalence modulo Inputs},
  year      = {2014},
  booktitle = {Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  pages     = {216–226},
  numpages  = {11},
  keywords  = {equivalent program variants, automated testing, miscompilation, compiler testing},
  location  = {Edinburgh, United Kingdom},
  series    = {PLDI ’14}
}
@article{Li2018,
  abstract  = {Security vulnerability is one of the root causes of cyber-security threats. To discover vulnerabilities and fix them in advance, researchers have proposed several techniques, among which fuzzing is the most widely used one. In recent years, fuzzing solutions, like AFL, have made great improvements in vulnerability discovery. This paper presents a summary of the recent advances, analyzes how they improve the fuzzing process, and sheds light on future work in fuzzing. Firstly, we discuss the reason why fuzzing is popular, by comparing different commonly used vulnerability discovery techniques. Then we present an overview of fuzzing solutions, and discuss in detail one of the most popular type of fuzzing, i.e., coverage-based fuzzing. Then we present other techniques that could make fuzzing process smarter and more efficient. Finally, we show some applications of fuzzing, and discuss new trends of fuzzing and potential future directions.},
  author    = {Li, Jun and Zhao, Bodong and Zhang, Chao},
  doi       = {10.1186/S42400-018-0002-Y/TABLES/5},
  file      = {:Users/javierca/Library/Application Support/Mendeley Desktop/Downloaded/Li, Zhao, Zhang - 2018 - Fuzzing a survey.pdf:pdf},
  issn      = {25233246},
  journal   = {Cybersecurity},
  keywords  = {Coverage-based fuzzing,Fuzzing,Software security,Vulnerability discovery},
  month     = {dec},
  number    = {1},
  pages     = {1--13},
  publisher = {Springer Science and Business Media B.V.},
  title     = {{Fuzzing: a survey}},
  url       = {https://cybersecurity.springeropen.com/articles/10.1186/s42400-018-0002-y},
  volume    = {1},
  year      = {2018}
}

@article{mann1947,
  author    = {Mann, H. B. and Whitney, D. R.},
  doi       = {10.1214/aoms/1177730491},
  fjournal  = {Annals of Mathematical Statistics},
  journal   = {Ann. Math. Statist.},
  month     = {03},
  number    = {1},
  pages     = {50--60},
  publisher = {The Institute of Mathematical Statistics},
  title     = {On a Test of Whether one of Two Random Variables is Stochastically Larger than the Other},
  volume    = {18},
  year      = {1947}
}


@inproceedings{Maia08usinga,
  author    = {Marcelo De A. Maia and Victor Sobreira and Klérisson R. Paixão and Ra A. De Amo and Ilmério R. Silva},
  title     = {Using a sequence alignment algorithm to identify specific and common code from execution traces},
  booktitle = {Proceedings of the 4th International Workshop on Program Comprehension through Dynamic Analysis (PCODA},
  year      = {2008},
  pages     = {6--10}
}


@inproceedings{davi2015isomeron,
  title     = {Isomeron: Code Randomization Resilient to (Just-In-Time) Return-Oriented Programming},
  author    = {Davi, Lucas and Liebchen, Christopher and Sadeghi, Ahmad-Reza and Snow, Kevin Z and Monrose, Fabian},
  booktitle = {NDSS},
  year      = {2015}
}

@article{gnanadesikan1968probability,
  title   = {Probability plotting methods for the analysis of data},
  author  = {Gnanadesikan, Ramanathan and Wilk, Martin B},
  journal = {Biometrika},
  volume  = {55},
  number  = {1},
  pages   = {1--17},
  year    = {1968}
}

@article{2021arXiv210808125C,
  author        = {{Cabrera Arteaga}, Javier and {Laperdrix}, Pierre and {Monperrus}, Martin and {Baudry}, Benoit},
  title         = {{Multi-Variant Execution at the Edge}},
  journal       = {arXiv e-prints},
  keywords      = {Computer Science - Software Engineering},
  year          = 2021,
  month         = aug,
  eid           = {arXiv:2108.08125},
  pages         = {arXiv:2108.08125},
  archiveprefix = {arXiv},
  eprint        = {2108.08125},
  primaryclass  = {cs.SE},
  adsurl        = {https://ui.adsabs.harvard.edu/abs/2021arXiv210808125C},
  adsnote       = {Provided by the SAO/NASA Astrophysics Data System}
}

@article{Haas_2017,
  title    = {Bringing the web up to speed with WebAssembly},
  year     = {2017},
  author   = {Andreas Haas and Andreas Rossberg and Derek L. Schuff and Derek L. Schuff and Ben L. Titzer and Michael Holman and Dan Gohman and Luke Wagner and Alon Zakai and J. F. Bastien},
  doi      = {10.1145/3062341.3062363},
  pmid     = {null},
  pmcid    = {null},
  mag_id   = {2625141509},
  journal  = {PLDI},
  abstract = {The maturation of the Web platform has given rise to sophisticated and demanding Web applications such as interactive 3D visualization, audio and video software, and games. With that, efficiency and security of code on the Web has become more important than ever. Yet JavaScript as the only built-in language of the Web is not well-equipped to meet these requirements, especially as a compilation target.     Engineers from the four major browser vendors have risen to the challenge and collaboratively designed a portable low-level bytecode called WebAssembly. It offers compact representation, efficient validation and compilation, and safe low to no-overhead execution. Rather than committing to a specific programming model, WebAssembly is an abstraction over modern hardware, making it language-, hardware-, and platform-independent, with use cases beyond just the Web. WebAssembly has been designed with a formal semantics from the start. We describe the motivation, design and formal semantics of WebAssembly and provide some preliminary experience with implementations.}
}

@misc{Cheerps2018,
  title        = {{Cheerp - C++ for the Web}},
  year         = {2018},
  author       = {{Cheerp}},
  howpublished          = {\url{https://www.leaningtech.com/cheerp/}},
  lastaccessed = {2019-11-12}
}


@misc{asmjs,
  title        = {{asm.js Speedups Everywhere}},
  year         = {2015},
  author       = {{Alon Zakai}},
  howpublished          = {\url{https://hacks.mozilla.org/2015/03/asm-speedups-everywhere/}},
  lastaccessed = {2022-13-04}
}

@misc{wasm_spec,
  title        = {{WebAssembly Specification}},
  year         = {2017},
  author       = {{WebAssembly Community Group}},
  howpublished          = {\url{https://webassembly.github.io/spec/core/syntax/index.html}},
  lastaccessed = {2022-13-04}
}


@misc{wasm_roadmap,
  title        = {{WebAssembly Roadmap}},
  year         = {2017},
  author       = {{WebAssembly Community Group}},
  howpublished          = {\url{https://webassembly.org/roadmap/}},
  lastaccessed = {2022-13-04}
}

@misc{javaapplet,
  title        = {{JDK 9 Release Notes. Deprecation of Java Applets}},
  year         = {{2017}},
  author       = {{Oracle}},
  howpublished          = {\url{{https://www.oracle.com/java/technologies/javase/9-deprecated-features.html}}},
  lastaccessed = {2022-16-05}
}

@misc{activex,
  title        = {{Microsoft Announces ActiveX Technologies}},
  howpublished          = {\url{{https://web.archive.org/web/20090828024117/http://www.microsoft.com/presspass/press/1996/mar96/activxpr.mspx}}},
  author       = {{Microsoft}},
  year         = {{1996}},
  lastaccessed = {2022-16-05}
}


@misc{llvmofficialweb,
  title        = {{ The LLVM Compiler Infrastructure }},
  howpublished          = {\url{{https://llvm.org/}}},
  author       = {{LLVM}},
  year         = {{2003}},
  lastaccessed = {2022-16-05}
}

@misc{silverlight,
  title        = {{Silverlight}},
  year         = {{2007}},
  author       = {{Microsoft}},
  howpublished  = {\url{{https://www.microsoft.com/silverlight/}}},
  lastaccessed = {2022-16-05}
}

@misc{emscripten,
  howpublished          ={\url {{https://emscripten.org/}}},
  year         = {{2014}},
  title        = {{Emscripten}},
  author       = {{Zakai and colleagues}},
  lastaccessed = {2022-16-05}
}


@misc{asmjsweb,
  howpublished          = {\url{{http://asmjs.org/spec/latest/}}},
  year         = {{2014}},
  title        = {{asm.js}},
  author       = {{Zakai and colleagues}},
  lastaccessed = {2022-16-05}
}

@misc{nexus,
  howpublished          = {\url{{https://www.w3.org/People/Berners-Lee/WorldWideWeb.html}}},
  year         = {{1990}},
  title        = {{The WorldWideWeb browser}},
  author       = {{Tim Berners-Lee}},
  lastaccessed = {2022-16-05}
}

@misc{bytecodealliance,
  howpublished          = {\url{{https://bytecodealliance.org/}}},
  year         = {{2019}},
  title        = {{Bytecode Alliance}},
  author       = {{Bytecode Alliance }},
  lastaccessed = {2022-16-05}
}


@inproceedings{bryant2020webassembly,
  title     = {Webassembly outside the browser: A new foundation for pervasive computing},
  author    = {Bryant, David},
  booktitle = {Proc. of ICWE 2020},
  pages     = {9--12},
  year      = {2020}
}


@inproceedings{Narayan2021Swivel,
  title     = {Swivel: Hardening WebAssembly against Spectre},
  author    = {Narayan, Shravan and Disselkoen, Craig and Moghimi, Daniel and Cauligi, Sunjay and Johnson, Evan and Gang, Zhao and Vahldiek-Oberwagner, Anjo and Sahita, Ravi and Shacham, Hovav and Tullsen, Dean and others},
  booktitle = {USENIX Security Symposium },
  year      = {2021}
}


% Diversification papers
@article{cohen1993operating,
  title   = {Operating system protection through program evolution.},
  author  = {Cohen, Frederick B},
  journal = {Computers \& Security},
  volume  = {12},
  number  = {6},
  pages   = {565--584},
  year    = {1993}
}

@incollection{jackson2011compiler,
  title     = {Compiler-generated software diversity},
  author    = {Jackson, Todd and Salamat, Babak and Homescu, Andrei and Manivannan, Karthikeyan and Wagner, Gregor and Gal, Andreas and Brunthaler, Stefan and Wimmer, Christian and Franz, Michael},
  booktitle = {Moving Target Defense},
  pages     = {77--98},
  year      = {2011},
  publisher = {Springer}
}

@article{Genkin2018DrivebyKC,
  title   = {Drive-by Key-Extraction Cache Attacks from Portable Code},
  author  = {Daniel Genkin and Lev Pachmanov and Eran Tromer and Yuval Yarom},
  journal = {IACR Cryptol. ePrint Arch.},
  year    = {2018},
  volume  = {2018},
  pages   = {119}
}


@inproceedings{homescu2013profile,
  title        = {Profile-guided automated software diversity},
  author       = {Homescu, Andrei and Neisius, Steven and Larsen, Per and Brunthaler, Stefan and Franz, Michael},
  booktitle    = {Proceedings of the 2013 IEEE/ACM International Symposium on Code Generation and Optimization (CGO)},
  pages        = {1--11},
  year         = {2013},
  organization = {IEEE}
}

@article{coppens2013feedback,
  title     = {Feedback-driven binary code diversification},
  author    = {Coppens, Bart and De Sutter, Bjorn and Maebe, Jonas},
  journal   = {ACM Transactions on Architecture and Code Optimization (TACO)},
  volume    = {9},
  number    = {4},
  pages     = {1--26},
  year      = {2013},
  publisher = {ACM New York, NY, USA}
}

% Superoptimization

@article{bunel_learning_2017,
  author        = {{Bunel}, Rudy and {Desmaison}, Alban and {Pawan Kumar}, M. and
                   {Torr}, Philip H.S. and {Kohli}, Pushmeet},
  title         = {{Learning to superoptimize programs}},
  journal       = {arXiv e-prints},
  keywords      = {Computer Science - Machine Learning},
  year          = 2016,
  month         = nov,
  number        = 1,
  volume        = 1,
  numpages      = {10},
  eid           = {arXiv:1611.01787},
  pages         = {arXiv:1611.01787},
  archiveprefix = {arXiv},
  eprint        = {1611.01787},
  primaryclass  = {cs.LG},
  adsurl        = {https://ui.adsabs.harvard.edu/abs/2016arXiv161101787B},
  adsnote       = {Provided by the SAO/NASA Astrophysics Data System}
}


@article{Massalin1987,
  title     = {{Superoptimizer: a look at the smallest program}},
  year      = {1987},
  journal   = {ACM SIGARCH Computer Architecture News},
  author    = {Massalin Henry},
  number    = {5},
  month     = {Nov},
  pages     = {122--126},
  volume    = {15},
  publisher = {ACM},
  url       = {http://portal.acm.org/citation.cfm?doid=36177.36194},
  isbn      = {0-8186-0805-6},
  doi       = {10.1145/36177.36194},
  issn      = {01635964}
}


@article{churchill_sound_nodate,
  author     = {Churchill, Berkeley and Sharma, Rahul and Bastien, JF and Aiken, Alex},
  title      = {Sound Loop Superoptimization for Google Native Client},
  year       = {2017},
  issue_date = {May 2017},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {52},
  number     = {4},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/3093336.3037754},
  doi        = {10.1145/3093336.3037754},
  journal    = {SIGPLAN Not.},
  pages      = {313–326},
  numpages   = {14},
  keywords   = {verification, bounded verification, superoptimization, assembly, x86-64, equivalence checking, data-driven verification, native client}
}


% Superdiversifier
@inproceedings{jacob2008superdiversifier,
  title        = {The superdiversifier: Peephole individualization for software protection},
  author       = {Jacob, Matthias and Jakubowski, Mariusz H and Naldurg, Prasad and Saw, Chit Wei Nick and Venkatesan, Ramarathnam},
  booktitle    = {International Workshop on Security},
  pages        = {100--120},
  year         = {2008},
  organization = {Springer}
}

@inproceedings{bansal_automatic_nodate,
  author    = {Bansal, Sorav and Aiken, Alex},
  title     = {Automatic Generation of Peephole Superoptimizers},
  year      = {2006},
  isbn      = {1595934510},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1168857.1168906},
  doi       = {10.1145/1168857.1168906},
  booktitle = {Proceedings of the 12th International Conference on Architectural Support for Programming Languages and Operating Systems},
  pages     = {394–403},
  numpages  = {10},
  keywords  = {peephole optimization, code selection, superoptimization},
  location  = {San Jose, California, USA},
  series    = {ASPLOS XII}
}


@inproceedings{Sledge,
  author    = {Gadepalli, Phani Kishore and McBride, Sean and Peach, Gregor and Cherkasova, Ludmila and Parmer, Gabriel},
  title     = {Sledge: A Serverless-First, Light-Weight Wasm Runtime for the Edge},
  year      = {2020},
  doi       = {10.1145/3423211.3425680},
  booktitle = {Proceedings of the 21st International Middleware Conference},
  pages     = {265–279}
}

@inproceedings{wen2020wasmachine,
  title        = {Wasmachine: Bring iot up to speed with a webassembly os},
  author       = {Wen, Elliott and Weber, Gerald},
  booktitle    = {2020 IEEE International Conference on Pervasive Computing and Communications Workshops (PerCom Workshops)},
  pages        = {1--4},
  year         = {2020},
  organization = {IEEE}
}


@misc{WebAssemblySecurity,
  title        = {{WebAssembly documentation: Security}},
  howpublished          = {\url{https://webassembly.org/docs/security/}},
  organization = {{W3C}},
  note         = {{Accessed: 18 June 2020}},
  author       = {Dominic Chen and {\relax W3C group}},
  year         = {2020}
}

@inproceedings{usenixWasm2020,
  title     = {Everything Old is New Again: Binary Security of WebAssembly},
  booktitle = {29th USENIX Security Symposium (USENIX Security 20)},
  year      = {2020},
  publisher = {USENIX Association},
  month     = aug,
  author    = {Lehmann, Daniel and Kinder, Johannes and Pradel, Michael}
}


@techreport{ChromeZero,
  title  = {The Problems and Promise of WebAssembly},
  year   = 2018,
  author = {Silvanovich, Natalie},
  month  = mar,
  editor = {Silvanovich, Natalie},
  url    = {https://googleprojectzero.blogspot.com/2018/08/the-problems-and-promise-of-webassembly.html}
}

@inbook{UnleashingCompilerRen,
  author    = {Ren, Xiaolei and Ho, Michael and Ming, Jiang and Lei, Yu and Li, Li},
  title     = {Unleashing the Hidden Power of Compiler Optimization on Binary Code Difference: An Empirical Study},
  year      = {2021},
  isbn      = {9781450383912},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3453483.3454035},
  abstract  = {Hunting binary code difference without source code (i.e., binary diffing) has compelling applications in software security. Due to the high variability of binary code, existing solutions have been driven towards measuring semantic similarities from syntactically different code. Since compiler optimization is the most common source contributing to binary code differences in syntax, testing the resilience against the changes caused by different compiler optimization settings has become a standard evaluation step for most binary diffing approaches. For example, 47 top-venue papers in the last 12 years compared different program versions compiled by default optimization levels (e.g., -Ox in GCC and LLVM). Although many of them claim they are immune to compiler transformations, it is yet unclear about their resistance to non-default optimization settings. Especially, we have observed that adversaries explored non-default compiler settings to amplify malware differences.  This paper takes the first step to systematically studying the effectiveness of compiler optimization on binary code differences. We tailor search-based iterative compilation for the auto-tuning of binary code differences. We develop BinTuner to search near-optimal optimization sequences that can maximize the amount of binary code differences. We run BinTuner with GCC 10.2 and LLVM 11.0 on SPEC benchmarks (CPU2006 &amp; CPU2017), Coreutils, and OpenSSL. Our experiments show that at the cost of 279 to 1,881 compilation iterations, BinTuner can find custom optimization sequences that are substantially better than the general -Ox settings. BinTuner's outputs seriously undermine prominent binary diffing tools' comparisons. In addition, the detection rate of the IoT malware variants tuned by BinTuner falls by more than 50%. Our findings paint a cautionary tale for security analysts that attackers have a new way to mutate malware code cost-effectively, and the research community needs to step back to reassess optimization-resistance evaluations.},
  booktitle = {Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
  pages     = {142–157},
  numpages  = {16}
}


@inproceedings{amarilli2011can,
  title        = {Can code polymorphism limit information leakage?},
  author       = {Amarilli, Antoine and M{\"u}ller, Sascha and Naccache, David and Page, Daniel and Rauzy, Pablo and Tunstall, Michael},
  booktitle    = {IFIP International Workshop on Information Security Theory and Practices},
  pages        = {1--21},
  year         = {2011},
  organization = {Springer}
}


@article{agosta2015meet,
  title     = {The {MEET} approach: Securing cryptographic embedded software against side channel attacks},
  author    = {Agosta, Giovanni and Barenghi, Alessandro and Pelosi, Gerardo and Scandale, Michele},
  journal   = {IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems},
  volume    = {34},
  number    = {8},
  pages     = {1320--1333},
  year      = {2015},
  publisher = {IEEE}
}


@inproceedings{crane2015thwarting,
  title     = {Thwarting Cache Side-Channel Attacks Through Dynamic Software Diversity.},
  author    = {Crane, Stephen and Homescu, Andrei and Brunthaler, Stefan and Larsen, Per and Franz, Michael},
  booktitle = {NDSS},
  pages     = {8--11},
  year      = {2015}
}


@inproceedings{courousse2016runtime,
  title        = {Runtime code polymorphism as a protection against side channel attacks},
  author       = {Courouss{\'e}, Damien and Barry, Thierno and Robisson, Bruno and Jaillon, Philippe and Potin, Olivier and Lanet, Jean-Louis},
  booktitle    = {IFIP International Conference on Information Security Theory and Practice},
  pages        = {136--152},
  year         = {2016},
  organization = {Springer}
}


@inproceedings{bruschi2007diversified,
  title     = {Diversified process replic{\ae} for defeating memory error exploits},
  author    = {Bruschi, Danilo and Cavallaro, Lorenzo and Lanzi, Andrea},
  booktitle = {Proc. of the Int. Performance, Computing, and Communications Conference},
  year      = {2007}
}


@inproceedings{cox06,
  title     = {N-variant systems: a secretless framework for security through diversity},
  author    = {Cox, Benjamin and Evans, David and Filipi, Adrian and Rowanhill, Jonathan and Hu, Wei and Davidson, Jack and Knight, John and Nguyen-Tuong, Anh and Hiser, Jason},
  booktitle = {Proc. of USENIX Security Symposium},
  year      = {2006},
  series    = {USENIX-SS'06},
  location  = {Vancouver, B.C., Canada},
  url       = {http://dl.acm.org/citation.cfm?id=1267336.1267344}
}


@techreport{salamat2007stopping,
  title       = {Stopping Buffer Overflow Attacks at Run-Time: Simultaneous Multi-Variant Program Execution on a Multicore Processor},
  author      = {Salamat, Babak and Gal, Andreas and Jackson, Todd and Manivannan, Karthik and Wagner, Gregor and Franz, Michael},
  year        = {2007},
  institution = {Technical Report 07-13, School of Information and Computer Sciences, UCIrvine}
}



@article{lu2018stopping,
  title     = {Stopping memory disclosures via diversification and replicated execution},
  author    = {Lu, Kangjie and Xu, Meng and Song, Chengyu and Kim, Taesoo and Lee, Wenke},
  journal   = {IEEE Transactions on Dependable and Secure Computing},
  year      = {2018},
  publisher = {IEEE}
}

@article{volckaert2015cloning,
  title   = {Cloning your gadgets: Complete ROP attack immunity with multi-variant execution},
  author  = {Volckaert, Stijn and Coppens, Bart and De Sutter, Bjorn},
  journal = {IEEE Transactions on Dependable and Secure Computing},
  volume  = {13},
  number  = {4},
  year    = {2015}
}


@article{SalamatJWWF11,
  author    = {Babak Salamat and
               Todd Jackson and
               Gregor Wagner and
               Christian Wimmer and
               Michael Franz},
  title     = {Runtime Defense against Code Injection Attacks Using Replicated Execution},
  journal   = {{IEEE} Trans. Dependable Secur. Comput.},
  volume    = {8},
  number    = {4},
  pages     = {588--601},
  year      = {2011},
  url       = {https://doi.org/10.1109/TDSC.2011.18},
  doi       = {10.1109/TDSC.2011.18},
  timestamp = {Thu, 09 Apr 2020 17:07:58 +0200},
  biburl    = {https://dblp.org/rec/journals/tdsc/SalamatJWWF11.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}


@inproceedings{osterlund2019kmvx,
  title     = {kMVX: Detecting kernel information leaks with multi-variant execution},
  author    = {{\"O}sterlund, Sebastian and Koning, Koen and Olivier, Pierre and Barbalace, Antonio and Bos, Herbert and Giuffrida, Cristiano},
  booktitle = {ASPLOS},
  year      = {2019}
}


@inproceedings{salamat2009orchestra,
  title     = {Orchestra: intrusion detection using parallel execution and monitoring of program variants in user-space},
  author    = {Salamat, Babak and Jackson, Todd and Gal, Andreas and Franz, Michael},
  booktitle = {Proceedings of the 4th ACM European conference on Computer systems},
  pages     = {33--46},
  year      = {2009}
}


@inproceedings{koning2016secure,
  title        = {Secure and efficient multi-variant execution using hardware-assisted process virtualization},
  author       = {Koning, Koen and Bos, Herbert and Giuffrida, Cristiano},
  booktitle    = {2016 46th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN)},
  pages        = {431--442},
  year         = {2016},
  organization = {IEEE}
}


@article{10.1145/3281662,
  author     = {Belleville, Nicolas and Courouss\'{e}, Damien and Heydemann, Karine and Charles, Henri-Pierre},
  title      = {Automated Software Protection for the Masses Against Side-Channel Attacks},
  year       = {2018},
  issue_date = {December 2018},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {15},
  number     = {4},
  issn       = {1544-3566},
  url        = {https://doi.org/10.1145/3281662},
  doi        = {10.1145/3281662},
  abstract   = {We present an approach and a tool to answer the need for effective, generic, and easily applicable protections against side-channel attacks. The protection mechanism is based on code polymorphism, so that the observable behaviour of the protected component is variable and unpredictable to the attacker. Our approach combines lightweight specialized runtime code generation with the optimization capabilities of static compilation. It is extensively configurable. Experimental results show that programs secured by our approach present strong security levels and meet the performance requirements of constrained systems.},
  journal    = {ACM Trans. Archit. Code Optim.},
  month      = {nov},
  articleno  = {47},
  numpages   = {27},
  keywords   = {runtime code generation, hiding, polymorphism, compilation, Side-channel attack}
}


@inproceedings{maurer2012tachyon,
  title     = {TACHYON: Tandem execution for efficient live patch testing},
  author    = {Maurer, Matthew and Brumley, David},
  booktitle = {21st USENIX Security Symposium (USENIX Security 12)},
  pages     = {617--630},
  year      = {2012}
}

@article{Kim2015,
  title   = {Dual Execution for On the Fly Fine Grained Execution Comparison},
  author  = {Kim, Dohyeong and Kwon, Yonghwi and Sumner, William N. and Zhang, Xiangyu and Xu, Dongyan},
  journal = {SIGPLAN Not.},
  year    = {2015}
}



@inproceedings{voulimeneas2021dmvx,
  title     = {dMVX: Secure and Efficient Multi-Variant Execution in a Distributed Setting},
  author    = {Voulimeneas, Alexios and Song, Dokyung and Larsen, Per and Franz, Michael and Volckaert, Stijn},
  booktitle = {Proceedings of the 14th European Workshop on Systems Security},
  pages     = {41--47},
  year      = {2021}
}

@inproceedings{9640153,
  author    = {Spies, Benedikt and Mock, Markus},
  booktitle = {2021 XLVII Latin American Computing Conference (CLEI)},
  title     = {An Evaluation of WebAssembly in Non-Web Environments},
  year      = {2021},
  volume    = {},
  number    = {},
  pages     = {1-10},
  doi       = {10.1109/CLEI53233.2021.9640153}
}


@article{natural_diversity,
  author     = {Baudry, Benoit and Monperrus, Martin},
  title      = {The Multiple Facets of Software Diversity: Recent Developments in Year 2000 and Beyond},
  year       = {2015},
  issue_date = {September 2015},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {48},
  number     = {1},
  issn       = {0360-0300},
  url        = {https://doi.org/10.1145/2807593},
  doi        = {10.1145/2807593},
  abstract   = {Early experiments with software diversity in the mid 1970s investigated N-version programming and recovery blocks to increase the reliability of embedded systems. Four decades later, the literature about software diversity has expanded in multiple directions: goals (fault tolerance, security, software engineering), means (managed or automated diversity), and analytical studies (quantification of diversity and its impact). Our article contributes to the field of software diversity as the first work that adopts an inclusive vision of the area, with an emphasis on the most recent advances in the field. This survey includes classical work about design and data diversity for fault tolerance, as well as the cybersecurity literature that investigates randomization at different system levels. It broadens this standard scope of diversity to include the study and exploitation of natural diversity and the management of diverse software products. Our survey includes the most recent works, with an emphasis from 2000 to the present. The targeted audience is researchers and practitioners in one of the surveyed fields who miss the big picture of software diversity. Assembling the multiple facets of this fascinating topic sheds a new light on the field.},
  journal    = {ACM Comput. Surv.},
  month      = {sep},
  articleno  = {16},
  numpages   = {26},
  keywords   = {design principles, Software diversity, program transformation}
}

@inproceedings{SMT_solver,
  author    = {de Moura, Leonardo
               and Bj{\o}rner, Nikolaj},
  editor    = {Ramakrishnan, C. R.
               and Rehof, Jakob},
  title     = {Z3: An Efficient SMT Solver},
  booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
  year      = {2008},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {337--340},
  abstract  = {Satisfiability Modulo Theories (SMT) problem is a decision problem for logical first order formulas with respect to combinations of background theories such as: arithmetic, bit-vectors, arrays, and uninterpreted functions. Z3 is a new and efficient SMT Solver freely available from Microsoft Research. It is used in various software verification and analysis applications.},
  isbn      = {978-3-540-78800-3}
}



@article{2021arXiv210913498S,
  author        = {{Shypula}, Alex and {Yin}, Pengcheng and {Lacomis}, Jeremy and {Le Goues}, Claire and {Schwartz}, Edward and {Neubig}, Graham},
  title         = {{Learning to Superoptimize Real-world Programs}},
  journal       = {arXiv e-prints},
  keywords      = {Computer Science - Machine Learning, Computer Science - Artificial Intelligence, Computer Science - Programming Languages, Computer Science - Software Engineering},
  year          = 2021,
  month         = sep,
  eid           = {arXiv:2109.13498},
  pages         = {arXiv:2109.13498},
  archiveprefix = {arXiv},
  eprint        = {2109.13498},
  primaryclass  = {cs.LG},
  adsurl        = {https://ui.adsabs.harvard.edu/abs/2021arXiv210913498S},
  adsnote       = {Provided by the SAO/NASA Astrophysics Data System}
}


@inproceedings{bhatkar03,
  title     = {Address obfuscation: an efficient approach to combat a board range of memory error exploits},
  author    = {Bhatkar, Sandeep and DuVarney, Daniel C. and Sekar, R.},
  booktitle = {Proceedings of the USENIX Security Symposium},
  year      = {2003}
}



@inproceedings{Kc03,
  title     = {Countering code-injection attacks with instruction-set randomization},
  author    = {Kc, Gaurav S. and Keromytis, Angelos D. and Prevelakis, Vassilis},
  booktitle = {Proc. of CCS},
  year      = {2003},
  pages     = {272--280}
}


@inproceedings{barrantes2003randomized,
  title     = {Randomized instruction set emulation to disrupt binary code injection attacks},
  author    = {Barrantes, Elena Gabriela and Ackley, David H and Forrest, Stephanie and Palmer, Trek S and Stefanovic, Darko and Zovi, Dino Dai},
  booktitle = {Proc. CCS},
  pages     = {281--289},
  year      = {2003}
}


@phdthesis{jackson,
  title  = {On the Design, Implications, and Effects of Implementing Software Diversity for Security},
  author = {Todd Jackson},
  school = {University of California, Irvine},
  year   = {2012}
}


@techreport{Chew02mitigatingbuffer,
  title       = {Mitigating buffer overflows by operating system randomization},
  author      = { Chew, Monica and  Song, Dawn},
  institution = {Carnegie Mellon University},
  year        = {2002},
  number      = {CS-02-197}
}

@inproceedings{bhatkar2005efficient,
  title     = {Efficient techniques for comprehensive protection from memory error exploits},
  author    = {Bhatkar, Sandeep and Sekar, Ron and DuVarney, Daniel C},
  booktitle = {Proceedings of the USENIX Security Symposium},
  year      = {2005},
  pages     = {271--286}
}


@inproceedings{aga2019smokestack,
  title     = {Smokestack: thwarting DOP attacks with runtime stack layout randomization},
  author    = {Aga, Misiker Tadesse and Austin, Todd},
  booktitle = {Proc. of CGO},
  pages     = {26--36},
  year      = {2019},
  url       = {https://drive.google.com/file/d/12TvsrgL8Wt6IMfe6ASUp8y69L-bCVao0/view}
}


@article{lee2021savior,
  title   = {SaVioR: Thwarting Stack-Based Memory Safety Violations by Randomizing Stack Layout},
  author  = {Lee, Seongman and Kang, Hyeonwoo and Jang, Jinsoo and Kang, Brent Byunghoon},
  journal = {IEEE Transactions on Dependable and Secure Computing},
  year    = {2021},
  url     = {https://ieeexplore.ieee.org/iel7/8858/4358699/09369900.pdf}
}



@inproceedings{xu2020merr,
  title     = {Merr: Improving security of persistent memory objects via efficient memory exposure reduction and randomization},
  author    = {Xu, Yuanchao and Solihin, Yan and Shen, Xipeng},
  booktitle = {Proc. of ASPLOS},
  pages     = {987--1000},
  year      = {2020},
  url       = {https://dl.acm.org/doi/pdf/10.1145/3373376.3378492}
}



@inproceedings{10.1145/2384616.2384628,
  author    = {Kulkarni, Sameer and Cavazos, John},
  title     = {Mitigating the Compiler Optimization Phase-Ordering Problem Using Machine Learning},
  year      = {2012},
  isbn      = {9781450315616},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2384616.2384628},
  doi       = {10.1145/2384616.2384628},
  abstract  = {Today's compilers have a plethora of optimizations to choose from, and the correct choice of optimizations can have a significant impact on the performance of the code being optimized. Furthermore, choosing the correct order in which to apply those optimizations has been a long standing problem in compilation research. Each of these optimizations interacts with the code and in turn with all other optimizations in complicated ways. Traditional compilers typically apply the same set of optimization in a fixed order to all functions in a program, without regard the code being optimized.Understanding the interactions of optimizations is very important in determining a good solution to the phase-ordering problem. This paper develops a new approach that automatically selects good optimization orderings on a per method basis within a dynamic compiler. Our approach formulates the phase-ordering problem as a Markov process and uses a characterization of the current state of the code being optimized to creating a better solution to the phase ordering problem. Our technique uses neuro-evolution to construct an artificial neural network that is capable of predicting beneficial optimization ordering for a piece of code that is being optimized. We implemented our technique in Jikes RVM and achieved significant improvements on a set of standard Java benchmarks over a well-engineered fixed order.},
  booktitle = {Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications},
  pages     = {147–162},
  numpages  = {16},
  keywords  = {neural networks, machine learning, java, jikes rvm, phase ordering, compiler optimization, source code feature generation},
  location  = {Tucson, Arizona, USA},
  series    = {OOPSLA '12}
}

@article{phase-ordering-problem,
  author     = {Kulkarni, Sameer and Cavazos, John},
  title      = {Mitigating the Compiler Optimization Phase-Ordering Problem Using Machine Learning},
  year       = {2012},
  issue_date = {October 2012},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {47},
  number     = {10},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/2398857.2384628},
  doi        = {10.1145/2398857.2384628},
  abstract   = {Today's compilers have a plethora of optimizations to choose from, and the correct choice of optimizations can have a significant impact on the performance of the code being optimized. Furthermore, choosing the correct order in which to apply those optimizations has been a long standing problem in compilation research. Each of these optimizations interacts with the code and in turn with all other optimizations in complicated ways. Traditional compilers typically apply the same set of optimization in a fixed order to all functions in a program, without regard the code being optimized.Understanding the interactions of optimizations is very important in determining a good solution to the phase-ordering problem. This paper develops a new approach that automatically selects good optimization orderings on a per method basis within a dynamic compiler. Our approach formulates the phase-ordering problem as a Markov process and uses a characterization of the current state of the code being optimized to creating a better solution to the phase ordering problem. Our technique uses neuro-evolution to construct an artificial neural network that is capable of predicting beneficial optimization ordering for a piece of code that is being optimized. We implemented our technique in Jikes RVM and achieved significant improvements on a set of standard Java benchmarks over a well-engineered fixed order.},
  journal    = {SIGPLAN Not.},
  month      = {oct},
  pages      = {147–162},
  numpages   = {16},
  keywords   = {compiler optimization, machine learning, phase ordering, jikes rvm, java, neural networks, source code feature generation}
}


@misc{MTDNationalCyberLaep,
  title   = {{National Cyber Leap Year}},
  howpublished     = {\url{https://www.nitrd.gov/nitrdgroups/index.php?title=National_Cyber_Leap_Year}},
  urldate = {2021-02-02},
  year    = {2021},
  author  = {{NSA}}
}

@inproceedings{10.1145/3318216.3363338,
  author    = {Roy, Abhishek and Chhabra, Anshuman and Kamhoua, Charles A. and Mohapatra, Prasant},
  title     = {A Moving Target Defense against Adversarial Machine Learning},
  year      = {2019},
  booktitle = {Proceedings of the 4th ACM/IEEE Symposium on Edge Computing},
  pages     = {383–388}
}

@inproceedings{sengupta,
  author    = {Sengupta, Sailik and Vadlamudi, Satya Gautam and Kambhampati, Subbarao and Doup\'{e}, Adam and Zhao, Ziming and Taguinod, Marthony and Ahn, Gail-Joon},
  title     = {A Game Theoretic Approach to Strategy Generation for Moving Target Defense in Web Applications},
  year      = {2017},
  booktitle = {Proceedings of the 16th Conference on Autonomous Agents and MultiAgent Systems},
  pages     = {178–186},
  numpages  = {9},
  keywords  = {moving target defense, bayesian games, stackelberg equilibrium, security games}
}

@inproceedings{EsAsm.js,
  author    = {Van Es, Noah and Nicolay, Jens and Stievenart, Quentin and D'Hondt, Theo and De Roover, Coen},
  title     = {A Performant Scheme Interpreter in Asm.Js},
  year      = {2016},
  isbn      = {9781450337397},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2851613.2851748},
  doi       = {10.1145/2851613.2851748},
  abstract  = {This paper presents the implementation of an efficient interpreter for a Scheme-like language using manually written asm.js code. The asm.js specification defines an optimizable subset of JavaScript which has already served well as a compilation target for web applications where performance is critical. However, its usage as a human-writable language that can be integrated into existing projects to improve performance has remained largely unexplored. We therefore apply this strategy to optimize the implementation of an interpreter. We also discuss the feasibility of this approach, as writing asm.js by hand is generally not its recommended use-case. We therefore present a macro system to solve the challenges we encounter. The resulting interpreter is compared to the original C implementation and its compiled equivalent in asm.js. This way, we evaluate whether manual integration with asm.js provides the necessary performance to bring larger applications and runtimes to the web.},
  booktitle = {Proceedings of the 31st Annual ACM Symposium on Applied Computing},
  pages     = {1944–1951},
  numpages  = {8},
  keywords  = {asm.js, JavaScript, optimization},
  location  = {Pisa, Italy},
  series    = {SAC '16}
}



@article{NEEDLEMAN1970443,
  title        = {A General Method Applicable to the Search for Similarities in the Amino Acid Sequence of Two Proteins},
  volume       = {48},
  issn         = {0022-2836},
  url          = {http://www.sciencedirect.com/science/article/pii/0022283670900574},
  doi          = {https://doi.org/10.1016/0022-2836(70)90057-4},
  abstract     = {A computer adaptable method for finding similarities in the amino acid sequences of two proteins has been developed. From these findings it is possible to determine whether significant homology exists between the proteins. This information is used to trace their possible evolutionary development. The maximum match is a number dependent upon the similarity of the sequences. One of its definitions is the largest number of amino acids of one protein that can be matched with those of a second protein allowing for all possible interruptions in either of the sequences. While the interruptions give rise to a very large number of comparisons, the method efficiently excludes from consideration those comparisons that cannot contribute to the maximum match. Comparisons are made from the smallest unit of significance, a pair of amino acids, one from each protein. All possible pairs are represented by a two-dimensional array, and all possible comparisons are represented by pathways through the array. For this maximum match only certain of the possible pathways must be evaluated. A numerical value, one in this case, is assigned to every cell in the array representing like amino acids. The maximum match is the largest number that would result from summing the cell values of every pathway.},
  number       = {3},
  journaltitle = {Journal of Molecular Biology},
  shortjournal = {J. Mol. Biol.},
  date         = {1970},
  year         = {1970},
  pages        = {443-453},
  author       = {Needleman, Saul B. and Wunsch, Christian D.}
}

@inproceedings{shillaker2020faasm,
  title     = {Faasm: Lightweight isolation for efficient stateful serverless computing},
  author    = {Shillaker, Simon and Pietzuch, Peter},
  booktitle = {USENIX Annual Technical Conference},
  pages     = {419--433},
  year      = {2020}
}

@article{morgan2015web,
  title   = {Web timing attacks made practical},
  author  = {Morgan, Timothy D and Morgan, Jason W},
  journal = {Black Hat},
  year    = {2015}
}

@inproceedings{595185,
  author    = {Forrest, S. and Somayaji, A. and Ackley, D.H.},
  booktitle = {Proceedings. The Sixth Workshop on Hot Topics in Operating Systems (Cat. No.97TB100133)},
  title     = {Building diverse computer systems},
  year      = {1997},
  volume    = {},
  number    = {},
  pages     = {67-72},
  doi       = {10.1109/HOTOS.1997.595185}
}


@article{10.1145/390016.808467,
  author     = {Randell, B.},
  title      = {System Structure for Software Fault Tolerance},
  year       = {1975},
  issue_date = {June 1975},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {10},
  number     = {6},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/390016.808467},
  doi        = {10.1145/390016.808467},
  abstract   = {The paper presents, and discusses the rationale behind, a method for structuring complex computing systems by the use of what we term “recovery blocks”, “conversations” and “fault-tolerant interfaces”. The aim is to facilitate the provision of dependable error detection and recovery facilities which can cope with errors caused by residual design inadequacies, particularly in the system software, rather than merely the occasional malfunctioning of hardware components.},
  journal    = {SIGPLAN Not.},
  month      = {apr},
  pages      = {437–449},
  numpages   = {13},
  keywords   = {Recursive cache, Alternate block, Error recovery, Conversation, Acceptance test, Error detection, Checkpoint, Recovery block}
}

@article{1659219,
  author  = {Avizienis and Kelly},
  journal = {Computer},
  title   = {Fault Tolerance by Design Diversity: Concepts and Experiments},
  year    = {1984},
  volume  = {17},
  number  = {8},
  pages   = {67-80},
  doi     = {10.1109/MC.1984.1659219}
}
@article{CHEN201060,
  title    = {Adaptive Random Testing: The ART of test case diversity},
  journal  = {Journal of Systems and Software},
  volume   = {83},
  number   = {1},
  pages    = {60-66},
  year     = {2010},
  note     = {SI: Top Scholars},
  issn     = {0164-1212},
  doi      = {https://doi.org/10.1016/j.jss.2009.02.022},
  url      = {https://www.sciencedirect.com/science/article/pii/S0164121209000405},
  author   = {Tsong Yueh Chen and Fei-Ching Kuo and Robert G. Merkel and T.H. Tse},
  keywords = {Software testing, Random testing, Adaptive random testing, Adaptive random sequence, Failure-based testing, Failure pattern},
  abstract = {Random testing is not only a useful testing technique in itself, but also plays a core role in many other testing methods. Hence, any significant improvement to random testing has an impact throughout the software testing community. Recently, Adaptive Random Testing (ART) was proposed as an effective alternative to random testing. This paper presents a synthesis of the most important research results related to ART. In the course of our research and through further reflection, we have realised how the techniques and concepts of ART can be applied in a much broader context, which we present here. We believe such ideas can be applied in a variety of areas of software testing, and even beyond software testing. Amongst these ideas, we particularly note the fundamental role of diversity in test case selection strategies. We hope this paper serves to provoke further discussions and investigations of these ideas.}
}

@book{pohl2005software,
  title     = {Software product line engineering: foundations, principles, and techniques},
  author    = {Pohl, Klaus and B{\"o}ckle, G{\"u}nter and Van Der Linden, Frank},
  volume    = {1},
  year      = {2005},
  publisher = {Springer}
}

@article{Chen2010AdaptiveRT,
  title   = {Adaptive Random Testing: The ART of test case diversity},
  author  = {Tsong Yueh Chen and Fei-Ching Kuo and Robert G. Merkel and T. H. Tse},
  journal = {J. Syst. Softw.},
  year    = {2010},
  volume  = {83},
  pages   = {60-66}
}

@inproceedings{10.1145/2025113.2025133,
  author    = {Sidiroglou-Douskos, Stelios and Misailovic, Sasa and Hoffmann, Henry and Rinard, Martin},
  title     = {Managing Performance vs. Accuracy Trade-Offs with Loop Perforation},
  year      = {2011},
  isbn      = {9781450304436},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2025113.2025133},
  doi       = {10.1145/2025113.2025133},
  abstract  = {Many modern computations (such as video and audio encoders, Monte Carlo simulations, and machine learning algorithms) are designed to trade off accuracy in return for increased performance. To date, such computations typically use ad-hoc, domain-specific techniques developed specifically for the computation at hand. Loop perforation provides a general technique to trade accuracy for performance by transforming loops to execute a subset of their iterations. A criticality testing phase filters out critical loops (whose perforation produces unacceptable behavior) to identify tunable loops (whose perforation produces more efficient and still acceptably accurate computations). A perforation space exploration algorithm perforates combinations of tunable loops to find Pareto-optimal perforation policies. Our results indicate that, for a range of applications, this approach typically delivers performance increases of over a factor of two (and up to a factor of seven) while changing the result that the application produces by less than 10%.},
  booktitle = {Proceedings of the 19th ACM SIGSOFT Symposium and the 13th European Conference on Foundations of Software Engineering},
  pages     = {124–134},
  numpages  = {11},
  keywords  = {profiling, loop perforation, quality of service},
  location  = {Szeged, Hungary},
  series    = {ESEC/FSE '11}
}

@article{okhravi2013survey,
  title   = {Survey of cyber moving targets},
  author  = {Okhravi, H and Rabe, MA and Mayberry, TJ and Leonard, WG and Hobson, TR and Bigelow, D and Streilein, WW},
  journal = {Massachusetts Inst of Technology Lexington Lincoln Lab, No. MIT/LL-TR-1166},
  year    = {2013}
}

@inproceedings{wobfuscator,
  author    = {A. Romano and D. Lehmann and M. Pradel and W. Wang},
  booktitle = {2022 2022 IEEE Symposium on Security and Privacy (SP) (SP)},
  title     = {Wobfuscator: Obfuscating JavaScript Malware via Opportunistic Translation to WebAssembly},
  year      = {2022},
  volume    = {},
  issn      = {2375-1207},
  pages     = {1101-1116},
  keywords  = {webassembly;obfuscation;malware;opportunistic;web},
  doi       = {10.1109/SP46214.2022.00064},
  url       = {https://doi.ieeecomputersociety.org/10.1109/SP46214.2022.00064},
  publisher = {IEEE Computer Society},
  address   = {Los Alamitos, CA, USA},
  month     = {may}
}



@article{johnson2021,
  title   = {SFI safety for native-compiled Wasm},
  author  = {Johnson, Evan and Thien, David and Alhessi, Yousef and Narayan, Shravan and Brown, Fraser and Lerner, Sorin and McMullen, Tyler and Savage, Stefan and Stefan, Deian},
  journal = {NDSS. Internet Society},
  year    = {2021}
}



@article{MEWE,
  author        = {{Cabrera Arteaga}, Javier and {Laperdrix}, Pierre and {Monperrus}, Martin and {Baudry}, Benoit},
  title         = {{Multi-Variant Execution at the Edge}},
  journal       = {arXiv e-prints},
  keywords      = {Computer Science - Software Engineering},
  year          = 2021,
  month         = aug,
  eid           = {arXiv:2108.08125},
  pages         = {arXiv:2108.08125},
  archiveprefix = {arXiv},
  eprint        = {2108.08125},
  primaryclass  = {cs.SE},
  adsurl        = {https://ui.adsabs.harvard.edu/abs/2021arXiv210808125C},
  adsnote       = {Provided by the SAO/NASA Astrophysics Data System}
}

@inproceedings{CROW,
  title     = {CROW: code diversification for webassembly},
  author    = {Cabrera Arteaga, Javier and Floros, Orestis and Vera Perez, Oscar and Baudry, Benoit and Monperrus, Martin},
  booktitle = {MADWeb, NDSS 2021},
  year      = {2021},
  url       = {https://doi.org/10.14722/madweb.2021.23004}
}

@article{harrand2020java,
  title     = {Java decompiler diversity and its application to meta-decompilation},
  author    = {Harrand, Nicolas and Soto-Valero, C{\'e}sar and Monperrus, Martin and Baudry, Benoit},
  journal   = {Journal of Systems and Software},
  volume    = {168},
  pages     = {110645},
  year      = {2020},
  publisher = {Elsevier}
}
@article{Tsoupidi2020ConstraintBasedSD,
  title   = {Constraint-Based Software Diversification for Efficient Mitigation of Code-Reuse Attacks},
  author  = {Rodothea Myrsini Tsoupidi and Roberto Casta{\~n}eda Lozano and Beno{\^i}t Baudry},
  journal = {ArXiv},
  year    = {2020},
  volume  = {abs/2007.08955}
}
@article{10.1145/93548.93550,
  author     = {Pettis, Karl and Hansen, Robert C.},
  title      = {Profile Guided Code Positioning},
  year       = {1990},
  issue_date = {Jun. 1990},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {25},
  number     = {6},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/93548.93550},
  doi        = {10.1145/93548.93550},
  abstract   = {This paper presents the results of our investigation of code positioning techniques using execution profile data as input into the compilation process. The primary objective of the positioning is to reduce the overhead of the instruction memory hierarchy.After initial investigation in the literature, we decided to implement two prototypes for the Hewlett-Packard Precision Architecture (PA-RISC). The first, built on top of the linker, positions code based on whole procedures. This prototype has the ability to move procedures into an order that is determined by a “closest is best” strategy.The second prototype, built on top of an existing optimizer package, positions code based on basic blocks within procedures. Groups of basic blocks that would be better as straight-line sequences are identified as chains. These chains are then ordered according to branch heuristics. Code that is never executed during the data collection runs can be physically separated from the primary code of a procedure by a technique we devised called procedure splitting.The algorithms we implemented are described through examples in this paper. The performance improvements from our work are also summarized in various tables and charts.},
  journal    = {SIGPLAN Not.},
  month      = {jun},
  pages      = {16–27},
  numpages   = {12}
}

@inproceedings{pettisochhansen,
  author    = {Pettis, Karl and Hansen, Robert C.},
  title     = {Profile Guided Code Positioning},
  year      = {1990},
  isbn      = {0897913647},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/93542.93550},
  doi       = {10.1145/93542.93550},
  abstract  = {This paper presents the results of our investigation of code positioning techniques using execution profile data as input into the compilation process. The primary objective of the positioning is to reduce the overhead of the instruction memory hierarchy.After initial investigation in the literature, we decided to implement two prototypes for the Hewlett-Packard Precision Architecture (PA-RISC). The first, built on top of the linker, positions code based on whole procedures. This prototype has the ability to move procedures into an order that is determined by a “closest is best” strategy.The second prototype, built on top of an existing optimizer package, positions code based on basic blocks within procedures. Groups of basic blocks that would be better as straight-line sequences are identified as chains. These chains are then ordered according to branch heuristics. Code that is never executed during the data collection runs can be physically separated from the primary code of a procedure by a technique we devised called procedure splitting.The algorithms we implemented are described through examples in this paper. The performance improvements from our work are also summarized in various tables and charts.},
  booktitle = {Proceedings of the ACM SIGPLAN 1990 Conference on Programming Language Design and Implementation},
  pages     = {16–27},
  numpages  = {12},
  location  = {White Plains, New York, USA},
  series    = {PLDI '90}
}


@inproceedings{ElKhalil2004,
  author    = {El-Khalil, Rakan
               and Keromytis, Angelos D.},
  editor    = {Lopez, Javier
               and Qing, Sihan
               and Okamoto, Eiji},
  title     = {Hydan: Hiding Information in Program Binaries},
  booktitle = {Information and Communications Security},
  year      = {2004},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {187--199},
  abstract  = {We present a scheme to steganographically embed information in x86 program binaries. We define sets of functionally-equivalent instructions, and use a key-derived selection process to encode information in machine code by using the appropriate instructions from each set. Such a scheme can be used to watermark (or fingerprint) code, sign executables, or simply create a covert communication channel. We experimentally measure the capacity of the covert channel by determining the distribution of equivalent instructions in several popular operating system distributions. Our analysis shows that we can embed only a limited amount of information in each executable (approximately {\$}{\backslash}frac{\{}1{\}}{\{}110{\}}{\$}bit encoding rate), although this amount is sufficient for some of the potential applications mentioned. We conclude by discussing potential improvements to the capacity of the channel and other future work.},
  isbn      = {978-3-540-30191-2}
}



@article{Cleemput2012,
  author     = {Cleemput, Jeroen V. and Coppens, Bart and De Sutter, Bjorn},
  title      = {Compiler Mitigations for Time Attacks on Modern X86 Processors},
  year       = {2012},
  issue_date = {January 2012},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {8},
  number     = {4},
  issn       = {1544-3566},
  url        = {https://doi.org/10.1145/2086696.2086702},
  doi        = {10.1145/2086696.2086702},
  abstract   = {This paper studies and evaluates the extent to which automated compiler techniques can defend against timing-based side channel attacks on modern x86 processors. We study how modern x86 processors can leak timing information through side channels that relate to data flow. We study the efficiency, effectiveness, portability, predictability and sensitivity of several mitigating code transformations that eliminate or minimize key-dependent execution time variations. Furthermore, we discuss the extent to which compiler backends are a suitable tool to provide automated support for the proposed mitigations.},
  journal    = {ACM Trans. Archit. Code Optim.},
  month      = {jan},
  articleno  = {23},
  numpages   = {20},
  keywords   = {variable latency instructions, Time-based side channels, x86 architecture}
}

@inproceedings{Younan2006,
  author    = {Younan, Yves and Pozza, Davide and Piessens, Frank and Joosen, Wouter},
  booktitle = {2006 22nd Annual Computer Security Applications Conference (ACSAC'06)},
  title     = {Extended Protection against Stack Smashing Attacks without Performance Loss},
  year      = {2006},
  volume    = {},
  number    = {},
  pages     = {429-438},
  doi       = {10.1109/ACSAC.2006.27}
}



@inbook{ahodragonbook,
  author    = {Aho, Alfred V. and Sethi, Ravi and Ullman, Jeffrey D.},
  title     = {Compilers: Principles, Techniques, and Tools},
  year      = {1986},
  isbn      = {0201100886},
  chapter   = {1},
  pages     = {28-31},
  publisher = {Addison-Wesley Longman Publishing Co., Inc.},
  address   = {USA}
}

@article{Sasnauskas2017Souper:Superoptimizer,
  title   = {{Souper: A Synthesizing Superoptimizer}},
  year    = {2017},
  author  = {Sasnauskas, Raimondas and Chen, Yang and Collingbourne, Peter and Ketema, Jeroen and Lup, Gratian and Taneja, Jubi and Regehr, John},
  journal = {arXiv preprint 1711.04422}
}


@inproceedings{10.1007/978-3-540-78800-3_24,
  author    = {de Moura, Leonardo
               and Bj{\o}rner, Nikolaj},
  editor    = {Ramakrishnan, C. R.
               and Rehof, Jakob},
  title     = {Z3: An Efficient SMT Solver},
  booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
  year      = {2008},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {337--340},
  abstract  = {Satisfiability Modulo Theories (SMT) problem is a decision problem for logical first order formulas with respect to combinations of background theories such as: arithmetic, bit-vectors, arrays, and uninterpreted functions. Z3 is a new and efficient SMT Solver freely available from Microsoft Research. It is used in various software verification and analysis applications.},
  isbn      = {978-3-540-78800-3}
}



@inproceedings{liljestrand2021pacstack,
  title     = {PACStack: an Authenticated Call Stack},
  author    = {Liljestrand, Hans and Nyman, Thomas and Gunn, Lachlan J and Ekberg, Jan-Erik and Asokan, N},
  booktitle = {30th USENIX Security Symposium (USENIX Security 21)},
  year      = {2021}
}


@inproceedings{rane2015raccoon,
  title     = {Raccoon: Closing digital side-channels through obfuscated execution},
  author    = {Rane, Ashay and Lin, Calvin and Tiwari, Mohit},
  booktitle = {24th USENIX Security Symposium (USENIX Security 15)},
  pages     = {431--446},
  year      = {2015}
}


@article{ryder1979,
  title     = {Constructing the call graph of a program},
  author    = {Ryder, Barbara G},
  journal   = {IEEE Transactions on Software Engineering},
  number    = {3},
  pages     = {216--226},
  year      = {1979},
  publisher = {IEEE}
}


@misc{WASI,
  title   = {WebAssembly System Interface},
  howpublished     = {\url{https://github.com/WebAssembly/WASI}},
  urldate = {2021-07-22},
  year    = {2021}
}

@misc{CVE,
  title   = {Stop a Wasm Compiler Bug Before it Becomes a Problem | Fastly},
  howpublished     = {\url{https://www.fastly.com/blog/defense-in-depth-stopping-a-wasm-compiler-bug-before-it-became-a-problem}},
  urldate = {2021-07-22},
  year    = {2021}
}



@inproceedings{10.1007/978-3-642-14107-2_7,
  author    = {Guha, Arjun
               and Saftoiu, Claudiu
               and Krishnamurthi, Shriram},
  editor    = {D'Hondt, Theo},
  title     = {The Essence of JavaScript},
  booktitle = {ECOOP 2010 -- Object-Oriented Programming},
  year      = {2010},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {126--150},
  abstract  = {We reduce JavaScript to a core calculus structured as a small-step operational semantics. We present several peculiarities of the language and show that our calculus models them. We explicate the desugaring process that turns JavaScript programs into ones in the core. We demonstrate faithfulness to JavaScript using real-world test suites. Finally, we illustrate utility by defining a security property, implementing it as a type system on the core, and extending it to the full language.},
  isbn      = {978-3-642-14107-2}
}



@inproceedings{churchill2019,
  author    = {Churchill, Berkeley and Padon, Oded and Sharma, Rahul and Aiken, Alex},
  title     = {Semantic Program Alignment for Equivalence Checking},
  year      = {2019},
  isbn      = {9781450367127},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3314221.3314596},
  doi       = {10.1145/3314221.3314596},
  abstract  = {We introduce a robust semantics-driven technique for program equivalence checking. Given two functions we find a trace alignment over a set of concrete executions of both programs and construct a product program particularly amenable to checking equivalence.  We demonstrate that our algorithm is applicable to challenging equivalence problems beyond the scope of existing techniques. For example, we verify the correctness of the hand-optimized vector implementation of strlen that ships as part of the GNU C Library, as well as the correctness of vectorization optimizations for 56 benchmarks derived from the Test Suite for Vectorizing Compilers.},
  booktitle = {Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  pages     = {1027–1040},
  numpages  = {14},
  keywords  = {verification, equivalence checking},
  location  = {Phoenix, AZ, USA},
  series    = {PLDI 2019}
}

@inproceedings{SMTGupta,
  author    = {Gupta, Shubhani
               and Saxena, Aseem
               and Mahajan, Anmol
               and Bansal, Sorav},
  editor    = {Beyersdorff, Olaf
               and Wintersteiger, Christoph M.},
  title     = {Effective Use of SMT Solvers for Program Equivalence Checking Through Invariant-Sketching and Query-Decomposition},
  booktitle = {Theory and Applications of Satisfiability Testing -- SAT 2018},
  year      = {2018},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {365--382},
  abstract  = {Program equivalence checking is a fundamental problem in computer science with applications to translation validation and automatic synthesis of compiler optimizations. Contemporary equivalence checkers employ SMT solvers to discharge proof obligations generated by their equivalence checking algorithm. Equivalence checkers also involve algorithms to infer invariants that relate the intermediate states of the two programs being compared for equivalence. We present a new algorithm, called invariant-sketching, that allows the inference of the required invariants through the generation of counter-examples using SMT solvers. We also present an algorithm, called query-decomposition, that allows a more capable use of SMT solvers for application to equivalence checking. Both invariant-sketching and query-decomposition help us prove equivalence across program transformations that could not be handled by previous equivalence checking algorithms.},
  isbn      = {978-3-319-94144-8}
}



@inproceedings{LeCompilers,
  author    = {Le, Vu and Afshari, Mehrdad and Su, Zhendong},
  title     = {Compiler Validation via Equivalence modulo Inputs},
  year      = {2014},
  booktitle = {Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  pages     = {216–226},
  numpages  = {11},
  keywords  = {equivalent program variants, automated testing, miscompilation, compiler testing},
  location  = {Edinburgh, United Kingdom},
  series    = {PLDI ’14}
}

@book{cox1893cinderella,
  title     = {Cinderella: Three hundred and forty-five variants of Cinderella, Catskin, and Cap o'Rushes},
  author    = {Cox, Marian Roalfe},
  number    = {31},
  year      = {1893},
  publisher = {Folk-lore Society}
}

@inbook{WasmSuperoptimizer,
  author    = {Cabrera Arteaga, Javier and Donde, Shrinish and Gu, Jian and Floros, Orestis and Satabin, Lucas and Baudry, Benoit and Monperrus, Martin},
  title     = {Superoptimization of WebAssembly Bytecode},
  year      = {2020},
  isbn      = {9781450375078},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3397537.3397567},
  abstract  = {Motivated by the fast adoption of WebAssembly, we propose the first functional pipeline to support the superoptimization of WebAssembly bytecode. Our pipeline works over LLVM and Souper. We evaluate our superoptimization pipeline with 12 programs from the Rosetta code project. Our pipeline improves the code section size of 8 out of 12 programs. We discuss the challenges faced in superoptimization of WebAssembly with two case studies.},
  booktitle = {Conference Companion of the 4th International Conference on Art, Science, and Engineering of Programming},
  pages     = {36–40},
  numpages  = {5}
}
@inproceedings{STRAC,
  author    = {Cabrera Arteaga, Javier and Monperrus, Martin and Baudry, Benoit},
  title     = {Scalable Comparison of JavaScript V8 Bytecode Traces},
  year      = {2019},
  isbn      = {9781450369879},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3358504.3361228},
  doi       = {10.1145/3358504.3361228},
  abstract  = {The comparison and alignment of runtime traces are essential, e.g., for semantic analysis or debugging. However, naive sequence alignment algorithms cannot address the needs of the modern web: (i) the bytecode generation process of V8 is not deterministic; (ii) bytecode traces are large.  We present STRAC, a scalable and extensible tool tailored to compare bytecode traces generated by the V8 JavaScript engine. Given two V8 bytecode traces and a distance function between trace events, STRAC computes and provides the best alignment. The key insight is to split access between memory and disk. STRAC can identify semantically equivalent web pages and is capable of processing huge V8 bytecode traces whose order of magnitude matches today's web like https://2019.splashcon.org, which generates approx. 150k of V8 bytecode instructions.},
  booktitle = {Proceedings of the 11th ACM SIGPLAN International Workshop on Virtual Machines and Intermediate Languages},
  pages     = {22–31},
  numpages  = {10},
  keywords  = {Sequence alignment, V8, Bytecode, Similarity measurement, JavaScript},
  location  = {Athens, Greece},
  series    = {VMIL 2019}
}


@inproceedings{pMendkiServerless,
  author    = {P. {Mendki}},
  booktitle = {2020 IEEE Cloud Summit},
  title     = {Evaluating Webassembly Enabled Serverless Approach for Edge Computing},
  year      = {2020},
  volume    = {},
  number    = {},
  pages     = {161-166},
  doi       = {10.1109/IEEECloudSummit48914.2020.00031}
}

@techreport{Napieralla2020,
  author = {Napieralla, Jonah},
  file   = {:Users/javierca/Library/Application Support/Mendeley Desktop/Downloaded/Napieralla - 2020 - Considering WebAssembly Containers for Edge Computing on Hardware-Constrained IoT Devices.pdf:pdf},
  isbn   = {4645538500},
  title  = {{Considering WebAssembly Containers for Edge Computing on Hardware-Constrained IoT Devices}},
  url    = {www.bth.se},
  year   = {2020}
}

@inproceedings{1244493Jacobsson,
  title        = {Virtual machine execution for wearables based on webassembly},
  author       = {Jacobsson, Martin and W{\aa}hsl{\'e}n, Jonas},
  booktitle    = {EAI International Conference on Body Area Networks},
  pages        = {381--389},
  year         = {2018},
  organization = {Springer, Cham}
}

@techreport{FastlyWasm,
  title  = {Announcing Lucet: Fastly’s native WebAssembly compiler and runtime},
  year   = 2018,
  author = {Hickey, Pat},
  month  = mar,
  editor = {Hickey, Pat},
  url    = {https://www.fastly.com/blog/announcing-lucet-fastly-native-webassembly-compiler-runtime}
}

@techreport{CloudflareWasm,
  title  = {WebAssembly on Cloudflare Workers},
  year   = 2018,
  month  = jan,
  author = {Varda, Kenton},
  editor = {Varda, Kenton},
  url    = {https://blog.cloudflare.com/webassembly-on-cloudflare-workers/}
}

@phdthesis{Harrand1650630,
  author      = {Harrand, Nicolas},
  institution = {KTH, Software and Computer systems, SCS},
  note        = {QCR 20220413},
  pages       = {100},
  school      = {KTH, Software and Computer systems, SCS},
  title       = {Software Diversity for Third-Party Dependencies},
  series      = {TRITA-EECS-AVL},
  number      = {2022:22},
  keywords    = {Automated Software Engineering, Software Diversity, Software libraries, Software Monoculture},
  abstract    = {Thanks to the emergence of package managers and online software repositories, modern software development heavily relies on the reuse of third-party libraries. This practice has significant benefits in terms of productivity and reliability. Yet, the reuse of software libraries leads large groups of applications to share a significant amount of code, including potential defects such as bugs or vulnerabilities. The lack of diversity in these group of applications make them more prone to large-scale failures, and more predictable for attackers attempting to exploit their shared vulnerabilities.To mitigate these risks opened by library reuse, this dissertation proposes to introduce diversity in software applications.We create variants of software applications through transformations targeting the libraries they depend on. These variants provide functionalities equivalent to their original, while not sharing the exact same behavior. In this dissertation, we cover three aspects of software diversity.First, we study the existing behavioral diversity of alternative libraries implementing similar functionalities.We perform two case studies on two families of reusable software artifacts: JSON libraries and Bytecode decompilers. We provide empirical evidence that both groups of artifacts exhibit significant natural input/output behavioral diversity. Second, we study software transformations targeting libraries themselves. We propose six source-to-source transformations targeting software libraries, as well as a general architecture to implement library substitution. We implement this architecture in a JSON library substitution framework, leveraging the diversity of behavior we observe in JSON libraries. We assess the impact of these transformations on open-source libraries and software applications through two experiments. Finally, we study the properties of software applications and libraries that make them prone to transformation without changing their functionalities. We analyze the variants produced during our software diversification experiments and discuss our findings. In particular, we observe that the existence of alternative implementations at different granularity, instructions, methods, classes, and libraries, provides an important source of potential diversity that can be leveraged. },
  isbn        = {978-91-8040-184-5},
  year        = {2022}
}

@inproceedings{DeRoover2022,
  author    = {Sti\'{e}venart, Quentin and De Roover, Coen and Ghafari, Mohammad},
  title     = {Security Risks of Porting C Programs to Webassembly},
  year      = {2022},
  isbn      = {9781450387132},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3477314.3507308},
  doi       = {10.1145/3477314.3507308},
  abstract  = {WebAssembly is a compilation target for cross-platform applications that is increasingly being used. In this paper, we investigate whether one can transparently cross-compile C programs to WebAssembly, and if not, what impact porting can have on their security. We compile 17 802 programs that exhibit common vulnerabilities to 64-bit x86 and to WebAssembly binaries, and we observe that the execution of 4 911 binaries produces different results across these platforms. Through manual inspection, we identify three classes of root causes for such differences: the use of a different standard library implementation, the lack of security measures in WebAssembly, and the different semantics of the execution environments. We describe our observations and discuss the ones that are critical from a security point of view and need most attention from developers. We conclude that compiling an existing C program to WebAssembly for cross-platform distribution may require source code adaptations; otherwise, the security of the WebAssembly application may be at risk.},
  booktitle = {Proceedings of the 37th ACM/SIGAPP Symposium on Applied Computing},
  pages     = {1713–1722},
  numpages  = {10},
  keywords  = {WebAssembly, security, cross-compilation},
  location  = {Virtual Event},
  series    = {SAC '22}
}
@misc{zalewski2017american,
  title  = {American fuzzy lop},
  author = {Zalewski, Michal},
  year   = {2017}
}

@inproceedings{10.1145/2872362.2872387,
  author    = {Phothilimthana, Phitchaya Mangpo and Thakur, Aditya and Bodik, Rastislav and Dhurjati, Dinakar},
  title     = {Scaling up Superoptimization},
  year      = {2016},
  isbn      = {9781450340915},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2872362.2872387},
  doi       = {10.1145/2872362.2872387},
  abstract  = {Developing a code optimizer is challenging, especially for new, idiosyncratic ISAs. Superoptimization can, in principle, discover machine-specific optimizations automatically by searching the space of all instruction sequences. If we can increase the size of code fragments a superoptimizer can optimize, we will be able to discover more optimizations. We develop LENS, a search algorithm that increases the size of code a superoptimizer can synthesize by rapidly pruning away invalid candidate programs. Pruning is achieved by selectively refining the abstraction under which candidates are considered equivalent, only in the promising part of the candidate space. LENS also uses a bidirectional search strategy to prune the candidate space from both forward and backward directions. These pruning strategies allow LENS to solve twice as many benchmarks as existing enumerative search algorithms, while LENS is about 11-times faster.Additionally, we increase the effective size of the superoptimized fragments by relaxing the correctness condition using contexts (surrounding code). Finally, we combine LENS with complementary search techniques into a cooperative superoptimizer, which exploits the stochastic search to make random jumps in a large candidate space, and a symbolic (SAT-solver-based) search to synthesize arbitrary constants. While existing superoptimizers consistently solve 9--16 out of 32 benchmarks, the cooperative superoptimizer solves 29 benchmarks. It can synthesize code fragments that are up to 82% faster than code generated by gcc -O3 from WiBench and MiBench.},
  booktitle = {Proceedings of the Twenty-First International Conference on Architectural Support for Programming Languages and Operating Systems},
  pages     = {297–310},
  numpages  = {14},
  keywords  = {program synthesis, SMT, superoptimization},
  location  = {Atlanta, Georgia, USA},
  series    = {ASPLOS '16}
}

@article{10.1145/2954679.2872387,
  author     = {Phothilimthana, Phitchaya Mangpo and Thakur, Aditya and Bodik, Rastislav and Dhurjati, Dinakar},
  title      = {Scaling up Superoptimization},
  year       = {2016},
  issue_date = {April 2016},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {51},
  number     = {4},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/2954679.2872387},
  doi        = {10.1145/2954679.2872387},
  abstract   = {Developing a code optimizer is challenging, especially for new, idiosyncratic ISAs. Superoptimization can, in principle, discover machine-specific optimizations automatically by searching the space of all instruction sequences. If we can increase the size of code fragments a superoptimizer can optimize, we will be able to discover more optimizations. We develop LENS, a search algorithm that increases the size of code a superoptimizer can synthesize by rapidly pruning away invalid candidate programs. Pruning is achieved by selectively refining the abstraction under which candidates are considered equivalent, only in the promising part of the candidate space. LENS also uses a bidirectional search strategy to prune the candidate space from both forward and backward directions. These pruning strategies allow LENS to solve twice as many benchmarks as existing enumerative search algorithms, while LENS is about 11-times faster.Additionally, we increase the effective size of the superoptimized fragments by relaxing the correctness condition using contexts (surrounding code). Finally, we combine LENS with complementary search techniques into a cooperative superoptimizer, which exploits the stochastic search to make random jumps in a large candidate space, and a symbolic (SAT-solver-based) search to synthesize arbitrary constants. While existing superoptimizers consistently solve 9--16 out of 32 benchmarks, the cooperative superoptimizer solves 29 benchmarks. It can synthesize code fragments that are up to 82% faster than code generated by gcc -O3 from WiBench and MiBench.},
  journal    = {SIGPLAN Not.},
  month      = {mar},
  pages      = {297–310},
  numpages   = {14},
  keywords   = {superoptimization, program synthesis, SMT}
}

@article{SuperoptimizationScaling,
  author     = {Phothilimthana, Phitchaya Mangpo and Thakur, Aditya and Bodik, Rastislav and Dhurjati, Dinakar},
  title      = {Scaling up Superoptimization},
  year       = {2016},
  issue_date = {May 2016},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {44},
  number     = {2},
  issn       = {0163-5964},
  url        = {https://doi.org/10.1145/2980024.2872387},
  doi        = {10.1145/2980024.2872387},
  abstract   = {Developing a code optimizer is challenging, especially for new, idiosyncratic ISAs. Superoptimization can, in principle, discover machine-specific optimizations automatically by searching the space of all instruction sequences. If we can increase the size of code fragments a superoptimizer can optimize, we will be able to discover more optimizations. We develop LENS, a search algorithm that increases the size of code a superoptimizer can synthesize by rapidly pruning away invalid candidate programs. Pruning is achieved by selectively refining the abstraction under which candidates are considered equivalent, only in the promising part of the candidate space. LENS also uses a bidirectional search strategy to prune the candidate space from both forward and backward directions. These pruning strategies allow LENS to solve twice as many benchmarks as existing enumerative search algorithms, while LENS is about 11-times faster.Additionally, we increase the effective size of the superoptimized fragments by relaxing the correctness condition using contexts (surrounding code). Finally, we combine LENS with complementary search techniques into a cooperative superoptimizer, which exploits the stochastic search to make random jumps in a large candidate space, and a symbolic (SAT-solver-based) search to synthesize arbitrary constants. While existing superoptimizers consistently solve 9--16 out of 32 benchmarks, the cooperative superoptimizer solves 29 benchmarks. It can synthesize code fragments that are up to 82% faster than code generated by gcc -O3 from WiBench and MiBench.},
  journal    = {SIGARCH Comput. Archit. News},
  month      = {mar},
  pages      = {297–310},
  numpages   = {14},
  keywords   = {program synthesis, superoptimization, SMT}
}


@inproceedings{10.1145/3507657.3528560,
  author    = {Bhansali, Shrenik and Aris, Ahmet and Acar, Abbas and Oz, Harun and Uluagac, A. Selcuk},
  title     = {A First Look at Code Obfuscation for WebAssembly},
  year      = {2022},
  isbn      = {9781450392167},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3507657.3528560},
  doi       = {10.1145/3507657.3528560},
  abstract  = {WebAssembly (Wasm) has seen a lot of attention lately as it spreads through the mobile computing domain and becomes the new standard for performance-oriented web development. It has diversified its uses far beyond just web applications by acting as an execution environment for mobile agents, containers for IoT devices, and enabling new serverless approaches for edge computing. Within the numerous uses of Wasm, not all of them are benign. With the rise of Wasm-based cryptojacking malware, analyzing Wasm applications has been a hot topic in the literature, resulting in numerous Wasm-based cryptojacking detection systems. Many of these methods rely on static analysis, which traditionally can be circumvented through obfuscation. However, the feasibility of the obfuscation techniques for Wasm programs has never been investigated thoroughly. In this paper, we address this gap and perform the first look at code obfuscation for Wasm. We apply numerous obfuscation techniques to Wasm programs, and test their effectiveness in producing a fully obfuscated Wasm program. Particularly, we obfuscate both benign Wasm-based web applications and cryptojacking malware instances and feed them into a state-of-the-art Wasm cryptojacking detector to see if current Wasm analysis methods can be subverted with obfuscation. Our analysis shows that obfuscation can be highly effective and can cause even a state-of-the-art detector to misclassify the obfuscated Wasm samples.},
  booktitle = {Proceedings of the 15th ACM Conference on Security and Privacy in Wireless and Mobile Networks},
  pages     = {140–145},
  numpages  = {6},
  keywords  = {webassembly, wasm, obfuscation, cryptojacking},
  location  = {San Antonio, TX, USA},
  series    = {WiSec '22}
}


@article{10.1145/1190215.1190252,
  author     = {Yu, Dachuan and Chander, Ajay and Islam, Nayeem and Serikov, Igor},
  title      = {JavaScript Instrumentation for Browser Security},
  year       = {2007},
  issue_date = {January 2007},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {42},
  number     = {1},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/1190215.1190252},
  doi        = {10.1145/1190215.1190252},
  abstract   = {It is well recognized that JavaScript can be exploited to launch browser-based security attacks. We propose to battle such attacks using program instrumentation. Untrusted JavaScript code goes through a rewriting process which identifies relevant operations, modifies questionable behaviors, and prompts the user (a web page viewer) for decisions on how to proceed when appropriate. Our solution is parametric with respect to the security policy-the policy is implemented separately from the rewriting, and the same rewriting process is carried out regardless of which policy is in use. Be-sides providing a rigorous account of the correctness of our solution, we also discuss practical issues including policy management and prototype experiments. A useful by-product of our work is an operational semantics of a core subset of JavaScript, where code embedded in (HTML) documents may generate further document pieces (with new code embedded) at runtime, yielding a form of self-modifying code.},
  journal    = {SIGPLAN Not.},
  month      = {jan},
  pages      = {237–249},
  numpages   = {13},
  keywords   = {edit automata, program instrumentation, web browser, JavaScript}
}

@inproceedings{10.1145/1190216.1190252,
  author    = {Yu, Dachuan and Chander, Ajay and Islam, Nayeem and Serikov, Igor},
  title     = {JavaScript Instrumentation for Browser Security},
  year      = {2007},
  isbn      = {1595935754},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1190216.1190252},
  doi       = {10.1145/1190216.1190252},
  abstract  = {It is well recognized that JavaScript can be exploited to launch browser-based security attacks. We propose to battle such attacks using program instrumentation. Untrusted JavaScript code goes through a rewriting process which identifies relevant operations, modifies questionable behaviors, and prompts the user (a web page viewer) for decisions on how to proceed when appropriate. Our solution is parametric with respect to the security policy-the policy is implemented separately from the rewriting, and the same rewriting process is carried out regardless of which policy is in use. Be-sides providing a rigorous account of the correctness of our solution, we also discuss practical issues including policy management and prototype experiments. A useful by-product of our work is an operational semantics of a core subset of JavaScript, where code embedded in (HTML) documents may generate further document pieces (with new code embedded) at runtime, yielding a form of self-modifying code.},
  booktitle = {Proceedings of the 34th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages     = {237–249},
  numpages  = {13},
  keywords  = {web browser, program instrumentation, edit automata, JavaScript},
  location  = {Nice, France},
  series    = {POPL '07}
}



@article{maliciousJS,
  author   = {Y. {Fang} and C. {Huang} and L. {Liu} and M. {Xue}},
  journal  = {IEEE Access},
  title    = {Research on Malicious JavaScript Detection Technology Based on LSTM},
  year     = {2018},
  volume   = {6},
  number   = {},
  pages    = {59118-59125},
  keywords = {Malware;Feature extraction;Browsers;Engines;Web pages;Semantics;Bills of materials;JavaScript;malicious code detection;bytecode;word vector;LSTM},
  doi      = {10.1109/ACCESS.2018.2874098},
  issn     = {2169-3536},
  month    = {}
}

@inproceedings{mulazzani2013fast,
  title        = {Fast and reliable browser identification with javascript engine fingerprinting},
  author       = {Mulazzani, Martin and Reschl, Philipp and Huber, Markus and Leithner, Manuel and Schrittwieser, Sebastian and Weippl, Edgar and Wien, FC},
  booktitle    = {Web 2.0 Workshop on Security and Privacy (W2SP)},
  volume       = {5},
  pages        = {4},
  year         = {2013},
  organization = {Citeseer}
}

@inproceedings{10.1145/3412841.3442001,
  author    = {Ko, Yoonseok and Rezk, Tamara and Serrano, Manuel},
  title     = {SecureJS Compiler: Portable Memory Isolation in JavaScript},
  year      = {2021},
  isbn      = {9781450381048},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3412841.3442001},
  doi       = {10.1145/3412841.3442001},
  abstract  = {The memory isolation mechanism plays an essential role to provide security enforcement in JavaScript programs. Existing secure interaction libraries such as Google Caja, SES, and VM2 rely on built-in memory isolation mechanisms provided by Node.js and browsers, yet most of the other engines such as JerryScript and Duktape, which are implementations for IoT devices, do not support such isolation mechanisms.In this paper, we report about the design and implementation of SecureJS, a portable JavaScript-to-JavaScript compiler that enforces memory isolation. As it only uses standard features, the compiled code it generates can be used by any JavaScript engine. We validated empirically the semantics preservation and memory isolation of SecureJS compiled programs by using 10,490 test programs of ECMAScript Test262 test suite. We also developed a novel experiment to evaluate memory isolation property of compiled code by instrumented JavaScript engines.},
  booktitle = {Proceedings of the 36th Annual ACM Symposium on Applied Computing},
  pages     = {1265–1274},
  numpages  = {10},
  keywords  = {compiler, JavaScript, memory isolation},
  location  = {Virtual Event, Republic of Korea},
  series    = {SAC '21}
}

@inproceedings{10.1145/3184558.3188736,
  author    = {Peguero, Ksenia and Zhang, Nan and Cheng, Xiuzhen},
  title     = {An Empirical Study of the Framework Impact on the Security of JavaScript Web Applications},
  year      = {2018},
  isbn      = {9781450356404},
  publisher = {International World Wide Web Conferences Steering Committee},
  address   = {Republic and Canton of Geneva, CHE},
  url       = {https://doi.org/10.1145/3184558.3188736},
  doi       = {10.1145/3184558.3188736},
  abstract  = {textitBackground: JavaScript frameworks are widely used to create client-side and server-side parts of contemporary web applications. Vulnerabilities like cross-site scripting introduce significant risks in web applications. textitAim: The goal of our study is to understand how the security features of a framework impact the security of the applications written using that framework. textitMethod: In this paper, we present four locations in an application, relative to the framework being used, where a mitigation can be applied. We perform an empirical study of JavaScript applications that use the three most common template engines: Jade/Pug, EJS, and Angular. Using automated and manual analysis of each group of applications, we identify the number of projects vulnerable to cross-site scripting, and the number of vulnerabilities in each project, based on the framework used. textitResults: We analyze the results to compare the number of vulnerable projects to the mitigation locations used in each framework and perform statistical analysis of confounding variables. textitConclusions: The location of the mitigation impacts the application's security posture, with mitigations placed within the framework resulting in more secure applications.},
  booktitle = {Companion Proceedings of the The Web Conference 2018},
  pages     = {753–758},
  numpages  = {6},
  keywords  = {framework analysis, template engines, web frameworks, web security, cross-site scripting, javascript security},
  location  = {Lyon, France},
  series    = {WWW '18}
}
@inproceedings{grosskurth2005reference,
  title        = {A reference architecture for web browsers},
  author       = {Grosskurth, Alan and Godfrey, Michael W},
  booktitle    = {21st IEEE International Conference on Software Maintenance (ICSM'05)},
  pages        = {661--664},
  year         = {2005},
  organization = {IEEE}
}

@article{GARCES2021111004,
  title    = {Three decades of software reference architectures: A systematic mapping study},
  journal  = {Journal of Systems and Software},
  volume   = {179},
  pages    = {111004},
  year     = {2021},
  issn     = {0164-1212},
  doi      = {https://doi.org/10.1016/j.jss.2021.111004},
  url      = {https://www.sciencedirect.com/science/article/pii/S0164121221001011},
  author   = {Lina Garcés and Silverio Martínez-Fernández and Lucas Oliveira and Pedro Valle and Claudia Ayala and Xavier Franch and Elisa Yumi Nakagawa},
  keywords = {Software architecture, Reference architecture, Systematic mapping, Secondary study},
  abstract = {Software reference architectures have played an essential role in software systems development due to the possibility of knowledge reuse. Although increasingly adopted by industry, these architectures are not yet completely understood. This work presents a panorama on existing software reference architectures, characterizing them according to their context, goals, perspectives, application domains, design approaches, and maturity, as well as the industry involvement for their construction. For this, we planned and conducted a systematic mapping study. During last decade, the number of reference architectures in very diverse application domains has increased, resulting from efforts of industry, academia, and through their collaborations. Academic reference architectures are oriented to facilitate the reuse of architectural and domain knowledge. The industry has focused on architectures for standardization with certain maturity level. However, the great amount of architectures studied in this work have been designed without following a systematic process, and they lack the maturity to be used in real software projects. Further investigations can be oriented to gathering empirical evidences, from different sources than academic data libraries, that allow to understand how references architectures have been constructed, utilized, and maintained during the whole software life-cycle.}
}

@article{goth2003addressing,
  title={Addressing the monoculture},
  author={Goth, Greg},
  journal={IEEE Security \& Privacy},
  volume={1},
  number={06},
  pages={8--10},
  year={2003},
  publisher={IEEE Computer Society}
}

@article{lala2009monoculture,
  title={It monoculture security risks and defenses},
  author={Lala, Jaynarayan H and Schneider, Fred B},
  journal={IEEE Security \& Privacy},
  volume={7},
  number={1},
  pages={12--13},
  year={2009},
  publisher={IEEE}
}



@misc{BREAKFastly,
    title= {{Global CDN Disruption}},
    howpublished = {\url{https://www.fastly.com/blog/summary-of-june-8-outage}},
    urldate = {2021-08-08},
    year={2021}
}


@misc{leftPad,
    title= {{How one programmer broke the internet by deleting a tiny piece of code}},
    howpublished = {\url{https://qz.com/646467/how-one-programmer-broke-the-internet-by-deleting-a-tiny-piece-of-code/}},
    urldate = {2022-05-20},
    year={2016}
}


@inproceedings{WARDuino2019,
 author = {Gurdeep Singh, Robbert and Scholliers, Christophe},
 title = {WARDuino: A Dynamic WebAssembly Virtual Machine for Programming Microcontrollers},
 booktitle = {Proceedings of the 16th ACM SIGPLAN International Conference on Managed Programming Languages and Runtimes},
 series = {MPLR 2019},
 year = {2019},
 isbn = {978-1-4503-6977-0},
 location = {Athens, Greece},
 pages = {27--36},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/3357390.3361029},
 doi = {10.1145/3357390.3361029},
 acmid = {3361029},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Arduino, Live Code Updates, Virtual Machine, WebAssembly},
}