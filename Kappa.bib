@inbook{Runeson2020,
  author    = {Runeson, Per
               and Engstr{\"o}m, Emelie
               and Storey, Margaret-Anne},
  editor    = {Felderer, Michael
               and Travassos, Guilherme Horta},
  title     = {The Design Science Paradigm as a Frame for Empirical Software Engineering},
  booktitle = {Contemporary Empirical Methods in Software Engineering},
  year      = {2020},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {127--147},
  abstract  = {Software engineering research aims to help improve real-world practice. With the adoption of empirical software engineering research methods, the understanding of real-world needs and validation of solution proposals have evolved. However, the philosophical perspective on what constitutes theoretical knowledge and research contributions in software engineering is less discussed in the community. In this chapter, we use the design science paradigm as a frame for articulating and communicating prescriptive software engineering research contributions. Design science embraces problem conceptualization, solution (or artifact) design, and validation of solution proposals, with recommendations for practice phrased as technological rules. Design science is used in related research areas, particularly information systems and management theory. We elaborate the constructs of design science for software engineering, relate them to different conceptualizations of design science, and provide examples of possible research methods. We outline how the assessment of research contributions, industry--academia communication, and theoretical knowledge building may be supported by the design science paradigm. Finally, we provide examples of software engineering research presented through a design science lens.},
  isbn      = {978-3-030-32489-6},
  doi       = {10.1007/978-3-030-32489-6_5},
  url       = {https://doi.org/10.1007/978-3-030-32489-6_5}
}

@article{Hilbig2021AnES,
  title   = {An Empirical Study of Real-World WebAssembly Binaries: Security, Languages, Use Cases},
  author  = {Aaron Hilbig and Daniel Lehmann and Michael Pradel},
  journal = {Proceedings of the Web Conference 2021},
  year    = {2021}
}


@inproceedings{moduloinputpaper,
  author    = {Le, Vu and Afshari, Mehrdad and Su, Zhendong},
  title     = {Compiler Validation via Equivalence modulo Inputs},
  year      = {2014},
  booktitle = {Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  pages     = {216–226},
  numpages  = {11},
  keywords  = {equivalent program variants, automated testing, miscompilation, compiler testing},
  location  = {Edinburgh, United Kingdom},
  series    = {PLDI ’14}
}
@article{Li2018,
  abstract  = {Security vulnerability is one of the root causes of cyber-security threats. To discover vulnerabilities and fix them in advance, researchers have proposed several techniques, among which fuzzing is the most widely used one. In recent years, fuzzing solutions, like AFL, have made great improvements in vulnerability discovery. This paper presents a summary of the recent advances, analyzes how they improve the fuzzing process, and sheds light on future work in fuzzing. Firstly, we discuss the reason why fuzzing is popular, by comparing different commonly used vulnerability discovery techniques. Then we present an overview of fuzzing solutions, and discuss in detail one of the most popular type of fuzzing, i.e., coverage-based fuzzing. Then we present other techniques that could make fuzzing process smarter and more efficient. Finally, we show some applications of fuzzing, and discuss new trends of fuzzing and potential future directions.},
  author    = {Li, Jun and Zhao, Bodong and Zhang, Chao},
  doi       = {10.1186/S42400-018-0002-Y/TABLES/5},
  file      = {:Users/javierca/Library/Application Support/Mendeley Desktop/Downloaded/Li, Zhao, Zhang - 2018 - Fuzzing a survey.pdf:pdf},
  issn      = {25233246},
  journal   = {Cybersecurity},
  keywords  = {Coverage-based fuzzing,Fuzzing,Software security,Vulnerability discovery},
  month     = {dec},
  number    = {1},
  pages     = {1--13},
  publisher = {Springer Science and Business Media B.V.},
  title     = {{Fuzzing: a survey}},
  url       = {https://cybersecurity.springeropen.com/articles/10.1186/s42400-018-0002-y},
  volume    = {1},
  year      = {2018}
}

@article{mann1947,
  author    = {Mann, H. B. and Whitney, D. R.},
  doi       = {10.1214/aoms/1177730491},
  fjournal  = {Annals of Mathematical Statistics},
  journal   = {Ann. Math. Statist.},
  month     = {03},
  number    = {1},
  pages     = {50--60},
  publisher = {The Institute of Mathematical Statistics},
  title     = {On a Test of Whether one of Two Random Variables is Stochastically Larger than the Other},
  volume    = {18},
  year      = {1947}
}


@inproceedings{Maia08usinga,
  author    = {Marcelo De A. Maia and Victor Sobreira and Klérisson R. Paixão and Ra A. De Amo and Ilmério R. Silva},
  title     = {Using a sequence alignment algorithm to identify specific and common code from execution traces},
  booktitle = {Proceedings of the 4th International Workshop on Program Comprehension through Dynamic Analysis (PCODA},
  year      = {2008},
  pages     = {6--10}
}


@inproceedings{davi2015isomeron,
  title     = {Isomeron: Code Randomization Resilient to (Just-In-Time) Return-Oriented Programming},
  author    = {Davi, Lucas and Liebchen, Christopher and Sadeghi, Ahmad-Reza and Snow, Kevin Z and Monrose, Fabian},
  booktitle = {NDSS},
  year      = {2015}
}

@article{gnanadesikan1968probability,
  title   = {Probability plotting methods for the analysis of data},
  author  = {Gnanadesikan, Ramanathan and Wilk, Martin B},
  journal = {Biometrika},
  volume  = {55},
  number  = {1},
  pages   = {1--17},
  year    = {1968}
}

@article{2021arXiv210808125C,
  author        = {{Cabrera Arteaga}, Javier and {Laperdrix}, Pierre and {Monperrus}, Martin and {Baudry}, Benoit},
  title         = {{Multi-Variant Execution at the Edge}},
  journal       = {arXiv e-prints},
  keywords      = {Computer Science - Software Engineering},
  year          = 2021,
  month         = aug,
  eid           = {arXiv:2108.08125},
  pages         = {arXiv:2108.08125},
  archiveprefix = {arXiv},
  eprint        = {2108.08125},
  primaryclass  = {cs.SE},
  adsurl        = {https://ui.adsabs.harvard.edu/abs/2021arXiv210808125C},
  adsnote       = {Provided by the SAO/NASA Astrophysics Data System}
}

@article{Haas_2017,
  title    = {Bringing the web up to speed with WebAssembly},
  year     = {2017},
  author   = {Andreas Haas and Andreas Rossberg and Derek L. Schuff and Derek L. Schuff and Ben L. Titzer and Michael Holman and Dan Gohman and Luke Wagner and Alon Zakai and J. F. Bastien},
  doi      = {10.1145/3062341.3062363},
  pmid     = {null},
  pmcid    = {null},
  mag_id   = {2625141509},
  journal  = {PLDI},
  abstract = {The maturation of the Web platform has given rise to sophisticated and demanding Web applications such as interactive 3D visualization, audio and video software, and games. With that, efficiency and security of code on the Web has become more important than ever. Yet JavaScript as the only built-in language of the Web is not well-equipped to meet these requirements, especially as a compilation target.     Engineers from the four major browser vendors have risen to the challenge and collaboratively designed a portable low-level bytecode called WebAssembly. It offers compact representation, efficient validation and compilation, and safe low to no-overhead execution. Rather than committing to a specific programming model, WebAssembly is an abstraction over modern hardware, making it language-, hardware-, and platform-independent, with use cases beyond just the Web. WebAssembly has been designed with a formal semantics from the start. We describe the motivation, design and formal semantics of WebAssembly and provide some preliminary experience with implementations.}
}

@misc{Cheerps2018,
  title        = {{Cheerp - C++ for the Web}},
  year         = {2018},
  author       = {{Cheerp}},
  howpublished          = {\url{https://www.leaningtech.com/cheerp/}},
  lastaccessed = {2019-11-12}
}


@misc{asmjs,
  title        = {{asm.js Speedups Everywhere}},
  year         = {2015},
  author       = {{Alon Zakai}},
  howpublished          = {\url{https://hacks.mozilla.org/2015/03/asm-speedups-everywhere/}},
  lastaccessed = {2022-13-04}
}

@misc{wasm_spec,
  title        = {{WebAssembly Specification}},
  year         = {2017},
  author       = {{WebAssembly Community Group}},
  howpublished          = {\url{https://webassembly.github.io/spec/core/syntax/index.html}},
  lastaccessed = {2022-13-04}
}


@misc{wasm_roadmap,
  title        = {{WebAssembly Roadmap}},
  year         = {2017},
  author       = {{WebAssembly Community Group}},
  howpublished          = {\url{https://webassembly.org/roadmap/}},
  lastaccessed = {2022-13-04}
}

@misc{javaapplet,
  title        = {{JDK 9 Release Notes. Deprecation of Java Applets}},
  year         = {{2017}},
  author       = {{Oracle}},
  howpublished          = {\url{{https://www.oracle.com/java/technologies/javase/9-deprecated-features.html}}},
  lastaccessed = {2022-16-05}
}

@misc{activex,
  title        = {{Microsoft Announces ActiveX Technologies}},
  howpublished          = {\url{{https://web.archive.org/web/20090828024117/http://www.microsoft.com/presspass/press/1996/mar96/activxpr.mspx}}},
  author       = {{Microsoft}},
  year         = {{1996}},
  lastaccessed = {2022-16-05}
}


@misc{llvmofficialweb,
  title        = {{ The LLVM Compiler Infrastructure }},
  howpublished          = {\url{{https://llvm.org/}}},
  author       = {{LLVM}},
  year         = {{2003}},
  lastaccessed = {2022-16-05}
}

@misc{silverlight,
  title        = {{Silverlight}},
  year         = {{2007}},
  author       = {{Microsoft}},
  howpublished  = {\url{{https://www.microsoft.com/silverlight/}}},
  lastaccessed = {2022-16-05}
}

@misc{emscripten,
  howpublished          ={\url {{https://emscripten.org/}}},
  year         = {{2014}},
  title        = {{Emscripten}},
  author       = {{Zakai and colleagues}},
  lastaccessed = {2022-16-05}
}


@misc{asmjsweb,
  howpublished          = {\url{{http://asmjs.org/spec/latest/}}},
  year         = {{2014}},
  title        = {{asm.js}},
  author       = {{Zakai and colleagues}},
  lastaccessed = {2022-16-05}
}

@misc{nexus,
  howpublished          = {\url{{https://www.w3.org/People/Berners-Lee/WorldWideWeb.html}}},
  year         = {{1990}},
  title        = {{The WorldWideWeb browser}},
  author       = {{Tim Berners-Lee}},
  lastaccessed = {2022-16-05}
}

@misc{bytecodealliance,
  howpublished          = {\url{{https://bytecodealliance.org/}}},
  year         = {{2019}},
  title        = {{Bytecode Alliance}},
  author       = {{Bytecode Alliance }},
  lastaccessed = {2022-16-05}
}


@inproceedings{bryant2020webassembly,
  title     = {Webassembly outside the browser: A new foundation for pervasive computing},
  author    = {Bryant, David},
  booktitle = {Proc. of ICWE 2020},
  pages     = {9--12},
  year      = {2020}
}


@inproceedings{Narayan2021Swivel,
  title     = {Swivel: Hardening WebAssembly against Spectre},
  author    = {Narayan, Shravan and Disselkoen, Craig and Moghimi, Daniel and Cauligi, Sunjay and Johnson, Evan and Gang, Zhao and Vahldiek-Oberwagner, Anjo and Sahita, Ravi and Shacham, Hovav and Tullsen, Dean and others},
  booktitle = {USENIX Security Symposium },
  year      = {2021}
}


% Diversification papers
@article{cohen1993operating,
  title   = {Operating system protection through program evolution.},
  author  = {Cohen, Frederick B},
  journal = {Computers \& Security},
  volume  = {12},
  number  = {6},
  pages   = {565--584},
  year    = {1993}
}

@incollection{jackson2011compiler,
  title     = {Compiler-generated software diversity},
  author    = {Jackson, Todd and Salamat, Babak and Homescu, Andrei and Manivannan, Karthikeyan and Wagner, Gregor and Gal, Andreas and Brunthaler, Stefan and Wimmer, Christian and Franz, Michael},
  booktitle = {Moving Target Defense},
  pages     = {77--98},
  year      = {2011},
  publisher = {Springer}
}

@article{Genkin2018DrivebyKC,
  title   = {Drive-by Key-Extraction Cache Attacks from Portable Code},
  author  = {Daniel Genkin and Lev Pachmanov and Eran Tromer and Yuval Yarom},
  journal = {IACR Cryptol. ePrint Arch.},
  year    = {2018},
  volume  = {2018},
  pages   = {119}
}


@inproceedings{homescu2013profile,
  title        = {Profile-guided automated software diversity},
  author       = {Homescu, Andrei and Neisius, Steven and Larsen, Per and Brunthaler, Stefan and Franz, Michael},
  booktitle    = {Proceedings of the 2013 IEEE/ACM International Symposium on Code Generation and Optimization (CGO)},
  pages        = {1--11},
  year         = {2013},
  organization = {IEEE}
}

@article{coppens2013feedback,
  title     = {Feedback-driven binary code diversification},
  author    = {Coppens, Bart and De Sutter, Bjorn and Maebe, Jonas},
  journal   = {ACM Transactions on Architecture and Code Optimization (TACO)},
  volume    = {9},
  number    = {4},
  pages     = {1--26},
  year      = {2013},
  publisher = {ACM New York, NY, USA}
}

% Superoptimization

@article{bunel_learning_2017,
  author        = {{Bunel}, Rudy and {Desmaison}, Alban and {Pawan Kumar}, M. and
                   {Torr}, Philip H.S. and {Kohli}, Pushmeet},
  title         = {{Learning to superoptimize programs}},
  journal       = {arXiv e-prints},
  keywords      = {Computer Science - Machine Learning},
  year          = 2016,
  month         = nov,
  number        = 1,
  volume        = 1,
  numpages      = {10},
  eid           = {arXiv:1611.01787},
  pages         = {arXiv:1611.01787},
  archiveprefix = {arXiv},
  eprint        = {1611.01787},
  primaryclass  = {cs.LG},
  adsurl        = {https://ui.adsabs.harvard.edu/abs/2016arXiv161101787B},
  adsnote       = {Provided by the SAO/NASA Astrophysics Data System}
}


@article{Massalin1987,
  title     = {{Superoptimizer: a look at the smallest program}},
  year      = {1987},
  journal   = {ACM SIGARCH Computer Architecture News},
  author    = {Massalin Henry},
  number    = {5},
  month     = {Nov},
  pages     = {122--126},
  volume    = {15},
  publisher = {ACM},
  url       = {http://portal.acm.org/citation.cfm?doid=36177.36194},
  isbn      = {0-8186-0805-6},
  doi       = {10.1145/36177.36194},
  issn      = {01635964}
}


@article{churchill_sound_nodate,
  author     = {Churchill, Berkeley and Sharma, Rahul and Bastien, JF and Aiken, Alex},
  title      = {Sound Loop Superoptimization for Google Native Client},
  year       = {2017},
  issue_date = {May 2017},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {52},
  number     = {4},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/3093336.3037754},
  doi        = {10.1145/3093336.3037754},
  journal    = {SIGPLAN Not.},
  pages      = {313–326},
  numpages   = {14},
  keywords   = {verification, bounded verification, superoptimization, assembly, x86-64, equivalence checking, data-driven verification, native client}
}


% Superdiversifier
@inproceedings{jacob2008superdiversifier,
  title        = {The superdiversifier: Peephole individualization for software protection},
  author       = {Jacob, Matthias and Jakubowski, Mariusz H and Naldurg, Prasad and Saw, Chit Wei Nick and Venkatesan, Ramarathnam},
  booktitle    = {International Workshop on Security},
  pages        = {100--120},
  year         = {2008},
  organization = {Springer}
}

@inproceedings{bansal_automatic_nodate,
  author    = {Bansal, Sorav and Aiken, Alex},
  title     = {Automatic Generation of Peephole Superoptimizers},
  year      = {2006},
  isbn      = {1595934510},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1168857.1168906},
  doi       = {10.1145/1168857.1168906},
  booktitle = {Proceedings of the 12th International Conference on Architectural Support for Programming Languages and Operating Systems},
  pages     = {394–403},
  numpages  = {10},
  keywords  = {peephole optimization, code selection, superoptimization},
  location  = {San Jose, California, USA},
  series    = {ASPLOS XII}
}


@inproceedings{Sledge,
  author    = {Gadepalli, Phani Kishore and McBride, Sean and Peach, Gregor and Cherkasova, Ludmila and Parmer, Gabriel},
  title     = {Sledge: A Serverless-First, Light-Weight Wasm Runtime for the Edge},
  year      = {2020},
  doi       = {10.1145/3423211.3425680},
  booktitle = {Proceedings of the 21st International Middleware Conference},
  pages     = {265–279}
}

@inproceedings{wen2020wasmachine,
  title        = {Wasmachine: Bring iot up to speed with a webassembly os},
  author       = {Wen, Elliott and Weber, Gerald},
  booktitle    = {2020 IEEE International Conference on Pervasive Computing and Communications Workshops (PerCom Workshops)},
  pages        = {1--4},
  year         = {2020},
  organization = {IEEE}
}


@misc{WebAssemblySecurity,
  title        = {{WebAssembly documentation: Security}},
  howpublished          = {\url{https://webassembly.org/docs/security/}},
  organization = {{W3C}},
  note         = {{Accessed: 18 June 2020}},
  author       = {Dominic Chen and {\relax W3C group}},
  year         = {2020}
}

@inproceedings{usenixWasm2020,
  title     = {Everything Old is New Again: Binary Security of WebAssembly},
  booktitle = {29th USENIX Security Symposium (USENIX Security 20)},
  year      = {2020},
  publisher = {USENIX Association},
  month     = aug,
  author    = {Lehmann, Daniel and Kinder, Johannes and Pradel, Michael}
}


@techreport{ChromeZero,
  title  = {The Problems and Promise of WebAssembly},
  year   = 2018,
  author = {Silvanovich, Natalie},
  month  = mar,
  editor = {Silvanovich, Natalie},
  url    = {https://googleprojectzero.blogspot.com/2018/08/the-problems-and-promise-of-webassembly.html}
}

@inbook{UnleashingCompilerRen,
  author    = {Ren, Xiaolei and Ho, Michael and Ming, Jiang and Lei, Yu and Li, Li},
  title     = {Unleashing the Hidden Power of Compiler Optimization on Binary Code Difference: An Empirical Study},
  year      = {2021},
  isbn      = {9781450383912},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3453483.3454035},
  abstract  = {Hunting binary code difference without source code (i.e., binary diffing) has compelling applications in software security. Due to the high variability of binary code, existing solutions have been driven towards measuring semantic similarities from syntactically different code. Since compiler optimization is the most common source contributing to binary code differences in syntax, testing the resilience against the changes caused by different compiler optimization settings has become a standard evaluation step for most binary diffing approaches. For example, 47 top-venue papers in the last 12 years compared different program versions compiled by default optimization levels (e.g., -Ox in GCC and LLVM). Although many of them claim they are immune to compiler transformations, it is yet unclear about their resistance to non-default optimization settings. Especially, we have observed that adversaries explored non-default compiler settings to amplify malware differences.  This paper takes the first step to systematically studying the effectiveness of compiler optimization on binary code differences. We tailor search-based iterative compilation for the auto-tuning of binary code differences. We develop BinTuner to search near-optimal optimization sequences that can maximize the amount of binary code differences. We run BinTuner with GCC 10.2 and LLVM 11.0 on SPEC benchmarks (CPU2006 &amp; CPU2017), Coreutils, and OpenSSL. Our experiments show that at the cost of 279 to 1,881 compilation iterations, BinTuner can find custom optimization sequences that are substantially better than the general -Ox settings. BinTuner's outputs seriously undermine prominent binary diffing tools' comparisons. In addition, the detection rate of the IoT malware variants tuned by BinTuner falls by more than 50%. Our findings paint a cautionary tale for security analysts that attackers have a new way to mutate malware code cost-effectively, and the research community needs to step back to reassess optimization-resistance evaluations.},
  booktitle = {Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
  pages     = {142–157},
  numpages  = {16}
}


@inproceedings{amarilli2011can,
  title        = {Can code polymorphism limit information leakage?},
  author       = {Amarilli, Antoine and M{\"u}ller, Sascha and Naccache, David and Page, Daniel and Rauzy, Pablo and Tunstall, Michael},
  booktitle    = {IFIP International Workshop on Information Security Theory and Practices},
  pages        = {1--21},
  year         = {2011},
  organization = {Springer}
}


@article{agosta2015meet,
  title     = {The {MEET} approach: Securing cryptographic embedded software against side channel attacks},
  author    = {Agosta, Giovanni and Barenghi, Alessandro and Pelosi, Gerardo and Scandale, Michele},
  journal   = {IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems},
  volume    = {34},
  number    = {8},
  pages     = {1320--1333},
  year      = {2015},
  publisher = {IEEE}
}


@inproceedings{crane2015thwarting,
  title     = {Thwarting Cache Side-Channel Attacks Through Dynamic Software Diversity.},
  author    = {Crane, Stephen and Homescu, Andrei and Brunthaler, Stefan and Larsen, Per and Franz, Michael},
  booktitle = {NDSS},
  pages     = {8--11},
  year      = {2015}
}


@inproceedings{courousse2016runtime,
  title        = {Runtime code polymorphism as a protection against side channel attacks},
  author       = {Courouss{\'e}, Damien and Barry, Thierno and Robisson, Bruno and Jaillon, Philippe and Potin, Olivier and Lanet, Jean-Louis},
  booktitle    = {IFIP International Conference on Information Security Theory and Practice},
  pages        = {136--152},
  year         = {2016},
  organization = {Springer}
}


@inproceedings{bruschi2007diversified,
  title     = {Diversified process replic{\ae} for defeating memory error exploits},
  author    = {Bruschi, Danilo and Cavallaro, Lorenzo and Lanzi, Andrea},
  booktitle = {Proc. of the Int. Performance, Computing, and Communications Conference},
  year      = {2007}
}


@inproceedings{cox06,
  title     = {N-variant systems: a secretless framework for security through diversity},
  author    = {Cox, Benjamin and Evans, David and Filipi, Adrian and Rowanhill, Jonathan and Hu, Wei and Davidson, Jack and Knight, John and Nguyen-Tuong, Anh and Hiser, Jason},
  booktitle = {Proc. of USENIX Security Symposium},
  year      = {2006},
  series    = {USENIX-SS'06},
  location  = {Vancouver, B.C., Canada},
  url       = {http://dl.acm.org/citation.cfm?id=1267336.1267344}
}


@techreport{salamat2007stopping,
  title       = {Stopping Buffer Overflow Attacks at Run-Time: Simultaneous Multi-Variant Program Execution on a Multicore Processor},
  author      = {Salamat, Babak and Gal, Andreas and Jackson, Todd and Manivannan, Karthik and Wagner, Gregor and Franz, Michael},
  year        = {2007},
  institution = {Technical Report 07-13, School of Information and Computer Sciences, UCIrvine}
}



@article{lu2018stopping,
  title     = {Stopping memory disclosures via diversification and replicated execution},
  author    = {Lu, Kangjie and Xu, Meng and Song, Chengyu and Kim, Taesoo and Lee, Wenke},
  journal   = {IEEE Transactions on Dependable and Secure Computing},
  year      = {2018},
  publisher = {IEEE}
}

@article{volckaert2015cloning,
  title   = {Cloning your gadgets: Complete ROP attack immunity with multi-variant execution},
  author  = {Volckaert, Stijn and Coppens, Bart and De Sutter, Bjorn},
  journal = {IEEE Transactions on Dependable and Secure Computing},
  volume  = {13},
  number  = {4},
  year    = {2015}
}


@article{SalamatJWWF11,
  author    = {Babak Salamat and
               Todd Jackson and
               Gregor Wagner and
               Christian Wimmer and
               Michael Franz},
  title     = {Runtime Defense against Code Injection Attacks Using Replicated Execution},
  journal   = {{IEEE} Trans. Dependable Secur. Comput.},
  volume    = {8},
  number    = {4},
  pages     = {588--601},
  year      = {2011},
  url       = {https://doi.org/10.1109/TDSC.2011.18},
  doi       = {10.1109/TDSC.2011.18},
  timestamp = {Thu, 09 Apr 2020 17:07:58 +0200},
  biburl    = {https://dblp.org/rec/journals/tdsc/SalamatJWWF11.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}


@inproceedings{osterlund2019kmvx,
  title     = {kMVX: Detecting kernel information leaks with multi-variant execution},
  author    = {{\"O}sterlund, Sebastian and Koning, Koen and Olivier, Pierre and Barbalace, Antonio and Bos, Herbert and Giuffrida, Cristiano},
  booktitle = {ASPLOS},
  year      = {2019}
}


@inproceedings{salamat2009orchestra,
  title     = {Orchestra: intrusion detection using parallel execution and monitoring of program variants in user-space},
  author    = {Salamat, Babak and Jackson, Todd and Gal, Andreas and Franz, Michael},
  booktitle = {Proceedings of the 4th ACM European conference on Computer systems},
  pages     = {33--46},
  year      = {2009}
}


@inproceedings{koning2016secure,
  title        = {Secure and efficient multi-variant execution using hardware-assisted process virtualization},
  author       = {Koning, Koen and Bos, Herbert and Giuffrida, Cristiano},
  booktitle    = {2016 46th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN)},
  pages        = {431--442},
  year         = {2016},
  organization = {IEEE}
}


@article{10.1145/3281662,
  author     = {Belleville, Nicolas and Courouss\'{e}, Damien and Heydemann, Karine and Charles, Henri-Pierre},
  title      = {Automated Software Protection for the Masses Against Side-Channel Attacks},
  year       = {2018},
  issue_date = {December 2018},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {15},
  number     = {4},
  issn       = {1544-3566},
  url        = {https://doi.org/10.1145/3281662},
  doi        = {10.1145/3281662},
  abstract   = {We present an approach and a tool to answer the need for effective, generic, and easily applicable protections against side-channel attacks. The protection mechanism is based on code polymorphism, so that the observable behaviour of the protected component is variable and unpredictable to the attacker. Our approach combines lightweight specialized runtime code generation with the optimization capabilities of static compilation. It is extensively configurable. Experimental results show that programs secured by our approach present strong security levels and meet the performance requirements of constrained systems.},
  journal    = {ACM Trans. Archit. Code Optim.},
  month      = {nov},
  articleno  = {47},
  numpages   = {27},
  keywords   = {runtime code generation, hiding, polymorphism, compilation, Side-channel attack}
}


@inproceedings{maurer2012tachyon,
  title     = {TACHYON: Tandem execution for efficient live patch testing},
  author    = {Maurer, Matthew and Brumley, David},
  booktitle = {21st USENIX Security Symposium (USENIX Security 12)},
  pages     = {617--630},
  year      = {2012}
}

@article{Kim2015,
  title   = {Dual Execution for On the Fly Fine Grained Execution Comparison},
  author  = {Kim, Dohyeong and Kwon, Yonghwi and Sumner, William N. and Zhang, Xiangyu and Xu, Dongyan},
  journal = {SIGPLAN Not.},
  year    = {2015}
}



@inproceedings{voulimeneas2021dmvx,
  title     = {dMVX: Secure and Efficient Multi-Variant Execution in a Distributed Setting},
  author    = {Voulimeneas, Alexios and Song, Dokyung and Larsen, Per and Franz, Michael and Volckaert, Stijn},
  booktitle = {Proceedings of the 14th European Workshop on Systems Security},
  pages     = {41--47},
  year      = {2021}
}

@inproceedings{9640153,
  author    = {Spies, Benedikt and Mock, Markus},
  booktitle = {2021 XLVII Latin American Computing Conference (CLEI)},
  title     = {An Evaluation of WebAssembly in Non-Web Environments},
  year      = {2021},
  volume    = {},
  number    = {},
  pages     = {1-10},
  doi       = {10.1109/CLEI53233.2021.9640153}
}


@article{natural_diversity,
  author     = {Baudry, Benoit and Monperrus, Martin},
  title      = {The Multiple Facets of Software Diversity: Recent Developments in Year 2000 and Beyond},
  year       = {2015},
  issue_date = {September 2015},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {48},
  number     = {1},
  issn       = {0360-0300},
  url        = {https://doi.org/10.1145/2807593},
  doi        = {10.1145/2807593},
  abstract   = {Early experiments with software diversity in the mid 1970s investigated N-version programming and recovery blocks to increase the reliability of embedded systems. Four decades later, the literature about software diversity has expanded in multiple directions: goals (fault tolerance, security, software engineering), means (managed or automated diversity), and analytical studies (quantification of diversity and its impact). Our article contributes to the field of software diversity as the first work that adopts an inclusive vision of the area, with an emphasis on the most recent advances in the field. This survey includes classical work about design and data diversity for fault tolerance, as well as the cybersecurity literature that investigates randomization at different system levels. It broadens this standard scope of diversity to include the study and exploitation of natural diversity and the management of diverse software products. Our survey includes the most recent works, with an emphasis from 2000 to the present. The targeted audience is researchers and practitioners in one of the surveyed fields who miss the big picture of software diversity. Assembling the multiple facets of this fascinating topic sheds a new light on the field.},
  journal    = {ACM Comput. Surv.},
  month      = {sep},
  articleno  = {16},
  numpages   = {26},
  keywords   = {design principles, Software diversity, program transformation}
}

@inproceedings{SMT_solver,
  author    = {de Moura, Leonardo
               and Bj{\o}rner, Nikolaj},
  editor    = {Ramakrishnan, C. R.
               and Rehof, Jakob},
  title     = {Z3: An Efficient SMT Solver},
  booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
  year      = {2008},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {337--340},
  abstract  = {Satisfiability Modulo Theories (SMT) problem is a decision problem for logical first order formulas with respect to combinations of background theories such as: arithmetic, bit-vectors, arrays, and uninterpreted functions. Z3 is a new and efficient SMT Solver freely available from Microsoft Research. It is used in various software verification and analysis applications.},
  isbn      = {978-3-540-78800-3}
}



@article{2021arXiv210913498S,
  author        = {{Shypula}, Alex and {Yin}, Pengcheng and {Lacomis}, Jeremy and {Le Goues}, Claire and {Schwartz}, Edward and {Neubig}, Graham},
  title         = {{Learning to Superoptimize Real-world Programs}},
  journal       = {arXiv e-prints},
  keywords      = {Computer Science - Machine Learning, Computer Science - Artificial Intelligence, Computer Science - Programming Languages, Computer Science - Software Engineering},
  year          = 2021,
  month         = sep,
  eid           = {arXiv:2109.13498},
  pages         = {arXiv:2109.13498},
  archiveprefix = {arXiv},
  eprint        = {2109.13498},
  primaryclass  = {cs.LG},
  adsurl        = {https://ui.adsabs.harvard.edu/abs/2021arXiv210913498S},
  adsnote       = {Provided by the SAO/NASA Astrophysics Data System}
}


@inproceedings{bhatkar03,
  title     = {Address obfuscation: an efficient approach to combat a board range of memory error exploits},
  author    = {Bhatkar, Sandeep and DuVarney, Daniel C. and Sekar, R.},
  booktitle = {Proceedings of the USENIX Security Symposium},
  year      = {2003}
}



@inproceedings{Kc03,
  title     = {Countering code-injection attacks with instruction-set randomization},
  author    = {Kc, Gaurav S. and Keromytis, Angelos D. and Prevelakis, Vassilis},
  booktitle = {Proc. of CCS},
  year      = {2003},
  pages     = {272--280}
}


@inproceedings{barrantes2003randomized,
  title     = {Randomized instruction set emulation to disrupt binary code injection attacks},
  author    = {Barrantes, Elena Gabriela and Ackley, David H and Forrest, Stephanie and Palmer, Trek S and Stefanovic, Darko and Zovi, Dino Dai},
  booktitle = {Proc. CCS},
  pages     = {281--289},
  year      = {2003}
}


@phdthesis{jackson,
  title  = {On the Design, Implications, and Effects of Implementing Software Diversity for Security},
  author = {Todd Jackson},
  school = {University of California, Irvine},
  year   = {2012}
}


@techreport{Chew02mitigatingbuffer,
  title       = {Mitigating buffer overflows by operating system randomization},
  author      = { Chew, Monica and  Song, Dawn},
  institution = {Carnegie Mellon University},
  year        = {2002},
  number      = {CS-02-197}
}

@inproceedings{bhatkar2005efficient,
  title     = {Efficient techniques for comprehensive protection from memory error exploits},
  author    = {Bhatkar, Sandeep and Sekar, Ron and DuVarney, Daniel C},
  booktitle = {Proceedings of the USENIX Security Symposium},
  year      = {2005},
  pages     = {271--286}
}


@inproceedings{aga2019smokestack,
  title     = {Smokestack: thwarting DOP attacks with runtime stack layout randomization},
  author    = {Aga, Misiker Tadesse and Austin, Todd},
  booktitle = {Proc. of CGO},
  pages     = {26--36},
  year      = {2019},
  url       = {https://drive.google.com/file/d/12TvsrgL8Wt6IMfe6ASUp8y69L-bCVao0/view}
}


@article{lee2021savior,
  title   = {SaVioR: Thwarting Stack-Based Memory Safety Violations by Randomizing Stack Layout},
  author  = {Lee, Seongman and Kang, Hyeonwoo and Jang, Jinsoo and Kang, Brent Byunghoon},
  journal = {IEEE Transactions on Dependable and Secure Computing},
  year    = {2021},
  url     = {https://ieeexplore.ieee.org/iel7/8858/4358699/09369900.pdf}
}



@inproceedings{xu2020merr,
  title     = {Merr: Improving security of persistent memory objects via efficient memory exposure reduction and randomization},
  author    = {Xu, Yuanchao and Solihin, Yan and Shen, Xipeng},
  booktitle = {Proc. of ASPLOS},
  pages     = {987--1000},
  year      = {2020},
  url       = {https://dl.acm.org/doi/pdf/10.1145/3373376.3378492}
}



@inproceedings{10.1145/2384616.2384628,
  author    = {Kulkarni, Sameer and Cavazos, John},
  title     = {Mitigating the Compiler Optimization Phase-Ordering Problem Using Machine Learning},
  year      = {2012},
  isbn      = {9781450315616},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2384616.2384628},
  doi       = {10.1145/2384616.2384628},
  abstract  = {Today's compilers have a plethora of optimizations to choose from, and the correct choice of optimizations can have a significant impact on the performance of the code being optimized. Furthermore, choosing the correct order in which to apply those optimizations has been a long standing problem in compilation research. Each of these optimizations interacts with the code and in turn with all other optimizations in complicated ways. Traditional compilers typically apply the same set of optimization in a fixed order to all functions in a program, without regard the code being optimized.Understanding the interactions of optimizations is very important in determining a good solution to the phase-ordering problem. This paper develops a new approach that automatically selects good optimization orderings on a per method basis within a dynamic compiler. Our approach formulates the phase-ordering problem as a Markov process and uses a characterization of the current state of the code being optimized to creating a better solution to the phase ordering problem. Our technique uses neuro-evolution to construct an artificial neural network that is capable of predicting beneficial optimization ordering for a piece of code that is being optimized. We implemented our technique in Jikes RVM and achieved significant improvements on a set of standard Java benchmarks over a well-engineered fixed order.},
  booktitle = {Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications},
  pages     = {147–162},
  numpages  = {16},
  keywords  = {neural networks, machine learning, java, jikes rvm, phase ordering, compiler optimization, source code feature generation},
  location  = {Tucson, Arizona, USA},
  series    = {OOPSLA '12}
}

@article{phase-ordering-problem,
  author     = {Kulkarni, Sameer and Cavazos, John},
  title      = {Mitigating the Compiler Optimization Phase-Ordering Problem Using Machine Learning},
  year       = {2012},
  issue_date = {October 2012},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {47},
  number     = {10},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/2398857.2384628},
  doi        = {10.1145/2398857.2384628},
  abstract   = {Today's compilers have a plethora of optimizations to choose from, and the correct choice of optimizations can have a significant impact on the performance of the code being optimized. Furthermore, choosing the correct order in which to apply those optimizations has been a long standing problem in compilation research. Each of these optimizations interacts with the code and in turn with all other optimizations in complicated ways. Traditional compilers typically apply the same set of optimization in a fixed order to all functions in a program, without regard the code being optimized.Understanding the interactions of optimizations is very important in determining a good solution to the phase-ordering problem. This paper develops a new approach that automatically selects good optimization orderings on a per method basis within a dynamic compiler. Our approach formulates the phase-ordering problem as a Markov process and uses a characterization of the current state of the code being optimized to creating a better solution to the phase ordering problem. Our technique uses neuro-evolution to construct an artificial neural network that is capable of predicting beneficial optimization ordering for a piece of code that is being optimized. We implemented our technique in Jikes RVM and achieved significant improvements on a set of standard Java benchmarks over a well-engineered fixed order.},
  journal    = {SIGPLAN Not.},
  month      = {oct},
  pages      = {147–162},
  numpages   = {16},
  keywords   = {compiler optimization, machine learning, phase ordering, jikes rvm, java, neural networks, source code feature generation}
}


@misc{MTDNationalCyberLaep,
  title   = {{National Cyber Leap Year}},
  howpublished     = {\url{https://www.nitrd.gov/nitrdgroups/index.php?title=National_Cyber_Leap_Year}},
  urldate = {2021-02-02},
  year    = {2021},
  author  = {{NSA}}
}

@inproceedings{10.1145/3318216.3363338,
  author    = {Roy, Abhishek and Chhabra, Anshuman and Kamhoua, Charles A. and Mohapatra, Prasant},
  title     = {A Moving Target Defense against Adversarial Machine Learning},
  year      = {2019},
  booktitle = {Proceedings of the 4th ACM/IEEE Symposium on Edge Computing},
  pages     = {383–388}
}

@inproceedings{sengupta,
  author    = {Sengupta, Sailik and Vadlamudi, Satya Gautam and Kambhampati, Subbarao and Doup\'{e}, Adam and Zhao, Ziming and Taguinod, Marthony and Ahn, Gail-Joon},
  title     = {A Game Theoretic Approach to Strategy Generation for Moving Target Defense in Web Applications},
  year      = {2017},
  booktitle = {Proceedings of the 16th Conference on Autonomous Agents and MultiAgent Systems},
  pages     = {178–186},
  numpages  = {9},
  keywords  = {moving target defense, bayesian games, stackelberg equilibrium, security games}
}

@inproceedings{EsAsm.js,
  author    = {Van Es, Noah and Nicolay, Jens and Stievenart, Quentin and D'Hondt, Theo and De Roover, Coen},
  title     = {A Performant Scheme Interpreter in Asm.Js},
  year      = {2016},
  isbn      = {9781450337397},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2851613.2851748},
  doi       = {10.1145/2851613.2851748},
  abstract  = {This paper presents the implementation of an efficient interpreter for a Scheme-like language using manually written asm.js code. The asm.js specification defines an optimizable subset of JavaScript which has already served well as a compilation target for web applications where performance is critical. However, its usage as a human-writable language that can be integrated into existing projects to improve performance has remained largely unexplored. We therefore apply this strategy to optimize the implementation of an interpreter. We also discuss the feasibility of this approach, as writing asm.js by hand is generally not its recommended use-case. We therefore present a macro system to solve the challenges we encounter. The resulting interpreter is compared to the original C implementation and its compiled equivalent in asm.js. This way, we evaluate whether manual integration with asm.js provides the necessary performance to bring larger applications and runtimes to the web.},
  booktitle = {Proceedings of the 31st Annual ACM Symposium on Applied Computing},
  pages     = {1944–1951},
  numpages  = {8},
  keywords  = {asm.js, JavaScript, optimization},
  location  = {Pisa, Italy},
  series    = {SAC '16}
}



@article{NEEDLEMAN1970443,
  title        = {A General Method Applicable to the Search for Similarities in the Amino Acid Sequence of Two Proteins},
  volume       = {48},
  issn         = {0022-2836},
  url          = {http://www.sciencedirect.com/science/article/pii/0022283670900574},
  doi          = {https://doi.org/10.1016/0022-2836(70)90057-4},
  abstract     = {A computer adaptable method for finding similarities in the amino acid sequences of two proteins has been developed. From these findings it is possible to determine whether significant homology exists between the proteins. This information is used to trace their possible evolutionary development. The maximum match is a number dependent upon the similarity of the sequences. One of its definitions is the largest number of amino acids of one protein that can be matched with those of a second protein allowing for all possible interruptions in either of the sequences. While the interruptions give rise to a very large number of comparisons, the method efficiently excludes from consideration those comparisons that cannot contribute to the maximum match. Comparisons are made from the smallest unit of significance, a pair of amino acids, one from each protein. All possible pairs are represented by a two-dimensional array, and all possible comparisons are represented by pathways through the array. For this maximum match only certain of the possible pathways must be evaluated. A numerical value, one in this case, is assigned to every cell in the array representing like amino acids. The maximum match is the largest number that would result from summing the cell values of every pathway.},
  number       = {3},
  journaltitle = {Journal of Molecular Biology},
  shortjournal = {J. Mol. Biol.},
  date         = {1970},
  year         = {1970},
  pages        = {443-453},
  author       = {Needleman, Saul B. and Wunsch, Christian D.}
}

@inproceedings{shillaker2020faasm,
  title     = {Faasm: Lightweight isolation for efficient stateful serverless computing},
  author    = {Shillaker, Simon and Pietzuch, Peter},
  booktitle = {USENIX Annual Technical Conference},
  pages     = {419--433},
  year      = {2020}
}

@article{morgan2015web,
  title   = {Web timing attacks made practical},
  author  = {Morgan, Timothy D and Morgan, Jason W},
  journal = {Black Hat},
  year    = {2015}
}

@inproceedings{595185,
  author    = {Forrest, S. and Somayaji, A. and Ackley, D.H.},
  booktitle = {Proceedings. The Sixth Workshop on Hot Topics in Operating Systems (Cat. No.97TB100133)},
  title     = {Building diverse computer systems},
  year      = {1997},
  volume    = {},
  number    = {},
  pages     = {67-72},
  doi       = {10.1109/HOTOS.1997.595185}
}


@article{10.1145/390016.808467,
  author     = {Randell, B.},
  title      = {System Structure for Software Fault Tolerance},
  year       = {1975},
  issue_date = {June 1975},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {10},
  number     = {6},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/390016.808467},
  doi        = {10.1145/390016.808467},
  abstract   = {The paper presents, and discusses the rationale behind, a method for structuring complex computing systems by the use of what we term “recovery blocks”, “conversations” and “fault-tolerant interfaces”. The aim is to facilitate the provision of dependable error detection and recovery facilities which can cope with errors caused by residual design inadequacies, particularly in the system software, rather than merely the occasional malfunctioning of hardware components.},
  journal    = {SIGPLAN Not.},
  month      = {apr},
  pages      = {437–449},
  numpages   = {13},
  keywords   = {Recursive cache, Alternate block, Error recovery, Conversation, Acceptance test, Error detection, Checkpoint, Recovery block}
}

@article{1659219,
  author  = {Avizienis and Kelly},
  journal = {Computer},
  title   = {Fault Tolerance by Design Diversity: Concepts and Experiments},
  year    = {1984},
  volume  = {17},
  number  = {8},
  pages   = {67-80},
  doi     = {10.1109/MC.1984.1659219}
}
@article{CHEN201060,
  title    = {Adaptive Random Testing: The ART of test case diversity},
  journal  = {Journal of Systems and Software},
  volume   = {83},
  number   = {1},
  pages    = {60-66},
  year     = {2010},
  note     = {SI: Top Scholars},
  issn     = {0164-1212},
  doi      = {https://doi.org/10.1016/j.jss.2009.02.022},
  url      = {https://www.sciencedirect.com/science/article/pii/S0164121209000405},
  author   = {Tsong Yueh Chen and Fei-Ching Kuo and Robert G. Merkel and T.H. Tse},
  keywords = {Software testing, Random testing, Adaptive random testing, Adaptive random sequence, Failure-based testing, Failure pattern},
  abstract = {Random testing is not only a useful testing technique in itself, but also plays a core role in many other testing methods. Hence, any significant improvement to random testing has an impact throughout the software testing community. Recently, Adaptive Random Testing (ART) was proposed as an effective alternative to random testing. This paper presents a synthesis of the most important research results related to ART. In the course of our research and through further reflection, we have realised how the techniques and concepts of ART can be applied in a much broader context, which we present here. We believe such ideas can be applied in a variety of areas of software testing, and even beyond software testing. Amongst these ideas, we particularly note the fundamental role of diversity in test case selection strategies. We hope this paper serves to provoke further discussions and investigations of these ideas.}
}

@book{pohl2005software,
  title     = {Software product line engineering: foundations, principles, and techniques},
  author    = {Pohl, Klaus and B{\"o}ckle, G{\"u}nter and Van Der Linden, Frank},
  volume    = {1},
  year      = {2005},
  publisher = {Springer}
}

@article{Chen2010AdaptiveRT,
  title   = {Adaptive Random Testing: The ART of test case diversity},
  author  = {Tsong Yueh Chen and Fei-Ching Kuo and Robert G. Merkel and T. H. Tse},
  journal = {J. Syst. Softw.},
  year    = {2010},
  volume  = {83},
  pages   = {60-66}
}

@inproceedings{10.1145/2025113.2025133,
  author    = {Sidiroglou-Douskos, Stelios and Misailovic, Sasa and Hoffmann, Henry and Rinard, Martin},
  title     = {Managing Performance vs. Accuracy Trade-Offs with Loop Perforation},
  year      = {2011},
  isbn      = {9781450304436},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2025113.2025133},
  doi       = {10.1145/2025113.2025133},
  abstract  = {Many modern computations (such as video and audio encoders, Monte Carlo simulations, and machine learning algorithms) are designed to trade off accuracy in return for increased performance. To date, such computations typically use ad-hoc, domain-specific techniques developed specifically for the computation at hand. Loop perforation provides a general technique to trade accuracy for performance by transforming loops to execute a subset of their iterations. A criticality testing phase filters out critical loops (whose perforation produces unacceptable behavior) to identify tunable loops (whose perforation produces more efficient and still acceptably accurate computations). A perforation space exploration algorithm perforates combinations of tunable loops to find Pareto-optimal perforation policies. Our results indicate that, for a range of applications, this approach typically delivers performance increases of over a factor of two (and up to a factor of seven) while changing the result that the application produces by less than 10%.},
  booktitle = {Proceedings of the 19th ACM SIGSOFT Symposium and the 13th European Conference on Foundations of Software Engineering},
  pages     = {124–134},
  numpages  = {11},
  keywords  = {profiling, loop perforation, quality of service},
  location  = {Szeged, Hungary},
  series    = {ESEC/FSE '11}
}

@article{okhravi2013survey,
  title   = {Survey of cyber moving targets},
  author  = {Okhravi, H and Rabe, MA and Mayberry, TJ and Leonard, WG and Hobson, TR and Bigelow, D and Streilein, WW},
  journal = {Massachusetts Inst of Technology Lexington Lincoln Lab, No. MIT/LL-TR-1166},
  year    = {2013}
}

@inproceedings{wobfuscator,
  author    = {A. Romano and D. Lehmann and M. Pradel and W. Wang},
  booktitle = {2022 2022 IEEE Symposium on Security and Privacy (SP) (SP)},
  title     = {Wobfuscator: Obfuscating JavaScript Malware via Opportunistic Translation to WebAssembly},
  year      = {2022},
  volume    = {},
  issn      = {2375-1207},
  pages     = {1101-1116},
  keywords  = {webassembly;obfuscation;malware;opportunistic;web},
  doi       = {10.1109/SP46214.2022.00064},
  url       = {https://doi.ieeecomputersociety.org/10.1109/SP46214.2022.00064},
  publisher = {IEEE Computer Society},
  address   = {Los Alamitos, CA, USA},
  month     = {may}
}



@article{johnson2021,
  title   = {SFI safety for native-compiled Wasm},
  author  = {Johnson, Evan and Thien, David and Alhessi, Yousef and Narayan, Shravan and Brown, Fraser and Lerner, Sorin and McMullen, Tyler and Savage, Stefan and Stefan, Deian},
  journal = {NDSS. Internet Society},
  year    = {2021}
}



@article{MEWE,
  author        = {{Cabrera Arteaga}, Javier and {Laperdrix}, Pierre and {Monperrus}, Martin and {Baudry}, Benoit},
  title         = {{Multi-Variant Execution at the Edge}},
  journal       = {arXiv e-prints},
  keywords      = {Computer Science - Software Engineering},
  year          = 2021,
  month         = aug,
  eid           = {arXiv:2108.08125},
  pages         = {arXiv:2108.08125},
  archiveprefix = {arXiv},
  eprint        = {2108.08125},
  primaryclass  = {cs.SE},
  adsurl        = {https://ui.adsabs.harvard.edu/abs/2021arXiv210808125C},
  adsnote       = {Provided by the SAO/NASA Astrophysics Data System}
}

@inproceedings{CROW,
  title     = {CROW: code diversification for webassembly},
  author    = {Cabrera Arteaga, Javier and Floros, Orestis and Vera Perez, Oscar and Baudry, Benoit and Monperrus, Martin},
  booktitle = {MADWeb, NDSS 2021},
  year      = {2021},
  url       = {https://doi.org/10.14722/madweb.2021.23004}
}

@article{harrand2020java,
  title     = {Java decompiler diversity and its application to meta-decompilation},
  author    = {Harrand, Nicolas and Soto-Valero, C{\'e}sar and Monperrus, Martin and Baudry, Benoit},
  journal   = {Journal of Systems and Software},
  volume    = {168},
  pages     = {110645},
  year      = {2020},
  publisher = {Elsevier}
}
@article{Tsoupidi2020ConstraintBasedSD,
  title   = {Constraint-Based Software Diversification for Efficient Mitigation of Code-Reuse Attacks},
  author  = {Rodothea Myrsini Tsoupidi and Roberto Casta{\~n}eda Lozano and Beno{\^i}t Baudry},
  journal = {ArXiv},
  year    = {2020},
  volume  = {abs/2007.08955}
}
@article{10.1145/93548.93550,
  author     = {Pettis, Karl and Hansen, Robert C.},
  title      = {Profile Guided Code Positioning},
  year       = {1990},
  issue_date = {Jun. 1990},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {25},
  number     = {6},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/93548.93550},
  doi        = {10.1145/93548.93550},
  abstract   = {This paper presents the results of our investigation of code positioning techniques using execution profile data as input into the compilation process. The primary objective of the positioning is to reduce the overhead of the instruction memory hierarchy.After initial investigation in the literature, we decided to implement two prototypes for the Hewlett-Packard Precision Architecture (PA-RISC). The first, built on top of the linker, positions code based on whole procedures. This prototype has the ability to move procedures into an order that is determined by a “closest is best” strategy.The second prototype, built on top of an existing optimizer package, positions code based on basic blocks within procedures. Groups of basic blocks that would be better as straight-line sequences are identified as chains. These chains are then ordered according to branch heuristics. Code that is never executed during the data collection runs can be physically separated from the primary code of a procedure by a technique we devised called procedure splitting.The algorithms we implemented are described through examples in this paper. The performance improvements from our work are also summarized in various tables and charts.},
  journal    = {SIGPLAN Not.},
  month      = {jun},
  pages      = {16–27},
  numpages   = {12}
}

@inproceedings{pettisochhansen,
  author    = {Pettis, Karl and Hansen, Robert C.},
  title     = {Profile Guided Code Positioning},
  year      = {1990},
  isbn      = {0897913647},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/93542.93550},
  doi       = {10.1145/93542.93550},
  abstract  = {This paper presents the results of our investigation of code positioning techniques using execution profile data as input into the compilation process. The primary objective of the positioning is to reduce the overhead of the instruction memory hierarchy.After initial investigation in the literature, we decided to implement two prototypes for the Hewlett-Packard Precision Architecture (PA-RISC). The first, built on top of the linker, positions code based on whole procedures. This prototype has the ability to move procedures into an order that is determined by a “closest is best” strategy.The second prototype, built on top of an existing optimizer package, positions code based on basic blocks within procedures. Groups of basic blocks that would be better as straight-line sequences are identified as chains. These chains are then ordered according to branch heuristics. Code that is never executed during the data collection runs can be physically separated from the primary code of a procedure by a technique we devised called procedure splitting.The algorithms we implemented are described through examples in this paper. The performance improvements from our work are also summarized in various tables and charts.},
  booktitle = {Proceedings of the ACM SIGPLAN 1990 Conference on Programming Language Design and Implementation},
  pages     = {16–27},
  numpages  = {12},
  location  = {White Plains, New York, USA},
  series    = {PLDI '90}
}


@inproceedings{ElKhalil2004,
  author    = {El-Khalil, Rakan
               and Keromytis, Angelos D.},
  editor    = {Lopez, Javier
               and Qing, Sihan
               and Okamoto, Eiji},
  title     = {Hydan: Hiding Information in Program Binaries},
  booktitle = {Information and Communications Security},
  year      = {2004},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {187--199},
  abstract  = {We present a scheme to steganographically embed information in x86 program binaries. We define sets of functionally-equivalent instructions, and use a key-derived selection process to encode information in machine code by using the appropriate instructions from each set. Such a scheme can be used to watermark (or fingerprint) code, sign executables, or simply create a covert communication channel. We experimentally measure the capacity of the covert channel by determining the distribution of equivalent instructions in several popular operating system distributions. Our analysis shows that we can embed only a limited amount of information in each executable (approximately {\$}{\backslash}frac{\{}1{\}}{\{}110{\}}{\$}bit encoding rate), although this amount is sufficient for some of the potential applications mentioned. We conclude by discussing potential improvements to the capacity of the channel and other future work.},
  isbn      = {978-3-540-30191-2}
}



@article{Cleemput2012,
  author     = {Cleemput, Jeroen V. and Coppens, Bart and De Sutter, Bjorn},
  title      = {Compiler Mitigations for Time Attacks on Modern X86 Processors},
  year       = {2012},
  issue_date = {January 2012},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {8},
  number     = {4},
  issn       = {1544-3566},
  url        = {https://doi.org/10.1145/2086696.2086702},
  doi        = {10.1145/2086696.2086702},
  abstract   = {This paper studies and evaluates the extent to which automated compiler techniques can defend against timing-based side channel attacks on modern x86 processors. We study how modern x86 processors can leak timing information through side channels that relate to data flow. We study the efficiency, effectiveness, portability, predictability and sensitivity of several mitigating code transformations that eliminate or minimize key-dependent execution time variations. Furthermore, we discuss the extent to which compiler backends are a suitable tool to provide automated support for the proposed mitigations.},
  journal    = {ACM Trans. Archit. Code Optim.},
  month      = {jan},
  articleno  = {23},
  numpages   = {20},
  keywords   = {variable latency instructions, Time-based side channels, x86 architecture}
}

@inproceedings{Younan2006,
  author    = {Younan, Yves and Pozza, Davide and Piessens, Frank and Joosen, Wouter},
  booktitle = {2006 22nd Annual Computer Security Applications Conference (ACSAC'06)},
  title     = {Extended Protection against Stack Smashing Attacks without Performance Loss},
  year      = {2006},
  volume    = {},
  number    = {},
  pages     = {429-438},
  doi       = {10.1109/ACSAC.2006.27}
}



@inbook{ahodragonbook,
  author    = {Aho, Alfred V. and Sethi, Ravi and Ullman, Jeffrey D.},
  title     = {Compilers: Principles, Techniques, and Tools},
  year      = {1986},
  isbn      = {0201100886},
  chapter   = {1},
  pages     = {28-31},
  publisher = {Addison-Wesley Longman Publishing Co., Inc.},
  address   = {USA}
}

@article{Sasnauskas2017Souper:Superoptimizer,
  title   = {{Souper: A Synthesizing Superoptimizer}},
  year    = {2017},
  author  = {Sasnauskas, Raimondas and Chen, Yang and Collingbourne, Peter and Ketema, Jeroen and Lup, Gratian and Taneja, Jubi and Regehr, John},
  journal = {arXiv preprint 1711.04422}
}


@inproceedings{10.1007/978-3-540-78800-3_24,
  author    = {de Moura, Leonardo
               and Bj{\o}rner, Nikolaj},
  editor    = {Ramakrishnan, C. R.
               and Rehof, Jakob},
  title     = {Z3: An Efficient SMT Solver},
  booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
  year      = {2008},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {337--340},
  abstract  = {Satisfiability Modulo Theories (SMT) problem is a decision problem for logical first order formulas with respect to combinations of background theories such as: arithmetic, bit-vectors, arrays, and uninterpreted functions. Z3 is a new and efficient SMT Solver freely available from Microsoft Research. It is used in various software verification and analysis applications.},
  isbn      = {978-3-540-78800-3}
}



@inproceedings{liljestrand2021pacstack,
  title     = {PACStack: an Authenticated Call Stack},
  author    = {Liljestrand, Hans and Nyman, Thomas and Gunn, Lachlan J and Ekberg, Jan-Erik and Asokan, N},
  booktitle = {30th USENIX Security Symposium (USENIX Security 21)},
  year      = {2021}
}


@inproceedings{rane2015raccoon,
  title     = {Raccoon: Closing digital side-channels through obfuscated execution},
  author    = {Rane, Ashay and Lin, Calvin and Tiwari, Mohit},
  booktitle = {24th USENIX Security Symposium (USENIX Security 15)},
  pages     = {431--446},
  year      = {2015}
}


@article{ryder1979,
  title     = {Constructing the call graph of a program},
  author    = {Ryder, Barbara G},
  journal   = {IEEE Transactions on Software Engineering},
  number    = {3},
  pages     = {216--226},
  year      = {1979},
  publisher = {IEEE}
}


@misc{WASI,
  title   = {WebAssembly System Interface},
  howpublished     = {\url{https://github.com/WebAssembly/WASI}},
  urldate = {2021-07-22},
  year    = {2021}
}

@misc{CVE,
  title   = {Stop a Wasm Compiler Bug Before it Becomes a Problem | Fastly},
  howpublished     = {\url{https://www.fastly.com/blog/defense-in-depth-stopping-a-wasm-compiler-bug-before-it-became-a-problem}},
  urldate = {2021-07-22},
  year    = {2021}
}



@inproceedings{10.1007/978-3-642-14107-2_7,
  author    = {Guha, Arjun
               and Saftoiu, Claudiu
               and Krishnamurthi, Shriram},
  editor    = {D'Hondt, Theo},
  title     = {The Essence of JavaScript},
  booktitle = {ECOOP 2010 -- Object-Oriented Programming},
  year      = {2010},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {126--150},
  abstract  = {We reduce JavaScript to a core calculus structured as a small-step operational semantics. We present several peculiarities of the language and show that our calculus models them. We explicate the desugaring process that turns JavaScript programs into ones in the core. We demonstrate faithfulness to JavaScript using real-world test suites. Finally, we illustrate utility by defining a security property, implementing it as a type system on the core, and extending it to the full language.},
  isbn      = {978-3-642-14107-2}
}



@inproceedings{churchill2019,
  author    = {Churchill, Berkeley and Padon, Oded and Sharma, Rahul and Aiken, Alex},
  title     = {Semantic Program Alignment for Equivalence Checking},
  year      = {2019},
  isbn      = {9781450367127},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3314221.3314596},
  doi       = {10.1145/3314221.3314596},
  abstract  = {We introduce a robust semantics-driven technique for program equivalence checking. Given two functions we find a trace alignment over a set of concrete executions of both programs and construct a product program particularly amenable to checking equivalence.  We demonstrate that our algorithm is applicable to challenging equivalence problems beyond the scope of existing techniques. For example, we verify the correctness of the hand-optimized vector implementation of strlen that ships as part of the GNU C Library, as well as the correctness of vectorization optimizations for 56 benchmarks derived from the Test Suite for Vectorizing Compilers.},
  booktitle = {Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  pages     = {1027–1040},
  numpages  = {14},
  keywords  = {verification, equivalence checking},
  location  = {Phoenix, AZ, USA},
  series    = {PLDI 2019}
}

@inproceedings{SMTGupta,
  author    = {Gupta, Shubhani
               and Saxena, Aseem
               and Mahajan, Anmol
               and Bansal, Sorav},
  editor    = {Beyersdorff, Olaf
               and Wintersteiger, Christoph M.},
  title     = {Effective Use of SMT Solvers for Program Equivalence Checking Through Invariant-Sketching and Query-Decomposition},
  booktitle = {Theory and Applications of Satisfiability Testing -- SAT 2018},
  year      = {2018},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {365--382},
  abstract  = {Program equivalence checking is a fundamental problem in computer science with applications to translation validation and automatic synthesis of compiler optimizations. Contemporary equivalence checkers employ SMT solvers to discharge proof obligations generated by their equivalence checking algorithm. Equivalence checkers also involve algorithms to infer invariants that relate the intermediate states of the two programs being compared for equivalence. We present a new algorithm, called invariant-sketching, that allows the inference of the required invariants through the generation of counter-examples using SMT solvers. We also present an algorithm, called query-decomposition, that allows a more capable use of SMT solvers for application to equivalence checking. Both invariant-sketching and query-decomposition help us prove equivalence across program transformations that could not be handled by previous equivalence checking algorithms.},
  isbn      = {978-3-319-94144-8}
}



@inproceedings{LeCompilers,
  author    = {Le, Vu and Afshari, Mehrdad and Su, Zhendong},
  title     = {Compiler Validation via Equivalence modulo Inputs},
  year      = {2014},
  booktitle = {Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  pages     = {216–226},
  numpages  = {11},
  keywords  = {equivalent program variants, automated testing, miscompilation, compiler testing},
  location  = {Edinburgh, United Kingdom},
  series    = {PLDI ’14}
}

@inbook{WasmSuperoptimizer,
  author    = {Cabrera Arteaga, Javier and Donde, Shrinish and Gu, Jian and Floros, Orestis and Satabin, Lucas and Baudry, Benoit and Monperrus, Martin},
  title     = {Superoptimization of WebAssembly Bytecode},
  year      = {2020},
  isbn      = {9781450375078},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3397537.3397567},
  abstract  = {Motivated by the fast adoption of WebAssembly, we propose the first functional pipeline to support the superoptimization of WebAssembly bytecode. Our pipeline works over LLVM and Souper. We evaluate our superoptimization pipeline with 12 programs from the Rosetta code project. Our pipeline improves the code section size of 8 out of 12 programs. We discuss the challenges faced in superoptimization of WebAssembly with two case studies.},
  booktitle = {Conference Companion of the 4th International Conference on Art, Science, and Engineering of Programming},
  pages     = {36–40},
  numpages  = {5}
}
@inproceedings{STRAC,
  author    = {Cabrera Arteaga, Javier and Monperrus, Martin and Baudry, Benoit},
  title     = {Scalable Comparison of JavaScript V8 Bytecode Traces},
  year      = {2019},
  isbn      = {9781450369879},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3358504.3361228},
  doi       = {10.1145/3358504.3361228},
  abstract  = {The comparison and alignment of runtime traces are essential, e.g., for semantic analysis or debugging. However, naive sequence alignment algorithms cannot address the needs of the modern web: (i) the bytecode generation process of V8 is not deterministic; (ii) bytecode traces are large.  We present STRAC, a scalable and extensible tool tailored to compare bytecode traces generated by the V8 JavaScript engine. Given two V8 bytecode traces and a distance function between trace events, STRAC computes and provides the best alignment. The key insight is to split access between memory and disk. STRAC can identify semantically equivalent web pages and is capable of processing huge V8 bytecode traces whose order of magnitude matches today's web like https://2019.splashcon.org, which generates approx. 150k of V8 bytecode instructions.},
  booktitle = {Proceedings of the 11th ACM SIGPLAN International Workshop on Virtual Machines and Intermediate Languages},
  pages     = {22–31},
  numpages  = {10},
  keywords  = {Sequence alignment, V8, Bytecode, Similarity measurement, JavaScript},
  location  = {Athens, Greece},
  series    = {VMIL 2019}
}


@inproceedings{pMendkiServerless,
  author    = {P. {Mendki}},
  booktitle = {2020 IEEE Cloud Summit},
  title     = {Evaluating Webassembly Enabled Serverless Approach for Edge Computing},
  year      = {2020},
  volume    = {},
  number    = {},
  pages     = {161-166},
  doi       = {10.1109/IEEECloudSummit48914.2020.00031}
}

@techreport{Napieralla2020,
  author = {Napieralla, Jonah},
  file   = {:Users/javierca/Library/Application Support/Mendeley Desktop/Downloaded/Napieralla - 2020 - Considering WebAssembly Containers for Edge Computing on Hardware-Constrained IoT Devices.pdf:pdf},
  isbn   = {4645538500},
  title  = {{Considering WebAssembly Containers for Edge Computing on Hardware-Constrained IoT Devices}},
  url    = {www.bth.se},
  year   = {2020}
}

@inproceedings{1244493Jacobsson,
  title        = {Virtual machine execution for wearables based on webassembly},
  author       = {Jacobsson, Martin and W{\aa}hsl{\'e}n, Jonas},
  booktitle    = {EAI International Conference on Body Area Networks},
  pages        = {381--389},
  year         = {2018},
  organization = {Springer, Cham}
}

@techreport{FastlyWasm,
  title  = {Announcing Lucet: Fastly’s native WebAssembly compiler and runtime},
  year   = 2018,
  author = {Hickey, Pat},
  month  = mar,
  editor = {Hickey, Pat},
  url    = {https://www.fastly.com/blog/announcing-lucet-fastly-native-webassembly-compiler-runtime}
}

@techreport{CloudflareWasm,
  title  = {WebAssembly on Cloudflare Workers},
  year   = 2018,
  month  = jan,
  author = {Varda, Kenton},
  editor = {Varda, Kenton},
  url    = {https://blog.cloudflare.com/webassembly-on-cloudflare-workers/}
}

@phdthesis{Harrand1650630,
  author      = {Harrand, Nicolas},
  institution = {KTH, Software and Computer systems, SCS},
  note        = {QCR 20220413},
  pages       = {100},
  school      = {KTH, Software and Computer systems, SCS},
  title       = {Software Diversity for Third-Party Dependencies},
  series      = {TRITA-EECS-AVL},
  number      = {2022:22},
  keywords    = {Automated Software Engineering, Software Diversity, Software libraries, Software Monoculture},
  abstract    = {Thanks to the emergence of package managers and online software repositories, modern software development heavily relies on the reuse of third-party libraries. This practice has significant benefits in terms of productivity and reliability. Yet, the reuse of software libraries leads large groups of applications to share a significant amount of code, including potential defects such as bugs or vulnerabilities. The lack of diversity in these group of applications make them more prone to large-scale failures, and more predictable for attackers attempting to exploit their shared vulnerabilities.To mitigate these risks opened by library reuse, this dissertation proposes to introduce diversity in software applications.We create variants of software applications through transformations targeting the libraries they depend on. These variants provide functionalities equivalent to their original, while not sharing the exact same behavior. In this dissertation, we cover three aspects of software diversity.First, we study the existing behavioral diversity of alternative libraries implementing similar functionalities.We perform two case studies on two families of reusable software artifacts: JSON libraries and Bytecode decompilers. We provide empirical evidence that both groups of artifacts exhibit significant natural input/output behavioral diversity. Second, we study software transformations targeting libraries themselves. We propose six source-to-source transformations targeting software libraries, as well as a general architecture to implement library substitution. We implement this architecture in a JSON library substitution framework, leveraging the diversity of behavior we observe in JSON libraries. We assess the impact of these transformations on open-source libraries and software applications through two experiments. Finally, we study the properties of software applications and libraries that make them prone to transformation without changing their functionalities. We analyze the variants produced during our software diversification experiments and discuss our findings. In particular, we observe that the existence of alternative implementations at different granularity, instructions, methods, classes, and libraries, provides an important source of potential diversity that can be leveraged. },
  isbn        = {978-91-8040-184-5},
  year        = {2022}
}

@inproceedings{DeRoover2022,
  author    = {Sti\'{e}venart, Quentin and De Roover, Coen and Ghafari, Mohammad},
  title     = {Security Risks of Porting C Programs to Webassembly},
  year      = {2022},
  isbn      = {9781450387132},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3477314.3507308},
  doi       = {10.1145/3477314.3507308},
  abstract  = {WebAssembly is a compilation target for cross-platform applications that is increasingly being used. In this paper, we investigate whether one can transparently cross-compile C programs to WebAssembly, and if not, what impact porting can have on their security. We compile 17 802 programs that exhibit common vulnerabilities to 64-bit x86 and to WebAssembly binaries, and we observe that the execution of 4 911 binaries produces different results across these platforms. Through manual inspection, we identify three classes of root causes for such differences: the use of a different standard library implementation, the lack of security measures in WebAssembly, and the different semantics of the execution environments. We describe our observations and discuss the ones that are critical from a security point of view and need most attention from developers. We conclude that compiling an existing C program to WebAssembly for cross-platform distribution may require source code adaptations; otherwise, the security of the WebAssembly application may be at risk.},
  booktitle = {Proceedings of the 37th ACM/SIGAPP Symposium on Applied Computing},
  pages     = {1713–1722},
  numpages  = {10},
  keywords  = {WebAssembly, security, cross-compilation},
  location  = {Virtual Event},
  series    = {SAC '22}
}
@misc{zalewski2017american,
  title  = {American fuzzy lop},
  author = {Zalewski, Michal},
  year   = {2017}
}

@inproceedings{10.1145/2872362.2872387,
  author    = {Phothilimthana, Phitchaya Mangpo and Thakur, Aditya and Bodik, Rastislav and Dhurjati, Dinakar},
  title     = {Scaling up Superoptimization},
  year      = {2016},
  isbn      = {9781450340915},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2872362.2872387},
  doi       = {10.1145/2872362.2872387},
  abstract  = {Developing a code optimizer is challenging, especially for new, idiosyncratic ISAs. Superoptimization can, in principle, discover machine-specific optimizations automatically by searching the space of all instruction sequences. If we can increase the size of code fragments a superoptimizer can optimize, we will be able to discover more optimizations. We develop LENS, a search algorithm that increases the size of code a superoptimizer can synthesize by rapidly pruning away invalid candidate programs. Pruning is achieved by selectively refining the abstraction under which candidates are considered equivalent, only in the promising part of the candidate space. LENS also uses a bidirectional search strategy to prune the candidate space from both forward and backward directions. These pruning strategies allow LENS to solve twice as many benchmarks as existing enumerative search algorithms, while LENS is about 11-times faster.Additionally, we increase the effective size of the superoptimized fragments by relaxing the correctness condition using contexts (surrounding code). Finally, we combine LENS with complementary search techniques into a cooperative superoptimizer, which exploits the stochastic search to make random jumps in a large candidate space, and a symbolic (SAT-solver-based) search to synthesize arbitrary constants. While existing superoptimizers consistently solve 9--16 out of 32 benchmarks, the cooperative superoptimizer solves 29 benchmarks. It can synthesize code fragments that are up to 82% faster than code generated by gcc -O3 from WiBench and MiBench.},
  booktitle = {Proceedings of the Twenty-First International Conference on Architectural Support for Programming Languages and Operating Systems},
  pages     = {297–310},
  numpages  = {14},
  keywords  = {program synthesis, SMT, superoptimization},
  location  = {Atlanta, Georgia, USA},
  series    = {ASPLOS '16}
}

@article{10.1145/2954679.2872387,
  author     = {Phothilimthana, Phitchaya Mangpo and Thakur, Aditya and Bodik, Rastislav and Dhurjati, Dinakar},
  title      = {Scaling up Superoptimization},
  year       = {2016},
  issue_date = {April 2016},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {51},
  number     = {4},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/2954679.2872387},
  doi        = {10.1145/2954679.2872387},
  abstract   = {Developing a code optimizer is challenging, especially for new, idiosyncratic ISAs. Superoptimization can, in principle, discover machine-specific optimizations automatically by searching the space of all instruction sequences. If we can increase the size of code fragments a superoptimizer can optimize, we will be able to discover more optimizations. We develop LENS, a search algorithm that increases the size of code a superoptimizer can synthesize by rapidly pruning away invalid candidate programs. Pruning is achieved by selectively refining the abstraction under which candidates are considered equivalent, only in the promising part of the candidate space. LENS also uses a bidirectional search strategy to prune the candidate space from both forward and backward directions. These pruning strategies allow LENS to solve twice as many benchmarks as existing enumerative search algorithms, while LENS is about 11-times faster.Additionally, we increase the effective size of the superoptimized fragments by relaxing the correctness condition using contexts (surrounding code). Finally, we combine LENS with complementary search techniques into a cooperative superoptimizer, which exploits the stochastic search to make random jumps in a large candidate space, and a symbolic (SAT-solver-based) search to synthesize arbitrary constants. While existing superoptimizers consistently solve 9--16 out of 32 benchmarks, the cooperative superoptimizer solves 29 benchmarks. It can synthesize code fragments that are up to 82% faster than code generated by gcc -O3 from WiBench and MiBench.},
  journal    = {SIGPLAN Not.},
  month      = {mar},
  pages      = {297–310},
  numpages   = {14},
  keywords   = {superoptimization, program synthesis, SMT}
}

@article{SuperoptimizationScaling,
  author     = {Phothilimthana, Phitchaya Mangpo and Thakur, Aditya and Bodik, Rastislav and Dhurjati, Dinakar},
  title      = {Scaling up Superoptimization},
  year       = {2016},
  issue_date = {May 2016},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {44},
  number     = {2},
  issn       = {0163-5964},
  url        = {https://doi.org/10.1145/2980024.2872387},
  doi        = {10.1145/2980024.2872387},
  abstract   = {Developing a code optimizer is challenging, especially for new, idiosyncratic ISAs. Superoptimization can, in principle, discover machine-specific optimizations automatically by searching the space of all instruction sequences. If we can increase the size of code fragments a superoptimizer can optimize, we will be able to discover more optimizations. We develop LENS, a search algorithm that increases the size of code a superoptimizer can synthesize by rapidly pruning away invalid candidate programs. Pruning is achieved by selectively refining the abstraction under which candidates are considered equivalent, only in the promising part of the candidate space. LENS also uses a bidirectional search strategy to prune the candidate space from both forward and backward directions. These pruning strategies allow LENS to solve twice as many benchmarks as existing enumerative search algorithms, while LENS is about 11-times faster.Additionally, we increase the effective size of the superoptimized fragments by relaxing the correctness condition using contexts (surrounding code). Finally, we combine LENS with complementary search techniques into a cooperative superoptimizer, which exploits the stochastic search to make random jumps in a large candidate space, and a symbolic (SAT-solver-based) search to synthesize arbitrary constants. While existing superoptimizers consistently solve 9--16 out of 32 benchmarks, the cooperative superoptimizer solves 29 benchmarks. It can synthesize code fragments that are up to 82% faster than code generated by gcc -O3 from WiBench and MiBench.},
  journal    = {SIGARCH Comput. Archit. News},
  month      = {mar},
  pages      = {297–310},
  numpages   = {14},
  keywords   = {program synthesis, superoptimization, SMT}
}


@inproceedings{10.1145/3507657.3528560,
  author    = {Bhansali, Shrenik and Aris, Ahmet and Acar, Abbas and Oz, Harun and Uluagac, A. Selcuk},
  title     = {A First Look at Code Obfuscation for WebAssembly},
  year      = {2022},
  isbn      = {9781450392167},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3507657.3528560},
  doi       = {10.1145/3507657.3528560},
  abstract  = {WebAssembly (Wasm) has seen a lot of attention lately as it spreads through the mobile computing domain and becomes the new standard for performance-oriented web development. It has diversified its uses far beyond just web applications by acting as an execution environment for mobile agents, containers for IoT devices, and enabling new serverless approaches for edge computing. Within the numerous uses of Wasm, not all of them are benign. With the rise of Wasm-based cryptojacking malware, analyzing Wasm applications has been a hot topic in the literature, resulting in numerous Wasm-based cryptojacking detection systems. Many of these methods rely on static analysis, which traditionally can be circumvented through obfuscation. However, the feasibility of the obfuscation techniques for Wasm programs has never been investigated thoroughly. In this paper, we address this gap and perform the first look at code obfuscation for Wasm. We apply numerous obfuscation techniques to Wasm programs, and test their effectiveness in producing a fully obfuscated Wasm program. Particularly, we obfuscate both benign Wasm-based web applications and cryptojacking malware instances and feed them into a state-of-the-art Wasm cryptojacking detector to see if current Wasm analysis methods can be subverted with obfuscation. Our analysis shows that obfuscation can be highly effective and can cause even a state-of-the-art detector to misclassify the obfuscated Wasm samples.},
  booktitle = {Proceedings of the 15th ACM Conference on Security and Privacy in Wireless and Mobile Networks},
  pages     = {140–145},
  numpages  = {6},
  keywords  = {webassembly, wasm, obfuscation, cryptojacking},
  location  = {San Antonio, TX, USA},
  series    = {WiSec '22}
}


@article{10.1145/1190215.1190252,
  author     = {Yu, Dachuan and Chander, Ajay and Islam, Nayeem and Serikov, Igor},
  title      = {JavaScript Instrumentation for Browser Security},
  year       = {2007},
  issue_date = {January 2007},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {42},
  number     = {1},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/1190215.1190252},
  doi        = {10.1145/1190215.1190252},
  abstract   = {It is well recognized that JavaScript can be exploited to launch browser-based security attacks. We propose to battle such attacks using program instrumentation. Untrusted JavaScript code goes through a rewriting process which identifies relevant operations, modifies questionable behaviors, and prompts the user (a web page viewer) for decisions on how to proceed when appropriate. Our solution is parametric with respect to the security policy-the policy is implemented separately from the rewriting, and the same rewriting process is carried out regardless of which policy is in use. Be-sides providing a rigorous account of the correctness of our solution, we also discuss practical issues including policy management and prototype experiments. A useful by-product of our work is an operational semantics of a core subset of JavaScript, where code embedded in (HTML) documents may generate further document pieces (with new code embedded) at runtime, yielding a form of self-modifying code.},
  journal    = {SIGPLAN Not.},
  month      = {jan},
  pages      = {237–249},
  numpages   = {13},
  keywords   = {edit automata, program instrumentation, web browser, JavaScript}
}

@inproceedings{10.1145/1190216.1190252,
  author    = {Yu, Dachuan and Chander, Ajay and Islam, Nayeem and Serikov, Igor},
  title     = {JavaScript Instrumentation for Browser Security},
  year      = {2007},
  isbn      = {1595935754},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1190216.1190252},
  doi       = {10.1145/1190216.1190252},
  abstract  = {It is well recognized that JavaScript can be exploited to launch browser-based security attacks. We propose to battle such attacks using program instrumentation. Untrusted JavaScript code goes through a rewriting process which identifies relevant operations, modifies questionable behaviors, and prompts the user (a web page viewer) for decisions on how to proceed when appropriate. Our solution is parametric with respect to the security policy-the policy is implemented separately from the rewriting, and the same rewriting process is carried out regardless of which policy is in use. Be-sides providing a rigorous account of the correctness of our solution, we also discuss practical issues including policy management and prototype experiments. A useful by-product of our work is an operational semantics of a core subset of JavaScript, where code embedded in (HTML) documents may generate further document pieces (with new code embedded) at runtime, yielding a form of self-modifying code.},
  booktitle = {Proceedings of the 34th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages     = {237–249},
  numpages  = {13},
  keywords  = {web browser, program instrumentation, edit automata, JavaScript},
  location  = {Nice, France},
  series    = {POPL '07}
}



@article{maliciousJS,
  author   = {Y. {Fang} and C. {Huang} and L. {Liu} and M. {Xue}},
  journal  = {IEEE Access},
  title    = {Research on Malicious JavaScript Detection Technology Based on LSTM},
  year     = {2018},
  volume   = {6},
  number   = {},
  pages    = {59118-59125},
  keywords = {Malware;Feature extraction;Browsers;Engines;Web pages;Semantics;Bills of materials;JavaScript;malicious code detection;bytecode;word vector;LSTM},
  doi      = {10.1109/ACCESS.2018.2874098},
  issn     = {2169-3536},
  month    = {}
}

@inproceedings{mulazzani2013fast,
  title        = {Fast and reliable browser identification with javascript engine fingerprinting},
  author       = {Mulazzani, Martin and Reschl, Philipp and Huber, Markus and Leithner, Manuel and Schrittwieser, Sebastian and Weippl, Edgar and Wien, FC},
  booktitle    = {Web 2.0 Workshop on Security and Privacy (W2SP)},
  volume       = {5},
  pages        = {4},
  year         = {2013},
  organization = {Citeseer}
}

@inproceedings{10.1145/3412841.3442001,
  author    = {Ko, Yoonseok and Rezk, Tamara and Serrano, Manuel},
  title     = {SecureJS Compiler: Portable Memory Isolation in JavaScript},
  year      = {2021},
  isbn      = {9781450381048},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3412841.3442001},
  doi       = {10.1145/3412841.3442001},
  abstract  = {The memory isolation mechanism plays an essential role to provide security enforcement in JavaScript programs. Existing secure interaction libraries such as Google Caja, SES, and VM2 rely on built-in memory isolation mechanisms provided by Node.js and browsers, yet most of the other engines such as JerryScript and Duktape, which are implementations for IoT devices, do not support such isolation mechanisms.In this paper, we report about the design and implementation of SecureJS, a portable JavaScript-to-JavaScript compiler that enforces memory isolation. As it only uses standard features, the compiled code it generates can be used by any JavaScript engine. We validated empirically the semantics preservation and memory isolation of SecureJS compiled programs by using 10,490 test programs of ECMAScript Test262 test suite. We also developed a novel experiment to evaluate memory isolation property of compiled code by instrumented JavaScript engines.},
  booktitle = {Proceedings of the 36th Annual ACM Symposium on Applied Computing},
  pages     = {1265–1274},
  numpages  = {10},
  keywords  = {compiler, JavaScript, memory isolation},
  location  = {Virtual Event, Republic of Korea},
  series    = {SAC '21}
}

@inproceedings{10.1145/3184558.3188736,
  author    = {Peguero, Ksenia and Zhang, Nan and Cheng, Xiuzhen},
  title     = {An Empirical Study of the Framework Impact on the Security of JavaScript Web Applications},
  year      = {2018},
  isbn      = {9781450356404},
  publisher = {International World Wide Web Conferences Steering Committee},
  address   = {Republic and Canton of Geneva, CHE},
  url       = {https://doi.org/10.1145/3184558.3188736},
  doi       = {10.1145/3184558.3188736},
  abstract  = {textitBackground: JavaScript frameworks are widely used to create client-side and server-side parts of contemporary web applications. Vulnerabilities like cross-site scripting introduce significant risks in web applications. textitAim: The goal of our study is to understand how the security features of a framework impact the security of the applications written using that framework. textitMethod: In this paper, we present four locations in an application, relative to the framework being used, where a mitigation can be applied. We perform an empirical study of JavaScript applications that use the three most common template engines: Jade/Pug, EJS, and Angular. Using automated and manual analysis of each group of applications, we identify the number of projects vulnerable to cross-site scripting, and the number of vulnerabilities in each project, based on the framework used. textitResults: We analyze the results to compare the number of vulnerable projects to the mitigation locations used in each framework and perform statistical analysis of confounding variables. textitConclusions: The location of the mitigation impacts the application's security posture, with mitigations placed within the framework resulting in more secure applications.},
  booktitle = {Companion Proceedings of the The Web Conference 2018},
  pages     = {753–758},
  numpages  = {6},
  keywords  = {framework analysis, template engines, web frameworks, web security, cross-site scripting, javascript security},
  location  = {Lyon, France},
  series    = {WWW '18}
}
@inproceedings{grosskurth2005reference,
  title        = {A reference architecture for web browsers},
  author       = {Grosskurth, Alan and Godfrey, Michael W},
  booktitle    = {21st IEEE International Conference on Software Maintenance (ICSM'05)},
  pages        = {661--664},
  year         = {2005},
  organization = {IEEE}
}

@article{GARCES2021111004,
  title    = {Three decades of software reference architectures: A systematic mapping study},
  journal  = {Journal of Systems and Software},
  volume   = {179},
  pages    = {111004},
  year     = {2021},
  issn     = {0164-1212},
  doi      = {https://doi.org/10.1016/j.jss.2021.111004},
  url      = {https://www.sciencedirect.com/science/article/pii/S0164121221001011},
  author   = {Lina Garcés and Silverio Martínez-Fernández and Lucas Oliveira and Pedro Valle and Claudia Ayala and Xavier Franch and Elisa Yumi Nakagawa},
  keywords = {Software architecture, Reference architecture, Systematic mapping, Secondary study},
  abstract = {Software reference architectures have played an essential role in software systems development due to the possibility of knowledge reuse. Although increasingly adopted by industry, these architectures are not yet completely understood. This work presents a panorama on existing software reference architectures, characterizing them according to their context, goals, perspectives, application domains, design approaches, and maturity, as well as the industry involvement for their construction. For this, we planned and conducted a systematic mapping study. During last decade, the number of reference architectures in very diverse application domains has increased, resulting from efforts of industry, academia, and through their collaborations. Academic reference architectures are oriented to facilitate the reuse of architectural and domain knowledge. The industry has focused on architectures for standardization with certain maturity level. However, the great amount of architectures studied in this work have been designed without following a systematic process, and they lack the maturity to be used in real software projects. Further investigations can be oriented to gathering empirical evidences, from different sources than academic data libraries, that allow to understand how references architectures have been constructed, utilized, and maintained during the whole software life-cycle.}
}

@article{goth2003addressing,
  title={Addressing the monoculture},
  author={Goth, Greg},
  journal={IEEE Security \& Privacy},
  volume={1},
  number={06},
  pages={8--10},
  year={2003},
  publisher={IEEE Computer Society}
}

@article{lala2009monoculture,
  title={It monoculture security risks and defenses},
  author={Lala, Jaynarayan H and Schneider, Fred B},
  journal={IEEE Security \& Privacy},
  volume={7},
  number={1},
  pages={12--13},
  year={2009},
  publisher={IEEE}
}



@misc{BREAKFastly,
    title= {{Global CDN Disruption}},
    howpublished = {\url{https://www.fastly.com/blog/summary-of-june-8-outage}},
    urldate = {2021-08-08},
    year={2021}
}


@misc{leftPad,
    title= {{How one programmer broke the internet by deleting a tiny piece of code}},
    howpublished = {\url{https://qz.com/646467/how-one-programmer-broke-the-internet-by-deleting-a-tiny-piece-of-code/}},
    urldate = {2022-05-20},
    year={2016}
}


@inproceedings{WARDuino2019,
 author = {Gurdeep Singh, Robbert and Scholliers, Christophe},
 title = {WARDuino: A Dynamic WebAssembly Virtual Machine for Programming Microcontrollers},
 booktitle = {Proceedings of the 16th ACM SIGPLAN International Conference on Managed Programming Languages and Runtimes},
 series = {MPLR 2019},
 year = {2019},
 isbn = {978-1-4503-6977-0},
 location = {Athens, Greece},
 pages = {27--36},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/3357390.3361029},
 doi = {10.1145/3357390.3361029},
 acmid = {3361029},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Arduino, Live Code Updates, Virtual Machine, WebAssembly},
}

@misc{Lic,
   author = {Cabrera Arteaga, Javier},
   institution = {KTH, Software and Computer systems, SCS},
   note = {QC 20220909},
   pages = {112},
   school = {KTH, Software and Computer systems, SCS},
   title = {Artificial Software Diversification for WebAssembly},
   series = {TRITA-EECS-AVL},
   number = {2022:52},
   keywords = {WebAssembly, LLVM, Software Diversity, Automatic Software Engineering, Security},
   abstract = {WebAssembly has become the fourth official web language, along with HTML, CSS and JavaScript since 2019. WebAssembly allows web browsers to execute existing programs or libraries written in other languages, such as C/C++ and Rust. In addition, WebAssembly evolves to be part of edge-cloud computing platforms. Despite being designed with security as a premise, WebAssembly is not exempt from vulnerabilities. Therefore, potential vulnerabilities and flaws are included in its distribution and execution, highlighting a software monoculture problem. On the other hand, while software diversity has been shown to mitigate monoculture, no diversification approach has been proposed for WebAssembly. This work proposes software diversity as a preemptive solution to mitigate software monoculture for WebAssembly. Besides, we provide implementations for our approaches, including a generic LLVM superdiversifier that potentially extends our ideas to other programming languages. We empirically demonstrate the impact of our approach by providing Randomization and Multivariant Execution (MVE) for WebAssembly. Our results show that our approaches can provide an automated end-to-end solution for the diversification of WebAssembly programs. The main contributions of this work are: We highlight the lack of diversification techniques for WebAssembly through an exhaustive literature review. We provide randomization and multivariant execution for WebAssembly with the implementation of two tools, CROW and MEWE respectively. We include constant inferring as a new code transformation to generate software diversification for WebAssembly. We empirically demonstrate the impact of our technique by evaluating the static and dynamic behavior of the generated diversification.  Our approaches harden observable properties commonly used to conduct attacks, such as static code analysis, execution traces, and execution time. },
   ISBN = {978-91-8040-327-6},
   year = {2022}
}


@ARTICLE{wasmmutate,
       author = {{Cabrera-Arteaga}, Javier and {Fitzgerald}, Nicholas and {Monperrus}, Martin and {Baudry}, Benoit},
        title = "{WASM-MUTATE: Fast and Effective Binary Diversification for WebAssembly}",
      journal = {arXiv e-prints},
     keywords = {Computer Science - Software Engineering},
         year = 2023,
        month = sep,
          eid = {arXiv:2309.07638},
        pages = {arXiv:2309.07638},
          doi = {10.48550/arXiv.2309.07638},
archivePrefix = {arXiv},
       eprint = {2309.07638},
 primaryClass = {cs.SE},
       adsurl = {https://ui.adsabs.harvard.edu/abs/2023arXiv230907638C},
      adsnote = {Provided by the SAO/NASA Astrophysics Data System}
}


@article{e-graph,
author = {Willsey, Max and Nandi, Chandrakana and Wang, Yisu Remy and Flatt, Oliver and Tatlock, Zachary and Panchekha, Pavel},
title = {Egg: Fast and Extensible Equality Saturation},
year = {2021},
issue_date = {January 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {POPL},
url = {https://doi.org/10.1145/3434304},
doi = {10.1145/3434304},
abstract = {An e-graph efficiently represents a congruence relation over many expressions. Although they were originally developed in the late 1970s for use in automated theorem provers, a more recent technique known as equality saturation repurposes e-graphs to implement state-of-the-art, rewrite-driven compiler optimizations and program synthesizers. However, e-graphs remain unspecialized for this newer use case. Equality saturation workloads exhibit distinct characteristics and often require ad-hoc e-graph extensions to incorporate transformations beyond purely syntactic rewrites. This work contributes two techniques that make e-graphs fast and extensible, specializing them to equality saturation. A new amortized invariant restoration technique called rebuilding takes advantage of equality saturation's distinct workload, providing asymptotic speedups over current techniques in practice. A general mechanism called e-class analyses integrates domain-specific analyses into the e-graph, reducing the need for ad hoc manipulation. We implemented these techniques in a new open-source library called egg. Our case studies on three previously published applications of equality saturation highlight how egg's performance and flexibility enable state-of-the-art results across diverse domains.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {23},
numpages = {29},
keywords = {e-graphs, equality saturation}
}


@ARTICLE{2017arXiv171104422S,
       author = {{Sasnauskas}, Raimondas and {Chen}, Yang and {Collingbourne}, Peter and {Ketema}, Jeroen and {Lup}, Gratian and {Taneja}, Jubi and {Regehr}, John},
        title = "{Souper: A Synthesizing Superoptimizer}",
      journal = {arXiv e-prints},
     keywords = {Computer Science - Programming Languages},
         year = 2017,
        month = nov,
          eid = {arXiv:1711.04422},
        pages = {arXiv:1711.04422},
          doi = {10.48550/arXiv.1711.04422},
archivePrefix = {arXiv},
       eprint = {1711.04422},
 primaryClass = {cs.PL},
       adsurl = {https://ui.adsabs.harvard.edu/abs/2017arXiv171104422S},
      adsnote = {Provided by the SAO/NASA Astrophysics Data System}

}


@misc{webassembly_runtime,
  title = {WebAssembly Specification: WebAssembly Runtime},
  author = {WebAssembly Community Group},
  year = {2021},
  note = {Version 1.0},
  url = {https://webassembly.github.io/spec/core/exec/runtime.html},
  howpublished = {\url{https://webassembly.github.io/spec/core/exec/runtime.html}}
}


@article{10.1145/3571207,
author = {Cao, David and Kunkel, Rose and Nandi, Chandrakana and Willsey, Max and Tatlock, Zachary and Polikarpova, Nadia},
title = {Babble: Learning Better Abstractions with E-Graphs and Anti-Unification},
year = {2023},
issue_date = {January 2023},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {7},
number = {POPL},
url = {https://doi.org/10.1145/3571207},
doi = {10.1145/3571207},
abstract = {Library learning compresses a given corpus of programs by extracting common structure from the corpus into reusable library functions. Prior work on library learning suffers from two limitations that prevent it from scaling to larger, more complex inputs. First, it explores too many candidate library functions that are not useful for compression. Second, it is not robust to syntactic variation in the input. We propose library learning modulo theory (LLMT), a new library learning algorithm that additionally takes as input an equational theory for a given problem domain. LLMT uses e-graphs and equality saturation to compactly represent the space of programs equivalent modulo the theory, and uses a novel e-graph anti-unification technique to find common patterns in the corpus more directly and efficiently. We implemented LLMT in a tool named babble. Our evaluation shows that babble achieves better compression orders of magnitude faster than the state of the art. We also provide a qualitative evaluation showing that babble learns reusable functions on inputs previously out of reach for library learning.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {14},
numpages = {29},
keywords = {anti-unification, e-graphs, library learning}
}


@inproceedings{10.1145/3488932.3517411,
author = {Rokicki, Thomas and Maurice, Cl\'{e}mentine and Botvinnik, Marina and Oren, Yossi},
title = {Port Contention Goes Portable: Port Contention Side Channels in Web Browsers},
year = {2022},
isbn = {9781450391405},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3488932.3517411},
doi = {10.1145/3488932.3517411},
abstract = {Microarchitectural side-channel attacks can derive secrets from the execution of vulnerable programs. Their implementation in web browsers represents a considerable extension of their attack surface, as a user simply browsing a malicious website, or even a malicious third-party advertisement in a benign cross-origin isolated website, can be a victim.In this paper, we present the first port contention side channel running entirely in a web browser, despite a highly challenging environment. Our attack can be used to build a cross-browser covert channel with a bit rate of 200bps, one order of magnitude above the state of the art, and has a spatial resolution of 1024 native instructions in a side-channel attack, a performance on-par with Prime+Probe attacks. We provide a framework to evaluate the port contention caused by WebAssembly instructions on Intel processors, allowing to increase the portability of port contention side channels. We conclude from our work that port contention attacks are not only fast, they are also less susceptible to noise than cache attacks, and are immune to countermeasures implemented in browsers as well as most side channel countermeasures, which target the cache in their vast majority.},
booktitle = {Proceedings of the 2022 ACM on Asia Conference on Computer and Communications Security},
pages = {1182–1194},
numpages = {13},
keywords = {javascript, side channel, web-assembly, cpu port contention},
location = {Nagasaki, Japan},
series = {ASIA CCS '22}
}

@inproceedings{10.1145/1480881.1480915,
author = {Tate, Ross and Stepp, Michael and Tatlock, Zachary and Lerner, Sorin},
title = {Equality Saturation: A New Approach to Optimization},
year = {2009},
isbn = {9781605583792},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1480881.1480915},
doi = {10.1145/1480881.1480915},
abstract = {Optimizations in a traditional compiler are applied sequentially, with each optimization destructively modifying the program to produce a transformed program that is then passed to the next optimization. We present a new approach for structuring the optimization phase of a compiler. In our approach, optimizations take the form of equality analyses that add equality information to a common intermediate representation. The optimizer works by repeatedly applying these analyses to infer equivalences between program fragments, thus saturating the intermediate representation with equalities. Once saturated, the intermediate representation encodes multiple optimized versions of the input program. At this point, a profitability heuristic picks the final optimized program from the various programs represented in the saturated representation. Our proposed way of structuring optimizers has a variety of benefits over previous approaches: our approach obviates the need to worry about optimization ordering, enables the use of a global optimization heuristic that selects among fully optimized programs, and can be used to perform translation validation, even on compilers other than our own. We present our approach, formalize it, and describe our choice of intermediate representation. We also present experimental results showing that our approach is practical in terms of time and space overhead, is effective at discovering intricate optimization opportunities, and is effective at performing translation validation for a realistic optimizer.},
booktitle = {Proceedings of the 36th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {264–276},
numpages = {13},
keywords = {compiler optimization, equality reasoning, intermediate representation},
location = {Savannah, GA, USA},
series = {POPL '09}
}





@article{EVASION,
title = {WebAssembly diversification for malware evasion},
journal = {Computers \& Security},
volume = {131},
pages = {103296},
year = {2023},
issn = {0167-4048},
doi = {https://doi.org/10.1016/j.cose.2023.103296},
url = {https://www.sciencedirect.com/science/article/pii/S0167404823002067},
author = {Javier Cabrera-Arteaga and Martin Monperrus and Tim Toady and Benoit Baudry},
keywords = {WebAssembly, Cryptojacking, Software diversification, Malware evasion},
abstract = {WebAssembly has become a crucial part of the modern web, offering a faster alternative to JavaScript in browsers. While boosting rich applications in browser, this technology is also very efficient to develop cryptojacking malware. This has triggered the development of several methods to detect cryptojacking malware. However, these defenses have not considered the possibility of attackers using evasion techniques. This paper explores how automatic binary diversification can support the evasion of WebAssembly cryptojacking detectors. We experiment with a dataset of 33 WebAssembly cryptojacking binaries and evaluate our evasion technique against two malware detectors: VirusTotal, a general-purpose detector, and MINOS, a WebAssembly-specific detector. Our results demonstrate that our technique can automatically generate variants of WebAssembly cryptojacking that evade the detectors in 90% of cases for VirusTotal and 100% for MINOS. Our results emphasize the importance of meta-antiviruses and diverse detection techniques and provide new insights into which WebAssembly code transformations are best suited for malware evasion. We also show that the variants introduce limited performance overhead, making binary diversification an effective technique for evasion.}
}



@inproceedings {Swivel,
author = {Shravan Narayan and Craig Disselkoen and Daniel Moghimi and Sunjay Cauligi and Evan Johnson and Zhao Gang and Anjo Vahldiek-Oberwagner and Ravi Sahita and Hovav Shacham and Dean Tullsen and Deian Stefan},
title = {Swivel: Hardening {WebAssembly} against Spectre},
booktitle = {30th USENIX Security Symposium (USENIX Security 21)},
year = {2021},
isbn = {978-1-939133-24-3},
pages = {1433--1450},
url = {https://www.usenix.org/conference/usenixsecurity21/presentation/narayan},
publisher = {USENIX Association},
month = aug,
}

%%%%%%% WASM SOTA

@INPROCEEDINGS{WasmA,
  author={Breitfelder, Florian and Roth, Tobias and Baumgärtner, Lars and Mezini, Mira},
  booktitle={2023 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER)}, 
  title={WasmA: A Static WebAssembly Analysis Framework for Everyone}, 
  year={2023},
  volume={},
  number={},
  pages={753-757},
  doi={10.1109/SANER56733.2023.00085}
}


@inproceedings{wassail,
  title={Wassail: a webassembly static analysis library},
  author={Sti{\'e}venart, Quentin and De Roover, Coen},
  booktitle={Fifth International Workshop on Programming Technology for the Future Web},
  year={2021}
}

@article{wasmati,
  title={Wasmati: An efficient static vulnerability scanner for WebAssembly},
  author={Brito, Tiago and Lopes, Pedro and Santos, Nuno and Santos, Jos{\'e} Fragoso},
  journal={Computers \& Security},
  volume={118},
  pages={102745},
  year={2022},
  publisher={Elsevier}
}

@inproceedings{Wasp,
  title={Concolic Execution for WebAssembly (Artifact)},
  author={Marques, Filipe and Fragoso Santos, Jos{\'e} and Santos, Nuno and Ad{\~a}o, Pedro},
  year={2022},
  organization={Schloss Dagstuhl-Leibniz-Zentrum f{\"u}r Informatik}
}

@article{Taintassembly,
  title={Taintassembly: Taint-based information flow control tracking for webassembly},
  author={Fu, William and Lin, Raymond and Inge, Daniel},
  journal={arXiv preprint arXiv:1802.01050},
  year={2018}
}

@inproceedings{Wasabi,
  title={Wasabi: A framework for dynamically analyzing webassembly},
  author={Lehmann, Daniel and Pradel, Michael},
  booktitle={Proceedings of the Twenty-Fourth International Conference on Architectural Support for Programming Languages and Operating Systems},
  pages={1045--1058},
  year={2019}
}

@article{Fuzzm,
  title={Fuzzm: Finding memory bugs through binary-only instrumentation and fuzzing of webassembly},
  author={Lehmann, Daniel and Torp, Martin Toldam and Pradel, Michael},
  journal={arXiv preprint arXiv:2110.15433},
  year={2021}
}

@inproceedings{Minesweeper,
  title={Minesweeper: An in-depth look into drive-by cryptocurrency mining and its defense},
  author={Konoth, Radhesh Krishnan and Vineti, Emanuele and Moonsamy, Veelasha and Lindorfer, Martina and Kruegel, Christopher and Bos, Herbert and Vigna, Giovanni},
  booktitle={Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security},
  pages={1714--1730},
  year={2018}
}
@inproceedings{MineThrottle,
  author = {Bian, Weikang and Meng, Wei and Zhang, Mingxue},
  title = {MineThrottle: Defending against Wasm In-Browser Cryptojacking},
  year = {2020},
  isbn = {9781450370233},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3366423.3380085},
  doi = {10.1145/3366423.3380085},
  abstract = {In-browser cryptojacking is an urgent threat to web users, where an attacker abuses the users’ computing resources without obtaining their consent. In-browser mining programs are usually developed in WebAssembly (Wasm) for its great performance. Several prior works have measured cryptojacking in the wild and proposed detection methods using static features and dynamic features. However, there exists no good defense mechanism within the user’s browser to stop the malicious drive-by mining behavior. In this work, we propose MineThrottle, a browser-based defense mechanism against Wasm cryptojacking. MineThrottle instruments Wasm code on the fly to detect mining behavior using block-level program profiling. It then throttles drive-by mining behavior based on a user-configurable policy. Our evaluation of MineThrottle with the Alexa top 1M websites demonstrates that it can accurately detect and mitigate in-browser cryptojacking with both a low false positive rate and a low false negative rate.},
  booktitle = {Proceedings of The Web Conference 2020},
  pages = {3112–3118},
  numpages = {7},
  keywords = {Cryptocurrency mining, WebAssembly, Cryptojacking},
  location = {Taipei, Taiwan},
  series = {WWW '20}
}

  
@inproceedings{musch2019new,
  title={New Kid on the Web: A Study on the Prevalence of WebAssembly in the Wild},
  author={Musch, Marius and Wressnegger, Christian and Johns, Martin and Rieck, Konrad},
  booktitle={Detection of Intrusions and Malware, and Vulnerability Assessment: 16th International Conference, DIMVA 2019, Gothenburg, Sweden, June 19--20, 2019, Proceedings 16},
  pages={23--42},
  year={2019},
  organization={Springer}
}


@inproceedings{MINOS,
  title={MINOS: A Lightweight Real-Time Cryptojacking Detection System.},
  author={Naseem, Faraz Naseem and Aris, Ahmet and Babun, Leonardo and Tekiner, Ege and Uluagac, A Selcuk},
  booktitle={NDSS},
  year={2021}
}



@inproceedings{SEISMIC,
  title={Seismic: Secure in-lined script monitors for interrupting cryptojacks},
  author={Wang, Wenhao and Ferrell, Benjamin and Xu, Xiaoyang and Hamlen, Kevin W and Hao, Shuang},
  booktitle={Computer Security: 23rd European Symposium on Research in Computer Security, ESORICS 2018, Barcelona, Spain, September 3-7, 2018, Proceedings, Part II 23},
  pages={122--142},
  year={2018},
  organization={Springer}
}

@inproceedings{Outguard,
  title={Outguard: Detecting in-browser covert cryptocurrency mining in the wild},
  author={Kharraz, Amin and Ma, Zane and Murley, Paul and Lever, Charles and Mason, Joshua and Miller, Andrew and Borisov, Nikita and Antonakakis, Manos and Bailey, Michael},
  booktitle={The World Wide Web Conference},
  pages={840--852},
  year={2019}
}

@inproceedings{MinerRay,
  title={Minerray: Semantics-aware analysis for ever-evolving cryptojacking detection},
  author={Romano, Alan and Zheng, Yunhui and Wang, Weihang},
  booktitle={Proceedings of the 35th IEEE/ACM International Conference on Automated Software Engineering},
  pages={1129--1140},
  year={2020}
}

@inproceedings{RAPID,
  title={Rapid: Resource and api-based detection against in-browser miners},
  author={Rodriguez, Juan D Parra and Posegga, Joachim},
  booktitle={Proceedings of the 34th Annual Computer Security Applications Conference},
  pages={313--326},
  year={2018}
}

%% Special this comes from Wang
@article{WANA,
  title={WANA: Symbolic execution of wasm bytecode for cross-platform smart contract vulnerability detection},
  author={Wang, Dong and Jiang, Bo and Chan, WK},
  journal={arXiv preprint arXiv:2007.15510},
  year={2020}
}

@inproceedings{WASAI,
  title={WASAI: uncovering vulnerabilities in Wasm smart contracts},
  author={Chen, Weimin and Sun, Zihan and Wang, Haoyu and Luo, Xiapu and Cai, Haipeng and Wu, Lei},
  booktitle={Proceedings of the 31st ACM SIGSOFT International Symposium on Software Testing and Analysis},
  pages={703--715},
  year={2022}
}

@INPROCEEDINGS{Avenger,

  author={Kim, Minseo and Jang, Hyerean and Shin, Youngjoo},

  booktitle={2022 IEEE 15th International Conference on Cloud Computing (CLOUD)}, 

  title={Avengers, Assemble! Survey of WebAssembly Security Solutions}, 

  year={2022},

  volume={},

  number={},

  pages={543-553},

  doi={10.1109/CLOUD55607.2022.00077}}


  


@ARTICLE{wasmixer,
       author = {{Cao}, Shangtong and {He}, Ningyu and {Guo}, Yao and {Wang}, Haoyu},
        title = "{WASMixer: Binary Obfuscation for WebAssembly}",
      journal = {arXiv e-prints},
     keywords = {Computer Science - Cryptography and Security},
         year = 2023,
        month = aug,
          eid = {arXiv:2308.03123},
        pages = {arXiv:2308.03123},
          doi = {10.48550/arXiv.2308.03123},
archivePrefix = {arXiv},
       eprint = {2308.03123},
 primaryClass = {cs.CR},
       adsurl = {https://ui.adsabs.harvard.edu/abs/2023arXiv230803123C},
      adsnote = {Provided by the SAO/NASA Astrophysics Data System}
}


@article{ctwasm,
  author = {Watt, Conrad and Renner, John and Popescu, Natalie and Cauligi, Sunjay and Stefan, Deian},
  title = {CT-Wasm: Type-Driven Secure Cryptography for the Web Ecosystem},
  year = {2019},
  issue_date = {January 2019},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {3},
  number = {POPL},
  url = {https://doi.org/10.1145/3290390},
  doi = {10.1145/3290390},
  abstract = {A significant amount of both client and server-side cryptography is implemented in JavaScript. Despite widespread concerns about its security, no other language has been able to match the convenience that comes from its ubiquitous support on the "web ecosystem" - the wide variety of technologies that collectively underpins the modern World Wide Web. With the introduction of the new WebAssembly bytecode language (Wasm) into the web ecosystem, we have a unique opportunity to advance a principled alternative to existing JavaScript cryptography use cases which does not compromise this convenience. We present Constant-Time WebAssembly (CT-Wasm), a type-driven, strict extension to WebAssembly which facilitates the verifiably secure implementation of cryptographic algorithms. CT-Wasm's type system ensures that code written in CT-Wasm is both information flow secure and resistant to timing side channel attacks; like base Wasm, these guarantees are verifiable in linear time. Building on an existing Wasm mechanization, we mechanize the full CT-Wasm specification, prove soundness of the extended type system, implement a verified type checker, and give several proofs of the language's security properties. We provide two implementations of CT-Wasm: an OCaml reference interpreter and a native implementation for Node.js and Chromium that extends Google's V8 engine. We also implement a CT-Wasm to Wasm rewrite tool that allows developers to reap the benefits of CT-Wasm's type system today, while developing cryptographic algorithms for base Wasm environments. We evaluate the language, our implementations, and supporting tools by porting several cryptographic primitives - Salsa20, SHA-256, and TEA - and the full TweetNaCl library. We find that CT-Wasm is fast, expressive, and generates code that we experimentally measure to be constant-time.},
  journal = {Proc. ACM Program. Lang.},
  month = {jan},
  articleno = {77},
  numpages = {29},
  keywords = {cryptography, constant-time, information flow control, WebAssembly}
}

@inproceedings{trufflewasm,
  author = {Salim, Salim S. and Nisbet, Andy and Luj\'{a}n, Mikel},
  title = {TruffleWasm: A WebAssembly Interpreter on GraalVM},
  year = {2020},
  isbn = {9781450375542},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3381052.3381325},
  doi = {10.1145/3381052.3381325},
  abstract = {WebAssembly is a binary format originally designed for web-based deployment and execution combined with JavaScript. WebAssembly can also be used for standalone programs provided a WebAssembly runtime environment is available.This paper describes the design and implementation of TruffleWasm, a guest language implementation of a WebAssembly hosted on Truffle and GraalVM. Truffle is a Java framework capable of constructing and interpreting an Abstract Syntax Tree (AST) representing a program on standard JVMs. GraalVM is a JVM with a JIT compiler which optimises the execution of ASTs from Truffle.Our work is motivated by trying to understand the advantages and disadvantages of using GraalVM, and its support for multiple programming languages, to build a standalone WebAssembly runtime. This contrast with developing a new runtime, as Wasmtime and other projects are undertaking. TruffleWasm can execute standalone WebAssembly modules, while offering also interoperability with other GraalVM hosted languages, such as Java, JavaScript, R, Python and Ruby.The experimental results compare the peak performance of TruffleWasm to the standalone Wasmtime runtime for the Shootout, C benchmarks in JetStream, and the Poly-BenchC benchmarks. The results show the geo-mean peak performance of TruffleWasm is 4\% slower than Wasmtime for Shootout/JetStream, and 4\% faster for PolyBenchC.},
  booktitle = {Proceedings of the 16th ACM SIGPLAN/SIGOPS International Conference on Virtual Execution Environments},
  pages = {88–100},
  numpages = {13},
  keywords = {Wasm, just in time compilation, JVM, WebAssembly, GraalVM},
  location = {Lausanne, Switzerland},
  series = {VEE '20}
}
  
@INPROCEEDINGS{wave,

  author={Johnson, Evan and Laufer, Evan and Zhao, Zijie and Gohman, Dan and Narayan, Shravan and Savage, Stefan and Stefan, Deian and Brown, Fraser},

  booktitle={2023 IEEE Symposium on Security and Privacy (SP)}, 

  title={WaVe: a verifiably secure WebAssembly sandboxing runtime}, 

  year={2023},

  volume={},

  number={},

  pages={2940-2955},

  doi={10.1109/SP46215.2023.10179357}}



@inproceedings{slicing,
  title={Dynamic Slicing of WebAssembly Binaries},
  author={Sti{\'e}venart, Quentin and Binkley, David and De Roover, Coen},
  booktitle={39th IEEE International Conference on Software Maintenance and Evolution},
  year={2023},
  organization={IEEE}
}

@inproceedings{slicing2,
  author = {Sti\'{e}venart, Quentin and Binkley, David W. and De Roover, Coen},
  title = {Static Stack-Preserving Intra-Procedural Slicing of Webassembly Binaries},
  year = {2022},
  isbn = {9781450392211},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3510003.3510070},
  doi = {10.1145/3510003.3510070},
  abstract = {The recently introduced WebAssembly standard aims to be a portable compilation target, enabling the cross-platform distribution of programs written in a variety of languages. We propose an approach to slice WebAssembly programs in order to enable applications in reverse engineering, code comprehension, and security among others. Given a program and a location in that program, program slicing produces a minimal version of the program that preserves the behavior at the given location. Specifically, our approach is a static, intra-procedural, backward slicing approach that takes into account WebAssembly-specific dependences to identify the instructions of the slice. To do so it must correctly overcome the considerable challenges of performing dependence analysis at the binary level. Furthermore, for the slice to be executable, the approach needs to ensure that the stack behavior of its output complies with WebAssembly's validation requirements. We implemented and evaluated our approach on a suite of 8 386 real-world WebAssembly binaries, finding that the average size of the 495 204 868 slices computed is 53\% of the original code, an improvement over the 60\% attained by related work slicing ARM binaries. To gain a more qualitative understanding of the slices produced by our approach, we compared them to 1 956 source-level slices of benchmark C programs. This inspection helps to illustrate the slicer's strengths and to uncover potential future improvements.},
  booktitle = {Proceedings of the 44th International Conference on Software Engineering},
  pages = {2031–2042},
  numpages = {12},
  keywords = {webassembly, binary analysis, static program slicing},
  location = {Pittsburgh, Pennsylvania},
  series = {ICSE '22}
}

@article{veriwasm,
place = {Country unknown/Code not available}, title = {Доверя́й, но проверя́й: SFI safety for native-compiled Wasm}, url = {https://par.nsf.gov/biblio/10228509}, DOI = {10.14722/ndss.2021.24078}, abstractNote = {WebAssembly (Wasm) is a platform-independent bytecode that offers both good performance and runtime isolation. To implement isolation, the compiler inserts safety checks when it compiles Wasm to native machine code. While this approach is cheap, it also requires trust in the compiler's correctness---trust that the compiler has inserted each necessary check, correctly formed, in each proper place. Unfortunately, subtle bugs in the Wasm compiler can break---and have broken---isolation guarantees. To address this problem, we propose verifying memory isolation of Wasm binaries post-compilation. We implement this approach in VeriWasm, a static offline verifier for native x86-64 binaries compiled from Wasm; we prove the verifier's soundness, and find that it can detect bugs with no false positives. Finally, we describe our deployment of VeriWasm at Fastly.}, journal = {Network and Distributed Systems Security (NDSS) Symposium}, author = {Johnson, Evan and Thien, David and Alhessi, Yousef and Narayan, Shravan and Brown, Fraser and Lerner, Sorin and McMullen, Tyler and Savage, Stefan and Stefan, Deian},
year={2021}
 }
  

@inproceedings{wafl,
  title={Wafl: Binary-only webassembly fuzzing with fast snapshots},
  author={Ha{\ss}ler, Keno and Maier, Dominik},
  booktitle={Reversing and Offensive-oriented Trends Symposium},
  pages={23--30},
  year={2021}
}

@inproceedings{wasmfuzzer,
  title={Wasmfuzzer: A fuzzer for webassembly virtual machines},
  author={Jiang, Bo and Li, Zichao and Huang, Yuhe and Zhang, Zhenyu and Chan, W},
  booktitle={34th International Conference on Software Engineering and Knowledge Engineering, SEKE 2022},
  pages={537--542},
  year={2022},
  organization={KSI Research Inc.}
}

@InProceedings{secwasm,
  author="Bastys, Iulia
  and Algehed, Maximilian
  and Sj{\"o}sten, Alexander
  and Sabelfeld, Andrei",
  editor="Singh, Gagandeep
  and Urban, Caterina",
  title="SecWasm: Information Flow Control for WebAssembly",
  booktitle="Static Analysis",
  year="2022",
  publisher="Springer Nature Switzerland",
  address="Cham",
  pages="74--103",
  abstract="We introduce SecWasm, the first general purpose information-flow control system for WebAssembly (Wasm), thus extending the safety guarantees offered by Wasm with guarantees that applications manipulate sensitive data in a secure way. SecWasm is a hybrid system enforcing termination-insensitive noninterference which overcomes the challenges posed by the uncommon characteristics for machine languages of Wasm in an elegant and thorough way.",
  isbn="978-3-031-22308-2"
}

@inproceedings{EOSAFE,
  title={$\{$EOSAFE$\}$: security analysis of $\{$EOSIO$\}$ smart contracts},
  author={He, Ningyu and Zhang, Ruiyi and Wang, Haoyu and Wu, Lei and Luo, Xiapu and Guo, Yao and Yu, Ting and Jiang, Xuxian},
  booktitle={30th USENIX Security Symposium (USENIX Security 21)},
  pages={1271--1288},
  year={2021}
}

@inproceedings{EOSFuzzer,
  title={EOSFuzzer: Fuzzing eosio smart contracts for vulnerability detection},
  author={Huang, Yuhe and Jiang, Bo and Chan, Wing Kwong},
  booktitle={Proceedings of the 12th Asia-Pacific Symposium on Internetware},
  pages={99--109},
  year={2020}
}

@InProceedings{BREWasm,
  author="Cao, Shangtong
  and He, Ningyu
  and Guo, Yao
  and Wang, Haoyu",
  editor="Hermenegildo, Manuel V.
  and Morales, Jos{\'e} F.",
  title="BREWasm: A General Static Binary Rewriting Framework for WebAssembly",
  booktitle="Static Analysis",
  year="2023",
  publisher="Springer Nature Switzerland",
  address="Cham",
  pages="139--163",
  abstract="Binary rewriting is a widely adopted technique in software analysis. WebAssembly (Wasm), as an emerging bytecode format, has attracted great attention from our community. Unfortunately, there is no general-purpose binary rewriting framework for Wasm, and existing effort on Wasm binary modification is error-prone and tedious. In this paper, we present BREWasm, the first general purpose static binary rewriting framework for Wasm, which has addressed inherent challenges of Wasm rewriting including high complicated binary structure, strict static syntax verification, and coupling among sections. We perform extensive evaluation on diverse Wasm applications to show the efficiency, correctness and effectiveness of BREWasm. We further show the promising direction of implementing a diverse set of binary rewriting tasks based on BREWasm in an effortless and user-friendly manner.",
isbn="978-3-031-44245-2"
}




@inproceedings{DBLP:conf/ndss/SchnitzlerKBP23,
  author       = {Theodor Schnitzler and
                  Katharina Kohls and
                  Evangelos Bitsikas and
                  Christina P{\"{o}}pper},
  title        = {Hope of Delivery: Extracting User Locations From Mobile Instant Messengers},
  booktitle    = {30th Annual Network and Distributed System Security Symposium, {NDSS}
                  2023, San Diego, California, USA, February 27 - March 3, 2023},
  publisher    = {The Internet Society},
  year         = {2023},
  url          = {https://www.ndss-symposium.org/ndss-paper/hope-of-delivery-extracting-user-locations-from-mobile-instant-messengers/},
  timestamp    = {Thu, 15 Jun 2023 16:53:22 +0200},
  biburl       = {https://dblp.org/rec/conf/ndss/SchnitzlerKBP23.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@article{10.1145/3282510,
author = {Rossberg, Andreas and Titzer, Ben L. and Haas, Andreas and Schuff, Derek L. and Gohman, Dan and Wagner, Luke and Zakai, Alon and Bastien, J. F. and Holman, Michael},
title = {Bringing the Web up to Speed with WebAssembly},
year = {2018},
issue_date = {December 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {61},
number = {12},
issn = {0001-0782},
url = {https://doi.org/10.1145/3282510},
doi = {10.1145/3282510},
journal = {Commun. ACM},
month = {nov},
pages = {107–115},
numpages = {9}
}

  

@inproceedings{ret2spec,
author = {Maisuradze, Giorgi and Rossow, Christian},
title = {Ret2spec: Speculative Execution Using Return Stack Buffers},
year = {2018},
isbn = {9781450356930},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3243734.3243761},
doi = {10.1145/3243734.3243761},
abstract = {Speculative execution is an optimization technique that has been part of CPUs for over a decade. It predicts the outcome and target of branch instructions to avoid stalling the execution pipeline. However, until recently, the security implications of speculative code execution have not been studied. In this paper, we investigate a special type of branch predictor that is responsible for predicting return addresses. To the best of our knowledge, we are the first to study return address predictors and their consequences for the security of modern software. In our work, we show how return stack buffers (RSBs), the core unit of return address predictors, can be used to trigger misspeculations. Based on this knowledge, we propose two new attack variants using RSBs that give attackers similar capabilities as the documented Spectre attacks. We show how local attackers can gain arbitrary speculative code execution across processes, e.g., to leak passwords another user enters on a shared system. Our evaluation showed that the recent Spectre countermeasures deployed in operating systems can also cover such RSB-based cross-process attacks. Yet we then demonstrate that attackers can trigger misspeculation in JIT environments in order to leak arbitrary memory content of browser processes. Reading outside the sandboxed memory region with JIT-compiled code is still possible with 80\% accuracy on average.},
booktitle = {Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security},
pages = {2109–2122},
numpages = {14},
keywords = {side channel attacks, javascript, hardware security},
location = {Toronto, Canada},
series = {CCS '18}
}

  



@misc { solomon,
    url={https://twitter.com/solomonstre/status/1111004913222324225},
    date={2019-03-27},
    urldate={2023-10-01},
    year={2019},
    title={Tweet},
    author={Solomon Hykes}
}

@misc { clark,
    url={https://hacks.mozilla.org/2017/02/what-makes-webassembly-fast/},
    date={2017-02-28},
    urldate={2023-10-01},
    year={2017},
    title={What makes WebAssembly fast?},
    author={Lin Clark}
}


@misc { kasperksy,
    url={https://securelist.com/cryptojacking-report-2022/107898/},
    date={2022-11-10},
    urldate={2022-11-27},
    year={2022},
    title={The state of cryptojacking in the first three quarters of 2022},
    author={Kaspersky} 
}


@misc{ firefoxcrypto,
    title={{Protections Against Fingerprinting and Cryptocurrency Mining Available in Firefox Nightly and Beta }},
    url={{https://blog.mozilla.org/futurereleases/2019/04/09/protections-against-fingerprinting-and-cryptocurrency-mining-available-in-firefox-nightly-and-beta/}},
    urldate= {2023-02-14},
    date={2019-04-09},
    year={2019},
    author={Mozilla}
}


@article{HOSSEINZADEH201872,
  title = {Diversification and obfuscation techniques for software security: A systematic literature review},
  journal = {Information and Software Technology},
  volume = {104},
  year = {2018},
  issn = {0950-5849},
  doi = {https://doi.org/10.1016/j.infsof.2018.07.007},
  url = {https://www.sciencedirect.com/science/article/pii/S0950584918301484},
  author = {Shohreh Hosseinzadeh and Sampsa Rauti and Samuel Laurén and Jari-Matti Mäkelä and Johannes Holvitie and Sami Hyrynsalmi and Ville Leppänen},
  keywords = {Diversification, Obfuscation, Software security, Systematic literature review},
  abstract = {Context: Diversification and obfuscation are promising techniques for securing software and protecting computers from harmful malware. The goal of these techniques is not removing the security holes, but making it difficult for the attacker to exploit security vulnerabilities and perform successful attacks. Objective: There is an increasing body of research on the use of diversification and obfuscation techniques for improving software security; however, the overall view is scattered and the terminology is unstructured. Therefore, a coherent review gives a clear statement of state-of-the-art, normalizes the ongoing discussion and provides baselines for future research. Method: In this paper, systematic literature review is used as the method of the study to select the studies that discuss diversification/obfuscation techniques for improving software security. We present the process of data collection, analysis of data, and report the results. Results: As the result of the systematic search, we collected 357 articles relevant to the topic of our interest, published between the years 1993 and 2017. We studied the collected articles, analyzed the extracted data from them, presented classification of the data, and enlightened the research gaps. Conclusion: The two techniques have been extensively used for various security purposes and impeding various types of security attacks. There exist many different techniques to obfuscate/diversify programs, each of which targets different parts of the programs and is applied at different phases of software development life-cycle. Moreover, we pinpoint the research gaps in this field, for instance that there are still various execution environments that could benefit from these two techniques, including cloud computing, Internet of Things (IoT), and trusted computing. We also present some potential ideas on applying the techniques on the discussed environments.}
}



@INPROCEEDINGS{Spectre,
  author={Kocher, Paul and Horn, Jann and Fogh, Anders and Genkin, Daniel and Gruss, Daniel and Haas, Werner and Hamburg, Mike and Lipp, Moritz and Mangard, Stefan and Prescher, Thomas and Schwarz, Michael and Yarom, Yuval},
  booktitle={2019 IEEE Symposium on Security and Privacy (SP)}, 
  title={Spectre Attacks: Exploiting Speculative Execution}, 
  year={2019},
  volume={},
  number={},
  pages={1-19},
  doi={10.1109/SP.2019.00002}}



@inproceedings{lettner2018partisan,
  title={PartiSan: fast and flexible sanitization via run-time partitioning},
  author={Lettner, Julian and Song, Dokyung and Park, Taemin and Larsen, Per and Volckaert, Stijn and Franz, Michael},
  booktitle={International Symposium on Research in Attacks, Intrusions, and Defenses},
  pages={403--422},
  year={2018},
  organization={Springer}
}


@inproceedings{10.1145/3593434.3593454,
author = {Wagner, Linus and Mayer, Maximilian and Marino, Andrea and Soldani Nezhad, Alireza and Zwaan, Hugo and Malavolta, Ivano},
title = {On the Energy Consumption and Performance of WebAssembly Binaries across Programming Languages and Runtimes in IoT},
year = {2023},
isbn = {9798400700446},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3593434.3593454},
doi = {10.1145/3593434.3593454},
abstract = {Context. WebAssembly (WASM) is a low-level bytecode format that is gaining traction among Internet of Things (IoT) devices. Because of IoT devices’ resources limitations, using WASM is becoming a popular technique for virtualization on IoT devices. However, it is unclear if the promises of WASM regarding its efficient use of energy and performance gains hold true. Goal. This study aims to determine how different source programming languages and runtime environments affect the energy consumption and performance of WASM binaries. Method. We perform a controlled experiment where we compile three benchmarking algorithms from four different programming languages (i.e., C, Rust, Go, and JavaScript) to WASM and run them using two different WASM runtimes on a Raspberry Pi 3B. Results. The source programming language significantly influences the performance and energy consumption of WASM binaries. We did not find evidence of the impact of the runtime environment. However, certain combinations of source programming language and runtime environment leads to a significant improvement of its energy consumption and performance. Conclusions. IoT developers should choose the source programming language wisely to benefit from better performance and a reduction in energy consumption. Specifically, Javy-compiled JavaScript should be avoided, while C and Rust are better options. We found no conclusive results for the choice of the WASM runtime.},
booktitle = {Proceedings of the 27th International Conference on Evaluation and Assessment in Software Engineering},
pages = {72–82},
numpages = {11},
location = {Oulu, Finland},
series = {EASE '23}
}

@INPROCEEDINGS{Vivienne,

  author={Tsoupidi, Rodothea Myrsini and Balliu, Musard and Baudry, Benoit},

  booktitle={2021 IEEE Secure Development Conference (SecDev)}, 

  title={Vivienne: Relational Verification of Cryptographic Implementations in WebAssembly}, 

  year={2021},

  volume={},

  number={},

  pages={94-102},

  doi={10.1109/SecDev51306.2021.00029}}


@inproceedings{makitalo2021webassembly,
  title={WebAssembly modules as lightweight containers for liquid IoT applications},
  author={M{\"a}kitalo, Niko and Mikkonen, Tommi and Pautasso, Cesare and Bankowski, Victor and Daubaris, Paulius and Mikkola, Risto and Beletski, Oleg},
  booktitle={International Conference on Web Engineering},
  pages={328--336},
  year={2021},
  organization={Springer}
}


@ARTICLE{9524529,

author={Chen, Huashan and Cam, Hasan and Xu, Shouhuai},

journal={IEEE Transactions on Dependable and Secure Computing}, 

title={Quantifying Cybersecurity Effectiveness of Dynamic Network Diversity}, 

year={2022},

volume={19},

number={6},

pages={3804-3821},

doi={10.1109/TDSC.2021.3107514}}


@inproceedings{10.1145/3492321.3519558,
author = {Vinck, Jonas and Abrath, Bert and Coppens, Bart and Voulimeneas, Alexios and De Sutter, Bjorn and Volckaert, Stijn},
title = {Sharing is Caring: Secure and Efficient Shared Memory Support for MVEEs},
year = {2022},
isbn = {9781450391627},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3492321.3519558},
doi = {10.1145/3492321.3519558},
abstract = {Multi-Variant Execution Environments (MVEEs) are a powerful tool for protecting legacy software against memory corruption attacks. MVEEs employ software diversity to run multiple variants of the same program in lockstep, whilst providing them with the same inputs and comparing their behavior. Well-constructed variants will behave equivalently under normal operating conditions but diverge when under attack. The MVEE detects these divergences and takes action before compromised variants can damage the host system.Existing MVEEs replicate inputs at the system call boundary, and therefore do not support programs that use shared-memory IPC with other processes, since shared memory pages can be read from and written to directly without system calls.We analyzed modern applications, ranging from web servers, over media players, to browsers, and observe that they rely heavily on shared memory, in some cases for their basic functioning and in other cases for enabling more advanced functionality. It follows that modern applications cannot enjoy the security provided by MVEEs unless those MVEEs support shared-memory IPC.This paper first identifies the requirements for supporting shared-memory IPC in an MVEE. We propose a design that involves techniques to identify and instrument accesses to shared memory pages, as well as techniques to replicate I/O through shared-memory IPC. We implemented these techniques in a prototype MVEE and report our findings through an evaluation of a range of benchmark programs. Our contributions enable the use of MVEEs on a far wider range of programs than previously supported. By overcoming one of the major remaining limitations of MVEEs, our contributions can help to bolster their real-world adoption.},
booktitle = {Proceedings of the Seventeenth European Conference on Computer Systems},
pages = {99–116},
numpages = {18},
keywords = {shared memory, OS, security},
location = {Rennes, France},
series = {EuroSys '22}
}



@article{avizienis1995methodology,
  title={The methodology of n-version programming},
  author={Avizienis, Algirdas},
  journal={Software fault tolerance},
  volume={3},
  pages={23--46},
  year={1995},
  publisher={John Wiley \& Sons, New York}
}


@article{debloating4evasion,
  author = {Gen\c{c}, Ziya Alper and Lenzini, Gabriele and Sgandurra, Daniele},
  title = {Cut-and-Mouse and Ghost Control: Exploiting Antivirus Software with Synthesized Inputs},
  year = {2021},
  issue_date = {March 2021},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {2},
  number = {1},
  url = {https://doi.org/10.1145/3431286},
  doi = {10.1145/3431286},
  abstract = {To protect their digital assets from malware attacks, most users and companies rely on antivirus (AV) software. AVs’ protection is a full-time task against malware: This is similar to a game where malware, e.g., through obfuscation and polymorphism, denial of service attacks, and malformed packets and parameters, tries to circumvent AV defences or make them crash. However, AVs react by complementing signature-based detection with anomaly or behavioral analysis, and by using OS protection, standard code, and binary protection techniques. Further, malware counter-acts, for instance, by using adversarial inputs to avoid detection, and so on. In this cat-and-mouse game, a winning strategy is trying to anticipate the move of the adversary by looking into one’s own weaknesses, seeing how the adversary can penetrate them, and building up appropriate defences or attacks. In this article, we play the role of malware developers and anticipate two novel moves for the malware side to demonstrate the weakness in the AVs and to improve the defences in AVs’ side. The first one consists in simulating mouse events to control AVs, namely, to send them mouse “clicks” to deactivate their protection. We prove that many AVs can be disabled in this way, and we call this class of attacks Ghost Control. The second one consists in controlling whitelisted applications, such as Notepad, by sending them keyboard events (such as “copy-and-paste”) to perform malicious operations on behalf of the malware. We prove that the anti-ransomware protection feature of AVs can be bypassed if we use Notepad as a “puppet” to rewrite the content of protected files as a ransomware would do. Playing with the words, and recalling the cat-and-mouse game, we call this class of attacks Cut-and-Mouse. We tested these two attacks on 29 AVs, and the results show that 14 AVs are vulnerable to Ghost Control attack while all 29 AV programs tested are found vulnerable to Cut-and-Mouse. Furthermore, we also show some weaknesses in additional protection mechanisms of AVs, such as sandboxing and CAPTCHA verification. We have engaged with the affected AV companies, and we reported the disclosure communication with them and their responses.},
  journal = {Digital Threats},
  month = {feb},
  articleno = {4},
  numpages = {23},
  keywords = {simulate mouse, vulnerability, ransomware, evasion, synthesize inputs, Antivirus}
}

@inproceedings{sinatra,
  author       = {Ugnius Rumsevicius and
                  Siddhanth Venkateshwaran and
                  Ellen Kidane and
                  Lu{\'{\i}}s Pina},
  editor       = {Karim Ali and
                  Guido Salvaneschi},
  title        = {Sinatra: Stateful Instantaneous Updates for Commercial Browsers Through
                  Multi-Version eXecution},
  booktitle    = {37th European Conference on Object-Oriented Programming, {ECOOP} 2023,
                  July 17-21, 2023, Seattle, Washington, United States},
  series       = {LIPIcs},
  volume       = {263},
  pages        = {26:1--26:29},
  publisher    = {Schloss Dagstuhl - Leibniz-Zentrum f{\"{u}}r Informatik},
  year         = {2023},
  url          = {https://doi.org/10.4230/LIPIcs.ECOOP.2023.26},
  doi          = {10.4230/LIPIcs.ECOOP.2023.26},
  timestamp    = {Tue, 11 Jul 2023 17:14:10 +0200},
  biburl       = {https://dblp.org/rec/conf/ecoop/RumseviciusVKP23.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{cornucopia,
  author = {Singhal, Vidush and Pillai, Akul Abhilash and Saumya, Charitha and Kulkarni, Milind and Machiry, Aravind},
  title = {Cornucopia : A Framework for Feedback Guided Generation of Binaries},
  year = {2023},
  isbn = {9781450394758},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3551349.3561152},
  doi = {10.1145/3551349.3561152},
  abstract = {Binary analysis is an important capability required for many security and software engineering applications. Consequently, there are many binary analysis techniques and tools with varied capabilities. However, testing these tools requires a large, varied binary dataset with corresponding source-level information. In this paper, we present Cornucopia, an architecture agnostic automated framework that can generate a plethora of binaries from corresponding program source by exploiting compiler optimizations and feedback-guided learning. Our evaluation shows that Cornucopia was able to generate 309K binaries across four architectures (x86, x64, ARM, MIPS) with an average of 403 binaries for each program and outperforms BinTuner  [53], a similar technique. Our experiments revealed issues with the LLVM optimization scheduler resulting in compiler crashes (∼ 300). Our evaluation of four popular binary analysis tools angr, Ghidra, ida, and radare, using Cornucopia generated binaries, revealed various issues with these tools. Specifically, we found 263 crashes in angr and one memory corruption issue in ida. Our differential testing on the analysis results revealed various semantic bugs in these tools. We also tested machine learning tools, Asm2Vec, SAFE, and Debin, that claim to capture binary semantics and show that they perform poorly (e.g., Debin F1 score dropped to 12.9\% from reported 63.1\%) on Cornucopia generated binaries. In summary, our exhaustive evaluation shows that Cornucopia is an effective mechanism to generate binaries for testing binary analysis techniques effectively.},
  booktitle = {Proceedings of the 37th IEEE/ACM International Conference on Automated Software Engineering},
  articleno = {27},
  numpages = {13},
  keywords = {Fuzzing, Compiler Optimizations, Binary Code Difference, Automated Binary Generation},
  location = {Rochester, MI, USA},
  series = {ASE '22}
}

  

@Article{cryptography4020013,
AUTHOR = {Bow, Ivan and Bete, Nahome and Saqib, Fareena and Che, Wenjie and Patel, Chintan and Robucci, Ryan and Chan, Calvin and Plusquellic, Jim},
TITLE = {Side-Channel Power Resistance for Encryption Algorithms Using Implementation Diversity},
JOURNAL = {Cryptography},
VOLUME = {4},
YEAR = {2020},
NUMBER = {2},
ARTICLE-NUMBER = {13},
URL = {https://www.mdpi.com/2410-387X/4/2/13},
ISSN = {2410-387X},
ABSTRACT = {This paper investigates countermeasures to side-channel attacks. A dynamic partial reconfiguration (DPR) method is proposed for field programmable gate arrays (FPGAs)s to make techniques such as differential power analysis (DPA) and correlation power analysis (CPA) difficult and ineffective. We call the technique side-channel power resistance for encryption algorithms using DPR, or SPREAD. SPREAD is designed to reduce cryptographic key related signal correlations in power supply transients by changing components of the hardware implementation on-the-fly using DPR. Replicated primitives within the advanced encryption standard (AES) algorithm, in particular, the substitution-box (SBOX)s, are synthesized to multiple and distinct gate-level implementations. The different implementations change the delay characteristics of the SBOXs, reducing correlations in the power traces, which, in turn, increases the difficulty of side-channel attacks. The effectiveness of the proposed countermeasures depends greatly on this principle; therefore, the focus of this paper is on the evaluation of implementation diversity techniques.},
DOI = {10.3390/cryptography4020013}
}

@inproceedings{payer2014embracing,
  title={Embracing the new threat: Towards automatically self-diversifying malware},
  author={Payer, Mathias},
  year={2014}
}



@INPROCEEDINGS{8714698,

  author={Castro, Raphael Labaca and Schmitt, Corinna and Rodosek, Gabi Dreo},

  booktitle={2019 5th International Conference on Information Management (ICIM)}, 

  title={ARMED: How Automatic Malware Modifications Can Evade Static Detection?}, 

  year={2019},

  volume={},

  number={},

  pages={20-27},

  doi={10.1109/INFOMAN.2019.8714698}}


@inproceedings{offensive_div,
  author = {Lundquist, Gilmore R. and Mohan, Vishwath and Hamlen, Kevin W.},
  title = {Searching for Software0 Diversity: Attaining Artificial Diversity through Program Synthesis},
  year = {2016},
  isbn = {9781450348133},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3011883.3011891},
  doi = {10.1145/3011883.3011891},
  abstract = {A means of attaining richer, more comprehensive forms of software diversity on a mass scale is proposed through leveraging and repurposing a closely related, yet heretofore untapped, line of computer science research---automatic program synthesis. It is argued that the search-based methodologies presently used for obtaining implementations from specifications can be broadened relatively easily to a search for many candidate solutions, potentially diversifying the software monoculture. Small-scale experiments using the Rosette synthesis tool offer preliminary support for this proposed approach. But the possible rewards are not without danger: It is argued that the same approach can power a dangerous new level of sophistication for malware mutation and reactively adaptive software threats.},
  booktitle = {Proceedings of the 2016 New Security Paradigms Workshop},
  pages = {80–91},
  numpages = {12},
  keywords = {security, artificial diversity, program synthesis},
  location = {Granby, Colorado, USA},
  series = {NSPW '16}
}

  




@book{cox1893cinderella,
  title     = {Cinderella: Three hundred and forty-five variants of Cinderella, Catskin, and Cap o'Rushes},
  author    = {Cox, Marian Roalfe},
  number    = {31},
  year      = {1893},
  publisher = {Folk-lore Society}
}


@InProceedings{JStimers,
  author="Schwarz, Michael
  and Maurice, Cl{\'e}mentine
  and Gruss, Daniel
  and Mangard, Stefan",
  editor="Kiayias, Aggelos",
  title="Fantastic Timers and Where to Find Them: High-Resolution Microarchitectural Attacks in JavaScript",
  booktitle="Financial Cryptography and Data Security",
  year="2017",
  publisher="Springer International Publishing",
  address="Cham",
  pages="247--267",
  abstract="Research showed that microarchitectural attacks like cache attacks can be performed through websites using JavaScript. These timing attacks allow an adversary to spy on users secrets such as their keystrokes, leveraging fine-grained timers. However, the W3C and browser vendors responded to this significant threat by eliminating fine-grained timers from JavaScript. This renders previous high-resolution microarchitectural attacks non-applicable.",
  isbn="978-3-319-70972-7"
}


@inproceedings{padding,
  author = {Duck, Gregory J. and Gao, Xiang and Roychoudhury, Abhik},
  title = {Binary Rewriting without Control Flow Recovery},
  year = {2020},
  isbn = {9781450376136},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3385412.3385972},
  doi = {10.1145/3385412.3385972},
  abstract = {Static binary rewriting has many important applications in software security and systems, such as hardening, repair, patching, instrumentation, and debugging. While many different static binary rewriting tools have been proposed, most rely on recovering control flow information from the input binary. The recovery step is necessary since the rewriting process may move instructions, meaning that the set of jump targets in the rewritten binary needs to be adjusted accordingly. Since the static recovery of control flow information is a hard problem in general, most tools rely on a set of simplifying heuristics or assumptions, such as specific compilers, specific source languages, or binary file meta information. However, the reliance on assumptions or heuristics tends to scale poorly in practice, and most state-of-the-art static binary rewriting tools cannot handle very large/complex programs such as web browsers. In this paper we present E9Patch, a tool that can statically rewrite x86_64 binaries without any knowledge of control flow information. To do so, E9Patch develops a suite of binary rewriting methodologies---such as instruction punning, padding, and eviction---that can insert jumps to trampolines without the need to move other instructions. Since this preserves the set of jump targets, the need for control flow recovery and related heuristics is eliminated. As such, E9Patch is robust by design, and can scale to very large (>100MB) stripped binaries including the Google Chrome and FireFox web browsers. We also evaluate the effectiveness of E9Patch against realistic applications such as binary instrumentation, hardening and repair.},
  booktitle = {Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation},
  pages = {151–163},
  numpages = {13},
  keywords = {instruction eviction, binary instrumentation, binary patching, static binary rewriting, instruction punning, memory management, binary repair},
  location = {London, UK},
  series = {PLDI 2020}
}



@INPROCEEDINGS{7958599,
  author={Wang, Junjie and Chen, Bihuan and Wei, Lei and Liu, Yang},
  booktitle={2017 IEEE Symposium on Security and Privacy (SP)}, 
  title={Skyfire: Data-Driven Seed Generation for Fuzzing}, 
  year={2017},
  volume={},
  number={},
  pages={579-594},
  doi={10.1109/SP.2017.23}}

@article{10.1145/3498688,
  author = {Kolosick, Matthew and Narayan, Shravan and Johnson, Evan and Watt, Conrad and LeMay, Michael and Garg, Deepak and Jhala, Ranjit and Stefan, Deian},
  title = {Isolation without Taxation: Near-Zero-Cost Transitions for WebAssembly and SFI},
  year = {2022},
  issue_date = {January 2022},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {6},
  number = {POPL},
  url = {https://doi.org/10.1145/3498688},
  doi = {10.1145/3498688},
  abstract = {Software sandboxing or software-based fault isolation (SFI) is a lightweight approach to building secure systems out of untrusted components. Mozilla, for example, uses SFI to harden the Firefox browser by sandboxing third-party libraries, and companies like Fastly and Cloudflare use SFI to safely co-locate untrusted tenants on their edge clouds. While there have been significant efforts to optimize and verify SFI enforcement, context switching in SFI systems remains largely unexplored: almost all SFI systems use heavyweight transitions that are not only error-prone but incur significant performance overhead from saving, clearing, and restoring registers when context switching. We identify a set of zero-cost conditions that characterize when sandboxed code has sufficient structured to guarantee security via lightweight zero-cost transitions (simple function calls). We modify the Lucet Wasm compiler and its runtime to use zero-cost transitions, eliminating the undue performance tax on systems that rely on Lucet for sandboxing (e.g., we speed up image and font rendering in Firefox by up to 29.7\% and 10\% respectively). To remove the Lucet compiler and its correct implementation of the Wasm specification from the trusted computing base, we (1) develop a static binary verifier, VeriZero, which (in seconds) checks that binaries produced by Lucet satisfy our zero-cost conditions, and (2) prove the soundness of VeriZero by developing a logical relation that captures when a compiled Wasm function is semantically well-behaved with respect to our zero-cost conditions. Finally, we show that our model is useful beyond Wasm by describing a new, purpose-built SFI system, SegmentZero32, that uses x86 segmentation and LLVM with mostly off-the-shelf passes to enforce our zero-cost conditions; our prototype performs on-par with the state-of-the-art Native Client SFI system.},
  journal = {Proc. ACM Program. Lang.},
  month = {jan},
  articleno = {27},
  numpages = {30},
  keywords = {WebAssembly, sandboxing, software fault isolation, verification}
}


@ARTICLE{madvex,
       author = {{Loose}, Nils and {M{\"a}chtle}, Felix and {Pott}, Claudius and {Bezsmertnyi}, Volodymyr and {Eisenbarth}, Thomas},
        title = "{Madvex: Instrumentation-based Adversarial Attacks on Machine Learning Malware Detection}",
      journal = {arXiv e-prints},
     keywords = {Computer Science - Cryptography and Security},
         year = 2023,
        month = may,
          eid = {arXiv:2305.02559},
        pages = {arXiv:2305.02559},
          doi = {10.48550/arXiv.2305.02559},
archivePrefix = {arXiv},
       eprint = {2305.02559},
 primaryClass = {cs.CR},
       adsurl = {https://ui.adsabs.harvard.edu/abs/2023arXiv230502559L},
      adsnote = {Provided by the SAO/NASA Astrophysics Data System}
}


@inproceedings{10.1145/3339252.3339261,
  author = {Musch, Marius and Wressnegger, Christian and Johns, Martin and Rieck, Konrad},
  title = {Thieves in the Browser: Web-Based Cryptojacking in the Wild},
  year = {2019},
  isbn = {9781450371643},
  publisher = {Association for Computing Machinery},

  url = {https://doi.org/10.1145/3339252.3339261},
  doi = {10.1145/3339252.3339261},
  abstract = {With the introduction of memory-bound cryptocurrencies, such as Monero, the implementation of mining code in browser-based JavaScript has become a worthwhile alternative to dedicated mining rigs. Based on this technology, a new form of parasitic computing, widely called cryptojacking or drive-by mining, has gained momentum in the web. A cryptojacking site abuses the computing resources of its visitors to covertly mine for cryptocurrencies. In this paper, we systematically explore this phenomenon. For this, we propose a 3-phase analysis approach, which enables us to identify mining scripts and conduct a large-scale study on the prevalence of cryptojacking in the Alexa 1 million websites. We find that cryptojacking is common, with currently 1 out of 500 sites hosting a mining script. Moreover, we perform several secondary analyses to gain insight into the cryptojacking landscape, including a measurement of code characteristics, an estimate of expected mining revenue, and an evaluation of current blacklist-based countermeasures.},
  booktitle = {Proceedings of the 14th International Conference on Availability, Reliability and Security},
  articleno = {4},
  location = {Canterbury, CA, United Kingdom},
  series = {ARES '19}
}


@INPROCEEDINGS{9566204,

  author={Tekiner, Ege and Acar, Abbas and Uluagac, A. Selcuk and Kirda, Engin and Selcuk, Ali Aydin},

  booktitle={2021 IEEE International Conference on Decentralized Applications and Infrastructures (DAPPS)}, 

  title={In-Browser Cryptomining for Good: An Untold Story}, 

  year={2021},

  volume={},

  number={},

  pages={20-29},

  doi={10.1109/DAPPS52256.2021.00008}}


@article{feud,
  author = {Knight, J. C. and Leveson, N. G.},
  title = {An Experimental Evaluation of the Assumption of Independence in Multiversion Programming},
  year = {1986},
  issue_date = {January 1986},
  publisher = {IEEE Press},
  volume = {12},
  number = {1},
  issn = {0098-5589},
  url = {https://doi.org/10.1109/TSE.1986.6312924},
  doi = {10.1109/TSE.1986.6312924},
  abstract = {N-version programming has been proposed as a method of incorporating fault tolerance into software. Multiple versions of a program (i.e., “N”) are prepared and executed in parallel. Their outputs are collected and examined by a voter, and, if they are not identical, it is assumed that the majority is correct. This method depends for its reliability improvement on the assumption that programs that have been developed independently will fail independently. In this paper an experiment is described in which the fundamental axiom is tested. A total of 27 versions of a program were prepared independently from the same specification at two universities and then subjected to one million tests. The results of the tests revealed that the programs were individually extremely reliable but that the number of tests in which more than one program failed was substantially more than expected. The results of these tests are presented along with an analysis of some of the faults that were found in the programs. Background information on the programmers used is also summarized. The conclusion from this experiment is that N-version programming must be used with care and that analysis of its reliability must include the effect of dependent errors.},
  journal = {IEEE Trans. Softw. Eng.},
  month = {jan},
  pages = {96–109},
  numpages = {14},
  keywords = {multiversion programming, fault-tolerant software, Software reliability, NASA, N-version programming, Software, Programming, software reliability, Design diversity, Educational institutions}
}

  
@inproceedings{fred1986computer,
  title={Computer viruses},
  author={Fred, Cohen},
  booktitle={Proceedings of the 7th DoD/NBS Computer Security Conference 1984},
  pages={240--263},
  year={1986}
}


@inproceedings{castro2019aimed,
  title={Aimed: Evolving malware with genetic programming to evade detection},
  author={Castro, Raphael Labaca and Schmitt, Corinna and Dreo, Gabi},
  booktitle={2019 18th IEEE International Conference On Trust, Security And Privacy In Computing And Communications/13th IEEE International Conference On Big Data Science And Engineering (TrustCom/BigDataSE)},
  pages={240--247},
  year={2019},
  organization={IEEE}
}

@inproceedings{Aghakhani2020WhenMI,
  title={When Malware is Packin' Heat; Limits of Machine Learning Classifiers Based on Static Analysis Features},
  author={H. Aghakhani and Fabio Gritti and Francesco Mecca and Martina Lindorfer and Stefano Ortolani and Davide Balzarotti and Giovanni Vigna and Christopher Kruegel},
  booktitle={Proc. of NDSS},
  year={2020}
}

@article{Bostani2021EvadeDroidAP,
  author    = {Hamid Bostani and
               Veelasha Moonsamy},
  title     = {EvadeDroid: {A} Practical Evasion Attack on Machine Learning for Black-box
               Android Malware Detection},
  journal   = {CoRR},
  volume    = {abs/2110.03301},
  year      = {2021},
  url       = {https://arxiv.org/abs/2110.03301},
  eprinttype = {arXiv},
  eprint    = {2110.03301},
  timestamp = {Thu, 21 Oct 2021 16:20:08 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-2110-03301.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@ARTICLE{2021arXiv211111487D,
       author = {{Dasgupta}, Prithviraj and {Osman}, Zachariah},
        title = "{A Comparison of State-of-the-Art Techniques for Generating Adversarial Malware Binaries}",
      journal = {arXiv e-prints},
     keywords = {Computer Science - Cryptography and Security, Computer Science - Machine Learning, I.2.6},
         year = 2021,
        month = nov,
          eid = {arXiv:2111.11487},
archivePrefix = {arXiv},
       eprint = {2111.11487},
 primaryClass = {cs.CR},
       adsurl = {https://ui.adsabs.harvard.edu/abs/2021arXiv211111487D},
      adsnote = {Provided by the SAO/NASA Astrophysics Data System}
}


@inproceedings{Lu2013WeaknessesID,
  author    = {Gen Lu and
               Saumya K. Debray},
  editor    = {Konrad Rieck and
               Patrick Stewin and
               Jean{-}Pierre Seifert},
  title     = {Weaknesses in Defenses against Web-Borne Malware - (Short Paper)},
  booktitle = {Detection of Intrusions and Malware, and Vulnerability Assessment
               - 10th International Conference, {DIMVA}. Proceedings},
  series    = {Lecture Notes in Computer Science},
  year      = {2013},
  url       = {https://doi.org/10.1007/978-3-642-39235-1\_8},
  doi       = {10.1007/978-3-642-39235-1\_8},
  biburl    = {https://dblp.org/rec/conf/dimva/LuD13.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{wang2021exposing,
  title={Exposing weaknesses of malware detectors with explainability-guided evasion attacks},
  author={Wang, Wei and Sun, Ruoxi and Dong, Tian and Li, Shaofeng and Xue, Minhui and Tyson, Gareth and Zhu, Haojin},
  journal={arXiv preprint arXiv:2111.10085},
  year={2021}
}


@inproceedings{chua,
author = {Chua, Melissa and Balachandran, Vivek},
title = {Effectiveness of Android Obfuscation on Evading Anti-Malware},
year = {2018},
isbn = {9781450356329},
publisher = {Association for Computing Machinery},

url = {https://doi.org/10.1145/3176258.3176942},
doi = {10.1145/3176258.3176942},
abstract = {Obfuscation techniques have been conventionally used for legitimate applications, including preventing application reverse engineering, tampering and protecting intellectual property. A malware author could also leverage these benign techniques to hide their malicious intents and evade anti-malware detection. As variants of known malware have been regularly found on the Google Play Store, transformed malware attacks are a real problem that security solutions today need to address. It has been proven that mainstream security tools installed on smartphones are mainly signature-based; our work focuses on evaluating the efficiency of a composite of obfuscation techniques in evading anti-malware detection. We further verified the trend of transformed malware in evading detection, with a larger and more updated database of known malware. This is also the first work to-date that presents the instability of some anti-malware tools (AMTs) against obfuscated malware. This work also proved that current mainstream AMTs do not build up resilience against obfuscation methods, but instead try to update the signature database on created variants.},
booktitle = {Proceedings of the Eighth ACM Conference on Data and Application Security and Privacy},
numpages = {3},
keywords = {malware, android, obfuscation techniques},
location = {Tempe, AZ, USA},
series = {CODASPY '18}
}
  
@INPROCEEDINGS{36307,

  author={Eichin, M.W. and Rochlis, J.A.},

  booktitle={Proceedings. 1989 IEEE Symposium on Security and Privacy}, 

  title={With microscope and tweezers: an analysis of the Internet virus of November 1988}, 

  year={1989},

  volume={},

  number={},

  pages={326-343},

  doi={10.1109/SECPRI.1989.36307}}



@inproceedings{10.1145/2594291.2594334,
	author    = {Le, Vu and Afshari, Mehrdad and Su, Zhendong},
	title     = {Compiler Validation via Equivalence modulo Inputs},
	year      = {2014},
	booktitle = {Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation},
	pages     = {216–226},
	numpages  = {11},
	keywords  = {equivalent program variants, automated testing, miscompilation, compiler testing},
	location  = {Edinburgh, United Kingdom},
	series    = {PLDI ’14}
}

@ARTICLE{2023arXiv230514591Z,
       author = {{Zhang}, Kexun and {Wang}, Danqing and {Xia}, Jingtao and {Wang}, William Yang and {Li}, Lei},
        title = "{ALGO: Synthesizing Algorithmic Programs with Generated Oracle Verifiers}",
      journal = {arXiv e-prints},
     keywords = {Computer Science - Computation and Language, Computer Science - Software Engineering},
         year = 2023,
        month = may,
          eid = {arXiv:2305.14591},
        pages = {arXiv:2305.14591},
          doi = {10.48550/arXiv.2305.14591},
archivePrefix = {arXiv},
       eprint = {2305.14591},
 primaryClass = {cs.CL},
       adsurl = {https://ui.adsabs.harvard.edu/abs/2023arXiv230514591Z},
      adsnote = {Provided by the SAO/NASA Astrophysics Data System}
}


@article{cohen1987computer,
  title={Computer viruses: theory and experiments},
  author={Cohen, Fred},
  journal={Computers \& security},
  volume={6},
  number={1},
  pages={22--35},
  year={1987},
  publisher={Elsevier}
}


@article{forrest_system_call,
  author = {Hofmeyr, Steven A. and Forrest, Stephanie and Somayaji, Anil},
  title = {Intrusion Detection Using Sequences of System Calls},
  year = {1998},
  issue_date = {August 1998},
  publisher = {IOS Press},
  address = {NLD},
  volume = {6},
  number = {3},
  issn = {0926-227X},
  abstract = {A method is introduced for detecting intrusions at the level of privileged processes. Evidence is given that short sequences of system calls executed by running processes are a good discriminator between normal and abnormal operating characteristics of several common UNIX programs. Normal behavior is collected in two ways: Synthetically, by exercising as many normal modes of usage of a program as possible, and in a live user environment by tracing the actual execution of the program. In the former case several types of intrusive behavior were studied; in the latter case, results were analyzed for false positives.},
  journal = {J. Comput. Secur.},
  month = {aug},
  pages = {151–180},
  numpages = {30}
}

@book{yao2018anomaly,
  title={Anomaly detection as a service: challenges, advances, and opportunities},
  author={Yao, Danfeng and Shu, Xiaokui and Cheng, Long and Stolfo, Salvatore Joseph and Bertino, Elisa and Sandhu, Ravi},
  year={2018},
  publisher={Springer}
}


@ARTICLE{8482113, 
author={Y. {Fang} and C. {Huang} and L. {Liu} and M. {Xue}}, 
journal={IEEE Access}, 
title={Research on Malicious JavaScript Detection Technology Based on LSTM}, 
year={2018}, 
volume={6}, 
number={}, 
pages={59118-59125}, 
keywords={Malware;Feature extraction;Browsers;Engines;Web pages;Semantics;Bills of materials;JavaScript;malicious code detection;bytecode;word vector;LSTM}, 
doi={10.1109/ACCESS.2018.2874098}, 
ISSN={2169-3536}, 
month={},}

@article{DBLP:journals/corr/abs-2111-09934,
  author       = {Rodothea{-}Myrsini Tsoupidi and
                  Roberto Casta{\~{n}}eda Lozano and
                  Benoit Baudry},
  title        = {Constraint-based Diversification of {JOP} Gadgets},
  journal      = {CoRR},
  volume       = {abs/2111.09934},
  year         = {2021},
  url          = {https://arxiv.org/abs/2111.09934},
  eprinttype    = {arXiv},
  eprint       = {2111.09934},
  timestamp    = {Mon, 22 Nov 2021 16:44:07 +0100},
  biburl       = {https://dblp.org/rec/journals/corr/abs-2111-09934.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{gumtree,
 title = {Fine-grained and Accurate Source Code Differencing},
 author = {Falleri, Jean-R{\'e}my and Morandat, Flor{\'e}al and Blanc, Xavier and Martinez, Matias and Monperrus, Martin},
 url = {https://hal.archives-ouvertes.fr/hal-01054552/file/main.pdf},
 booktitle = {{Proceedings of the International Conference on Automated Software Engineering}},
 pages = {313-324},
 year = {2014},
 doi = {10.1145/2642937.2642982},
}

@INPROCEEDINGS{comparing_unix,
  author={Koopman, P. and DeVale, J.},
  booktitle={Digest of Papers. Twenty-Ninth Annual International Symposium on Fault-Tolerant Computing (Cat. No.99CB36352)}, 
  title={Comparing the robustness of POSIX operating systems}, 
  year={1999},
  volume={},
  number={},
  pages={30-37},
  doi={10.1109/FTCS.1999.781031}}

@InProceedings{sql_diversity,
  author="Gashi, Ilir
  and Popov, Peter
  and Stankovic, Vladimir
  and Strigini, Lorenzo",
  editor="de Lemos, Rog{\'e}rio
  and Gacek, Cristina
  and Romanovsky, Alexander",
  title="On Designing Dependable Services with Diverse Off-the-Shelf SQL Servers",
  booktitle="Architecting Dependable Systems II",
  year="2004",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="191--214",
  abstract="The most important non-functional requirements for an SQL server are performance and dependability. This paper argues, based on empirical results from our on-going research with diverse SQL servers, in favour of diverse redundancy as a way of improving both. We show evidence that current data replication solutions are insufficient to protect against the range of faults documented for database servers; outline possible fault-tolerant architectures using diverse servers; discuss the design problems involved; and offer evidence of the potential for performance improvement through diverse redundancy.",
  isbn="978-3-540-25939-8"
}

@ARTICLE{sql_diversity2,

  author={Gashi, Ilir and Popov, Peter and Strigini, Lorenzo},

  journal={IEEE Transactions on Dependable and Secure Computing}, 

  title={Fault Tolerance via Diversity for Off-the-Shelf Products: A Study with SQL Database Servers}, 

  year={2007},

  volume={4},

  number={4},

  pages={280-294},

  doi={10.1109/TDSC.2007.70208}}


@article{kesseli2018counterexample,
  title={Counterexample Guided Inductive Synthesis Modulo Theories},
  author={Kesseli, Pascal},
  year={2018}
}


@ARTICLE{2023arXiv230513241T,
       author = {{Titzer}, Ben L.},
        title = "{Whose Baseline (compiler) is it anyway?}",
      journal = {arXiv e-prints},
     keywords = {Computer Science - Programming Languages, D.3.4},
         year = 2023,
        month = may,
          eid = {arXiv:2305.13241},
        pages = {arXiv:2305.13241},
          doi = {10.48550/arXiv.2305.13241},
archivePrefix = {arXiv},
       eprint = {2305.13241},
 primaryClass = {cs.PL},
       adsurl = {https://ui.adsabs.harvard.edu/abs/2023arXiv230513241T},
      adsnote = {Provided by the SAO/NASA Astrophysics Data System}
}
