
\msection{\Wasm}
%% This will come in the Background section
%In WebAssembly, the type section wraps definitions of signatures for the binary functions.

\msubsection{WebAssembly ecosystems}
\label{background:wasm:ecosystems}

The \Wasm's ecosystem can be categorized into two groups: producers and consumers.
The former ones, such as compilers, are in charge of generating \Wasm binaries out of source code.
\todo{Do a rephrase here about the producers. what are the most common sources of Wasm etc}

The latter ones, such as browsers, are in charge of compiling, analyzing and executing \Wasm binaries.
\todo{Here, we discuss what happens after we get  Wasm binary? What to do with it?}
\todo{Mention, stress the landscape of tools that involve Wasm. Include analysis tools, fuzzers, optimizers and malware detectors.}



\todo{End up motivating the need of Software Diversification for: testing and reliability.}


\todo{The concept of managed and unmanaged data in Wasm from Lehman.}
\todo{Define: managed and unmanaged data, sections, execution stack, etc.}
\msubsection{Binary format}
\label{background:wasm:binary}

\Wasm's custom sections serve to save metadata, including details such as the compiler name responsible for generating the binary and symbol information pertinent to debugging. 
\tool alters custom sections. 


% General description and the introduction of the component, module and section terms
\wasm\ defines its own Instruction Set Architecture (ISA) \cite{wasm_spec}. It is an abstraction close to machine code instructions but agnostic to CPU architectures. Thus, Wasm  is platform independent. The ISA of Wasm  includes also the necessary components that the binary requires to run in any host engine. 
A Wasm  binary has a unique module as its main component. A module is composed by sections, corresponding to 13 types\footnote{\url{https://webassembly.github.io/spec/core/binary/modules.html\#sections}}, each of them with an explicit semantic and a specific order inside the module. This makes the compilation to machine code faster. %The binary format of Wasm  can include custom sections. For example, the work of \todo{Doe} proposed the usage of custom sections to sign binaries for the sake of trusting. 


% Example and intro to the stack
In \autoref{CExample} and \autoref{WASMExample} we illustrate a C program and the Wasm program that results from its compilation. The C function contains: heap allocation, external function declaration and the definition of a function with a loop, conditional branching, function calls and memory accesses. The code in \autoref{WASMExample} shows the textual format for the generated Wasm. The module in this case first defines the signature of the functions (\lineref{tpe1}, \lineref{tpe2}  and  \lineref{tpe3})  that help in the validation of the binary defining its parameter and result types. The information exchange between the host and the Wasm  binary might be in two ways, exporting and importing functions, memory and globals to and from the host engine (\lineref{import1}, \lineref{export1} and \lineref{export2}). The definition of the function (\lineref{func1}) and its body follows the last import declaration at \lineref{import1}. 

% Functions
The function body is composed of local-variable declarations and typed instructions that are evaluated using a virtual stack (Line 7 to Line 32 in \autoref{WASMExample}). Each instruction reads its operands from the stack and pushes back the result. The result of a function call is the top value of the stack at the end of the execution. In the case of \autoref{WASMExample}, the result value of the main function is the calculation of the last instruction, \texttt{i32.add} at \lineref{result}. A valid Wasm  binary should have a valid stack structure that is verified during its translation to machine code. The stack validation is carried out using the static types of Wasm, \texttt{i32} for 32 bits signed integer, \texttt{i64} for 64 bits signed integer, \texttt{f32} for 32 bits float and \texttt{f64} for 64 bits float. As the listing shows, instructions are annotated with a numeric type.

% Example
\begin{code}
    \begin{minipage}[t]{0.45\linewidth}
        \lstset{language=C,caption={Example C function.},
        label=CExample,
        breaklines=true, 
        basicstyle=\small\ttfamily,
        postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
        escapeinside={(*@}{@*)}
        }
%\input{sota/code/code.c}
\end{minipage}\hspace{10mm}
\begin{minipage}[t]{0.46\linewidth}
\lstset{
    language=WAT,
    caption={\wasm\ code  for \autoref{CExample}.},
    style=WATStyle,
    breaklines=true, 
    %stepnumber=0,
    escapeinside={(*@}{@*)},
    numbers=left,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
    label=WASMExample}
%
%\input{sota/code/code.fix.wat}
%\end{lstlisting}
\end{minipage}


%\begin{tikzpicture}[remember picture,overlay]

%\path (2.west) edge[<-, black] (1.west);
%\path (3.west) edge[<-,  black] (4.west);

%\path (6.east) edge[<-, bend right, black] (3.east);
%\path (9.east) edge[<-, bend right, black] (4.east);
%\path (7.east) edge[<-, bend right, black] (8.east);


%\end{tikzpicture}
\end{code}

% Memory, globals and functions
Wasm  manages the memory in a restricted way. A Wasm  module has a linear memory component that is accessed with \texttt{i32} pointers (integer of 32 bits) and should be isolated from the virtual stack. The declaration of the linear data in the memory is showed in \lineref{data}. The memory access is illustrated in \lineref{load}. This memory is usually bound in browser engines to 4Gb of size, and it is only shareable between the process that instantiate the Wasm  binary and the binary itself (explicitly declared in \lineref{mem1} and \lineref{export2}). This ensures the isolation of the execution of Wasm  code. 

Wasm  also provides global variables in their four primitive types. Global variables (\lineref{global1}) are only accessible by their declaration index, and it is not possible to dynamically address them. For functions, Wasm  follows the same mechanism, either the functions are called by their index (\lineref{call}) or using a static table of function declarations. The latter allows modeling dynamic calls of functions (through pointers) from languages such as C/C++, for which the Wasm's compiler is in charge of populating the static table of functions.


In Wasm, all instructions are grouped into blocks, where the start of a function is the root block. Two consecutive block declarations can be appreciated in \lineref{block1} and \lineref{block2} of \autoref{WASMExample}. Control flow structures jump between block boundaries and not to any position in the code like regular assembly code. A block may specify the state that the stack must have before its execution and the result stack value coming from its instructions. Inside the Wasm  binary the blocks explicitly define where they start and end (\lineref{end1} and \lineref{end2}). By design, each block executes independently and cannot execute or refer to outer block codes. This is guaranteed by explicitly annotating the state of the stack before and after the block. Three instructions handle the navigation between blocks: unconditional break, conditional break (\lineref{break1} and \lineref{break2}) and table break. Each break instruction can only jump to one of its enclosing blocks. For example, in \autoref{WASMExample}, \lineref{break1} forces the execution to jump to the end of the first block that starts at \lineref{block1} if the value at the top of the stack is greater than zero.


\msubsection{Types}
\msubsection{Memory model}
\label{background:wasm:memory}
\todo{Managed and unmanaged}
\msubsection{Execution model}
\label{background:wasm:execution}
\todo{Stack, frames and blocks}
\todo{First order breaks}

\todo{Words on version 1.0 and why our tools  have no issues with it.}
