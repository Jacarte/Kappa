\renewcommand{\tool}{WASM-MUTATE\xspace}
\msection{\tool: Fast and Effective Binary for WebAssembly}

In this section we present our third technical contribution, \tool \cite{wasmmutate}.
It takes a WebAssembly program as input and produces functionally equivalent variants.
\tool is highlighted as the blue squared tooling in \autoref{fig:approach_landscape}, its central approach involves synthesizing program variants by substituting parts of the original binary using rewriting rules, boosted by diversification space traversals using e-graphs \cite{e-graph}.

\begin{figure*}[h!]
    \centering
    \includegraphics[width=0.9\linewidth]{diagrams/wasm_mutate.workflow.pdf}
    \caption{ \tool high level architecture.  It generates semantically equivalent variants from a given WebAssembly binary input. 
    Its central approach involves synthesizing these variants by substituting parts of the original binary using rewriting rules, boosted by a diversification space traversals using e-graphs.}
  \label{fig:wasm-mutate}
\end{figure*}


\autoref{fig:wasm-mutate} illustrates the workflow of \tool, which initiates with a WebAssembly binary as its input. 
The first step involves parsing this binary to create suitable abstractions, e.g. an intermediate representation.
Subsequently, \tool utilizes predefined rewriting rules to construct an e-graph for the initial program, encapsulating all potential equivalent codes derived from the rewriting rules. 
Then, pieces of the original program are randomly substituted by the result of random e-graph traversals, resulting in a variant that maintains functional equivalence to the original binary. 
This assurance of semantic preservation is rooted in the inherent properties of the individual rewrite rules employed.
%Notice that, the output of \tool can be used back as an input, facilitating the stacking of multiple transformations through repeated \tool iterations.


%% Move this to the new in practice section


%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=.8\linewidth]{figures/process.pdf}
%    \caption{}
%  \label{fig:wasm-mutate-process}
%\end{figure}




\msubsection{WebAssembly Rewriting Rules}
\tool incorporates a total of 135 rewriting rules, organized into categories referred to as meta-rules. 
The rewriting rules are conceived based on the seminal work of Sasnauskas et al. \cite{2017arXiv171104422S}, extended to include a predicate to enforce the conditions for replacement. 
Each rule is articulated as a tuple, represented as \texttt{(LHS, RHS, Cond)}, where: \texttt{LHS} identifies the segment of code targeted for replacement, \texttt{RHS} outlines the functionally equivalent substitute, and \texttt{Cond} defines the circumstances permitting the replacements.
For example, in the case of \Wasm binaries, the \texttt{Cond} predicate ensures that the replacement does not violate the type constraints. 
The following text details the seven meta-rules utilized in \tool.


\wrule{Add type:}
\tool implements two rewrite rules for the Type Section of the input \Wasm program.
The following rewriting rule illustrated how WASM-MUTATE adds a new type definition. 

\input{snippets/snippets-wasm-mutate/structure_transform/add_type}

This transformation creates random function signatures, varying both, the number of parameters and the count of results. 
It ensures the consistency of the index of already defined types, even after the introduction of a new type.

\wrule{Add function:} 
%In a \wasm binary, the function and code sections contain the function declarations and their respective code bodies. 
\tool adds new random functions by mutating the code, section and function sections . 
This process begins with the creation of a random type signature, followed by the formulation of a random function body that simply returns the default value corresponding to the result type. 
An illustration of this rewriting rule is provided in the subsequent example.

\input{snippets/snippets-wasm-mutate/structure_transform/new_function}

\wrule{Remove dead code:} \tool randomly eliminates dead code, targeting specific elements such as \emph{functions, types, custom sections, imports, tables, memories, globals, data segments, and elements} that are verifiably unused. 
For instance, the removal of a memory declaration needs the absence of any memory access operations within the binary code. 
\tool incorporates distinct mutators for each element type to facilitate this process.
The following example showcases a function removal using this meta-rule.



\input{snippets/snippets-wasm-mutate/structure_transform/remove_function}


\wrule{Edit custom sections:} \Wasm's custom sections serve to save metadata, including details such as the compiler name responsible for generating the binary and symbol information pertinent to debugging. 
\tool alters custom sections. 
Through the \emph{Edit Custom Section} transformation, it can randomly change either the content or the name of the custom section, a process illustrated in the subsequent rewriting rule example.

\input{snippets/snippets-wasm-mutate/structure_transform/custom_section_edit}


\wrule{If swapping:} In \Wasm, the if-construction is compound of two paths: the consequence and the alternative. 
The determination of which execution path to follow depends on the branching condition evaluated just before the \texttt{if} instruction. 
Specifically, a value greater than \texttt{0} at the top of the execution stack triggers the execution of the consequence code, while any other outcome initiates the alternative code.
The \emph{if swapping} rewriting rule interchanges the consequence and alternative codes within the if-construction, effectively reversing the original paths defined by the condition.



To facilitate the swapping of an if-construction in \Wasm, \tool introduces a negation of the value situated at the top of the stack immediately preceding the \texttt{if} instruction. 
The methodology behind this rewriting is demonstrated in the following rewriting rule example.

\input{snippets/snippets-wasm-mutate/code_motion/if_swap}


In this context, the consequence and alternative codes are labeled with the letters \texttt{A} and \texttt{B}, respectively, while the if-construction's condition is represented as \texttt{C}. 
To negate this condition, the \texttt{i32.eqz} instruction is incorporated into the RHS segment of the rewriting rule, functioning to compare the stack's top value with zero and, if true, pushing the value \texttt{1} onto the stack.
In addition, \tool introduces a \texttt{nop} instruction to substitute for the absent code block, ensuring a seamless rewriting process.


\wrule{Loop Unrolling:} \tool randomly unrolls loops.
To unroll a loop WASM-MUTATE first creates a new \wasm block, which contains a copy of its body (unrolling) followed by the original loop.
The copy of the loop body is itself a \wasm block.
To maintain the original control flow functionality, the instructions inside the loop and their copied body need to be adjusted.
To adjust the loop, \tool modifies the loop instructions that are first-order breaks, i.e., jumps that lead back to the loop's beginning and end (see section \autoref{background:wasm:execution}). 

Inside the loop body there can be two types of first order breaks: the first type which lead back to the loop's beginning, and the second type jumps, which lead to the loop's end.
The second type is irrelevant for the unrolling process, since the loop's end is not modified.
To adjust first order breaks, in the case of the copied body, they need to break the \wasm block that contains the loop body copy, making the execution of the program to continue with the loop's original construction appended after it.
In the case of the original loop, the first order breaks need to interrupt the block that contains the loop body, making the execution of the program to continue as originally as the loop finishes.
In concrete, their jumping indexes need to be incremented by 1, going outside the loop-unrolling outer \wasm block.
In the following example we illustrate the unrolling of a loop.

\input{snippets/snippets-wasm-mutate/code_motion/loop_unroll}

In the LHS part of the rewriting rule, the loop showcases a solitary first-order break, signaling that its activation prompts continuous loop iterations. 
The loop's operational span concludes just before the \texttt{end} instruction, delineating the juncture where the original loop ceases and the broader program execution resumes.
When this loop is chosen for unrolling, it undergoes a bifurcation of its instructions into two distinct groups, \texttt{A} and \texttt{B}. 
The RHS part of the illustration brings to light the creation of two fresh Wasm blocks during the unrolling procedure. 
Here, the outer block is a repository for both the original and the duplicated loop bodies, while the inner entities, labeled \texttt{A'} and \texttt{B'}, embody alterations to the jump directives originally found in groups \texttt{A} and \texttt{B}.

Any jump directives within \texttt{A'} and \texttt{B'} that initially direct flow outside the loop need an increment of one in their jump indices. 
This modification is a response to the newly instituted block scope encircling the loop body in the course of unrolling. 
Moreover, the conclusion of the unrolled loop iteration's body is marked by the insertion of an unconditional branch. 
This strategic placement guarantees that, in the absence of a continuation in the loop body, the operation exits the scope.

%\todo{Stress that this modifies the unmmanaged data of the Wasm program.}


\wrule{Peephole:} 
This meta-rule  focuses on the rewriting of instruction sequences found within function bodies, representing the lowest level of rewriting. 
In \tool, we have devised 125 rewriting rules specifically for this category.
% This was already mentioned before when deininig the rewriting rules.
%To facilitate successful replacements, we employ a series of conditions, labeled as \texttt{Cond}, which can be used both interchangeably and in conjunction to limit transformations, as detailed in \autoref{alg}.
\tool is structured to ensure the determinism of the instructions selected for replacement.
Therefore, any rewriting rule inside the Peephole meta-rule avoids instructions that might induce undefined behavior, e.g., function calls.
Consequently, the scope of this meta-rule is confined to modifications in stack and memory operations, preserving the original functionality of the control frame labels.

The peephole category rewriting rules are meticulously designed and manually verified. 
An instance of a rewriting rule in this category can be appreciated below:

\input{snippets/snippets-wasm-mutate/peephole/peep.tex}

The previous rewriting rule example implies that the \texttt{LHS} 'x' is to be replaced by an idempotent bitwise \texttt{i32.or} operation with itself,  as soon as x, which can be any subexpression, leaves a value of type i32 in the exeution stack.

\msubsection{Extending peephole meta-rules with custom operators}
\label{custom}

As illustrated in \autoref{fig:wasm-mutate}, the initial step in the process involves parsing an input \Wasm program, generating an intermediate representation. 
This step facilitates the transition of the \Wasm program to the next stages of \tool. 
This representation extends the textual Wat format.
We augment it with custom operator instructions to enhance the transformation capabilities of \tool \cite{webassembly_runtime}.
Custom operator instructions form part of the lowest level of transformation we provide in \tool, the Peephole meta-rule.
These custom operator instructions are designed to bolster \tool by utilizing well-established code diversification techniques, e.g. inserting \texttt{nop} instructions \cite{NOP}.


Let us illustrate how we include the previously mentioned specific diversification strategy by supporting custom operator instructions.
In \tool, we add a \texttt{container} operator instruction, which acts as a holder for multiple instructions, enabling transformations without altering the program's semantics. 
Below, we demonstrate a rewriting rule that leverages it to insert \texttt{nop} instructions into the any \Wasm program place:

\input{snippets/snippets-wasm-mutate/structure_transform/container.tex}

The instruction \texttt{x}, can potentially be substituted with \texttt{container (x nop)}. 
When converting back to the \Wasm binary format from the intermediate representation, custom instructions are meticulously handled to retain the original functionality of the \Wasm program. 
Concretely, the \texttt{container} custom operator is removed, the \texttt{nop} instruction is replaced with the \texttt{nop} opcode, and \texttt{x}, which denotes a single instruction, is encoded with the appropriate opcode.

The \texttt{container} operator is one of four custom operator instructions introduced in the \tool intermediate representation. 
Specifically, we have added:
\mrule{UseGlobals:} this operator substitutes its operand with the setting and retrieval actions involving a newly created global variable.
\mrule{Constant unfolding:} this operator, working with a constant numeric operand, statically generates two numbers whose sum equals the constant, followed by the addition of operations for these numbers.
\mrule{Rand:} this operator injects random constant numbers into the program.
Significantly, this adaptability enables \tool to embrace a wide array of code diversification techniques at instruction level.

%\todo{Here we use each one of this custom operators in the next chapter.}

\msubsection{E-graphs}
\label{alg}

We developed \tool leveraging e-graphs, a specific graph data structure for representing rewriting rules \cite{10.1145/3571207}. 
Within an e-graph, there exist two distinct node types: e-nodes and e-classes. 
The former encapsulates either an operator or an operand present in the rewriting rule, while the latter groups e-nodes into equivalence classes, essentially serving as a composite virtual node that contains a collection of e-nodes. 
Consequently, each e-class contains at least one e-node, with edges delineating the operator-operand equivalence relations between e-nodes and e-classes.

%\todo{This is cryptic}
In the context of \tool, the e-graph is constructed from a WebAssembly program, drawing upon the analysis of its expressions and operations as depicted in data flow graphs. 
This entails the transformation of each distinct expression, operator, and operand into e-nodes. 
Next steps involve identifying equivalent expressions based on the corpus of rewriting rules, thereby clustering analogous e-nodes into e-classes. 
This phase might also witness the introduction of new operators to the graph as e-nodes.

As the final step, e-nodes in e-classes are interlinked through edges to illustrate their equivalence relationships, a dynamic process that evolves with the integration of new rewriting rules until reaching a point of equality saturation \cite{10.1145/1480881.1480915}.

% How to construct
Let us illustrate the e-graph construction with a program that consists of a single instruction which returns an integer constant, denoted as \texttt{i64.const 0}. 
Besides, assume a single rewriting rule defined as \texttt{(x, x i64.or x, x returns type i64)}.
In this scenario, the control flow graph of the program is quite straightforward, containing only a single node that stands for the lone instruction present. 
This rewriting rule is designed to express the equivalence of conducting an \texttt{or} operation where both operands are identical.



\begin{figure}
  \centering
  \includegraphics[width=0.5\linewidth]{figures/egraph1.pdf}
  \caption{e-graph for idempotent bitwise-or rewriting rule. Solid lines represent operand-operator relations, and dashed lines represent equivalent class inclusion. }
\label{e-graph}
\end{figure}


In \autoref{e-graph} we visualize how the e-graph data structure out of the program and rewriting rule.
The process begins with the incorporation of the solitary program instruction, \texttt{i64.const 0}, as an e-node, which is represented by the leftmost solid rectangle node in the diagram.
Then, we derive additional e-nodes from the rewriting rule, which is depicted by the rightmost solid rectangle in the figure. 
This involves introducing a fresh e-node labeled \texttt{i64.or} and establishing edges leading to the \texttt{x} e-node.
Next, the equivalence by merging the two e-nodes is affirmed, thus forming a unified e-class. 
This step needs the redirection of the existing edges to target the newly formed e-class associated with the \texttt{x} symbol.
Finally, we successfully construct an e-graph that encapsulates the relationships and equivalences dictated by the initial program and the rewriting rule, setting the stage for further analyses and transformations based on this structured representation.

\msubsection{Random e-graph traversal for variants generation}
\label{traversal}

% General use of case
Willsey et al. demonstrated the potential for high flexibility in extracting code fragments from e-graphs, a process that can be recursively orchestrated through a cost function applied to e-nodes and their respective operands.
This methodology ensures the semantic equivalence of the derived code \cite{e-graph}. 
For instance, to extract the "optimal" code from an e-graph, one might commence the extraction at a specific e-node, subsequently selecting the AST with the minimal size from the available options within the corresponding e-class's operands.
In \too omitting the cost function from the extraction strategy leads us to a significant property: \emph{any path navigated through the e-graph yields a semantically equivalent code variant}. 

The previous mentioned property is exploited in \autoref{e-graph}, showcasing the feasibility of crafting an endless series of "or" operations. 
We exploit such property to generate diverse \Wasm variants.
We propose and implement an algorithm that facilitates the random traversal of an e-graph to yield semantically equivalent program variants, as detailed in \autoref{peephole:mutator}. 
This algorithm operates by taking an e-graph, an e-class node (starting with the root's e-class), and a parameter specifying the maximum extraction depth of the expression, to prevent infinite recursion.
Within the algorithm, a random e-node is chosen from the e-class (as seen in lines 5 and 6), setting the stage for a recursive continuation with the offspring of the selected e-node (refer to line 8). 
Once the depth parameter reaches zero, the algorithm extracts the most concise expression available within the current e-class (line 3). 
Following this, the subexpressions are built (line 10) for each child node, culminating in the return of the complete expression (line 11).


\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}
\begin{algorithm}
    %\footnotesize
	\begin{algorithmic}[1]
	%	\Procedure{MyProcedure}{}
      \Procedure{traverse}{$egraph$, $eclass$, $depth$}
        \If{depth = 0}
          \State  \Return \textbf{smallest\_tree\_from}(egraph,\ eclass)
        \Else
            \State $nodes \gets egraph[eclass]$
            \State $node \gets random\_choice(nodes)$
            \State $expr \gets (node, operands=[])$
            \ForEach {$child \in node.children $}
                \State $subexpr \gets \textbf{TRAVERSE}(egraph,\ child,\ depth - 1)$
                \State $expr.operands \gets expr.operands \cup\ \{subexpr\}$
            \EndFor
            \State \Return $expr$
        \EndIf
        \EndProcedure
	\end{algorithmic} 
	\caption{e-graph traversal algorithm taken from \cite{wasm-mutate}.} 
	\label{peephole:mutator}
\end{algorithm}

\msubsection{\tool instantiation}

% \todo{FIX cross refs}

% Example of a random e-graph traversal 
Let us illustrate how \tool generates variant programs by using the before enunciated algorithm.
Here, we use Algorithm \ref{peephole:mutator} with maximum depth of 1.
In \autoref{example:peeporig} a hypothetical original Wasm binary is illustrated.
In this context, a potential user has set two pivotal rewriting rules: \texttt{(x, container (x nop),)} and \texttt{(x, x i32.add 0, x instanceof i32)}.
The initial rule, which has been previously discussed in \autoref{custom}, grants the ability to append a \texttt{nop} instruction to any subexpression within the program. 
Conversely, the latter rule articulates the equivalence of augmenting any numeric value by zero.
Both rules preserve the semantic of the original program when applied.

Leveraging the code presented in \autoref{example:peeporig} alongside the defined rewriting rules, we build the e-graph.
The resulting e-graph can be found in \autoref{e-graph3}. 
This graphical representation illustrates the relationships between operators and operands, delineated through arrows connecting the respective nodes.
The e-graph illustration highlights the potential execution paths for rewriting according to the established rules.

\input{snippets/snippets-wasm-mutate/peephole/peep_example}


\begin{figure}
    \centering
    \includegraphics[width=1.0\linewidth]{figures/e-graph-traversal2.pdf}
    \caption{e-graph built for rewriting the first instruction of \autoref{example:peeporig}. }
  \label{e-graph3}
\end{figure}



In \autoref{e-graph3}, we highlight various stages of Algorithm \ref{peephole:mutator} in the context of the scenario previously described. 
The algorithm initiates at the e-class with the instruction \texttt{i64.const 1}, as seen in \autoref{example:peeporig}.
At \step{2}, it randomly selects an equivalent node within the e-class, in this instance taking the \texttt{i64.add} node, resulting: {\texttt{expr = i64.add l r}}.

As the traversal advances to \step{3}, it follows on the left operand of the previously chosen node, settling on the \texttt{i64.const 0} node within the same e-class.
The process continues in \step{4}, where the right operand of the \texttt{i64.add} node is choosen, selecting the \texttt{container} operator yielding:
{\texttt{expr = i64.or (i64.const 0 container ( r nop ))}}.

At \step{5}, the algorithm chooses the right operand of the \texttt{container}, which correlates to the initial instruction e-node highlighted in \step{6}, culminating in the final expression:
{\texttt{expr = i64.or (i64.const 0 container( i64.const 1 nop))\ i64.const 1}}.

As we proceed to the subsequent encoding phases, the \texttt{container} operator is ignored as a real Wasm instruction, finally resulting the program in \autoref{example:peepapplied}.

Notice that, within the e-graph showcased in \autoref{e-graph3}, the container node maintains a presence across all e-classes. 
Consequently, increasing the depth parameter in \autoref{peephole:mutator} would potentially escalate the number of viable variants infinitely.

%s\todo{Augment this last paragraph.}
