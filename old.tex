
% make this page vertical
\begin{landscape}
    \begin{table}
        
    
        \centering
        \begin{adjustbox}{width=1\linewidth}
        \begin{tabular}{p{0.2\linewidth} | l l l l l l l l l l l l l}
                  & Core & Code & Types & Def.Functions & Debloats & Memory & Globals & Locals & Custom S. & If swap & Loop unroll & Constant inferring & MVE  \\
            \hline
            CROW & Superdiversifier & x  \\
            \hline
            MEWE & CROW & x\\
            \hline
            wasm-mutate & e-graphs & x & x & x & x & x & x & x & x & x & x \\
            
            
        \end{tabular}
        \end{adjustbox}
        \caption{Comparison between CROW, MEWE and wasm-mutate.}
    \end{table}
    \end{landscape}
    

    \todo{Comparison of the approaches.}
    \todo{Add the cool table.}
    
    % Move the following
    Other solutions would have been to diversify at the source-code level or the \wasm\ binary level. However, these facts would limit the applicability of our work.
    Our approach is more general as diversification also will work for other LLVM backends.
    
    % Why and main change
    \todo{This is contradictory to our binary solution.}
    We use the superdiversifier idea of Jacob and colleagues to implement CROW because of two main reasons.
    First, the code replacements generated by this technique outperform diversification strategies based on handwritten rules . 
    Concretely, we can control the quality of the generated codes. 
    Besides, CROW always generates equivalent programs because it is based on a solver to check for equivalence. 
    Second, there is a battle-tested superoptimizer for LLVM, Souper \cite. 
    This latter makes it feasible the construction of a generic LLVM superdiversifier. 


\begin{table}
    \centering
    \begin{tabular}[pos]{l|l|l|l|l}
         & Runtime & Managed memory & Unmanaged memory &   \\
        \hline
        CROW & No & Yes & Yes & No  \\
        MEWE & No & Yes & Yes & No \\
        WASM-MUTATE & Yes & Yes & Yes & Yes \\
    \end{tabular}
\end{table}


\begin{table}
    \centering
    \begin{tabular}[pos]{l|l|l|l|l}
         & Reversible & < Runtime & > Runtime & Fast gen. \\
        \hline
        CROW & No & Yes & Yes & No  \\
        MEWE & No & Yes & Yes & No \\
        WASM-MUTATE & Yes & Yes & Yes & Yes \\
    \end{tabular}
\end{table}

\begin{table}
    \centering
    \begin{tabular}[pos]{l|l|l|l|l}
         & Core & Automatic & In. & Out \\
        \hline
        CROW & SMT & 1 & LLVM & \wasm \\
        MEWE & CROW & 1 & LLVM & MVE \wasm \\
        WASM-MUTATE & e-graph & 0.5 & \wasm & \wasm \\
    \end{tabular}
\end{table}


%% From Lhemann

{
    \color{red}
    Why is program analysis of WebAssembly binaries worthwhile in
particular? First, WebAssemblyâ€™s position as the low-level bytecode for
the Web makes it highly relevant today and more so in the future. If
proponents of WebAssembly are to be believed, it has the potential to
become a universal bytecode for applications outside the browser as
well. Figure 1.1 shows that WebAssembly is the common interchange
format between multiple source languages compiling to WebAssem-
bly and different host environments executing it. Developing program
analyses for each individual source language, or for each of the differ-
ent runtimes does not scale. When source code is not available, there
is also no choice but to analyze the WebAssembly bytecode directly

Second, as a novel code format, analyzing WebAssembly is rife with
open challenges and opportunities. When statically instrumenting WebAssembly binaries, the rewriting needs to be type-aware, otherwise the
resulting binaries are no longer valid. Other characteristics of WebAs-
sembly also need to be taken into account, e.g., structured control-flow
with relative branch labels. At the same time, WebAssembly is a saner
format for binary analysis and rewriting than native machine code.
Static disassembly of WebAssembly is robust, and built-in validation
helps with the reliability of static rewriting. We will discuss challenges
and opportunities around WebAssembly in more detail in Section 1.4.

Last but not least, we believe research should yield practical insights,
datasets, and (prototype) tools that are useful to developers and other
researchers to build on. Web developers so far are mostly used to high-
level JavaScript programs. With WebAssembly, e.g., compiled from C
and C++ code, they require new tooling and guidelines for dealing
with memory vulnerabilities, or to make sense of a binary without
source code. We discuss the conceptual contributions of our work in
Section 1.5 and how the chapters of the dissertation map to publica-
tions and released artifacts in Section 1.6
}


In concrete, distributing the unmodified binary to 100 machines would, essentially, creates 100 homogeneously vulnerable machines.
However, let us illustrate the case with a different approach: each time the binary is replicated onto a different machine, we distribute a unique variant instead of the original binary. 
If we disseminate a unique variant, with X stacked transformations, to each machine, every system would run a distinct \wasm binary. 
Based on our findings, even when some binaries are still vulnerable, we can confidently say that if 100 variants of a vulnerable program, each furnished with X stacked transformations, are distributed, the impact of any potential attack is considerably mitigated.
While it's true that some variants may retain their original vulnerabilities, not all of them do. 
This significantly enhances overall security. 
Further reinforcing this point, let's consider the case of btb\_leakage. 
In this scenario, a suite of 100 variants, each featuring at least 200 stacked transformations, ensures full protection against potential threats, effectively securing the entire infrastructure.
Moreover, considering the results for the ret2spec attack, this property holds for the whole population of generated variants, despite the number of stacked transformations.
Therefore, \tool as a software diversification tool, is a peemptive solution to potential attacks.

This is particularly remarkable in the case of \emph{constant inferring} transformations (see \autoref{CROW:constant_inferring}).
This tool offers a significant advantage over CROW and MEWE as it permits transformations in any section of a \wasm program, not just the code section.
Moreover, it leverages a virtually cost-free e-graph traversal process, avoiding, as a direct consequence, the \emph{overlapping} issue seen in CROW and MEWE, as detailed in \autoref{section:crow:example}. 
In addition, since WASM-MUTATE operates at the binary level, it can modify functions incorporated by the \Wasm producer itself.
For example, this is the case of the \emph{wasm32-wasi} architecture.
While the original program might have a few lines of code, the underlying compiler might inject more functions to support the \emph{wasm32-wasi} architecture.
Thus, augmenting the diversification space available to WASM-MUTATE.
Moreover, WASM-MUTATE outperforms CROW and MEWE capabilities in terms of the number of generated variants.
Yet, the changes made by WASM-MUTATE might not be as preserved as the ones generated by CROW and MEWE.
Thus, the variants generated by WASM-MUTATE might be more susceptible of being reversed, e.g. by further optimization passes.


An advantage of WASM-MUTATE, compared to CROW and MEWE, is its capacity to transform non-code sections without impacting the runtime behavior of the original variant, a strategy that effectively shields against static binary analysis, including malware detection based on signature sets \cite{EVASION}.
For instance, it can modify the type section of a \Wasm program, a section typically utilized only for function signature validation during compilation and validation processes by the host engine. 
This thwarts compiler identification techniques, such as fingerprinting.
Besides, it can be used for masquerading as a different compilation source.
Thus, reducing the fingerprinting surface available to attackers.


The overhead introduced by the diversification is tunneable in all three tools.
CROW, MEWE, and WASM-MUTATE generate variants that potentially improve the original program's runtime performance, demystifying that software diversification inherently compromises performance.
Therefore, users of our tools could decide to use or not worst performant variants in their deployments.


